# This file was generated with nixidy resource generator, do not edit.
{
  lib,
  options,
  config,
  ...
}:

with lib;

let
  hasAttrNotNull = attr: set: hasAttr attr set && set.${attr} != null;

  attrsToList =
    values:
    if values != null then
      sort (
        a: b:
        if (hasAttrNotNull "_priority" a && hasAttrNotNull "_priority" b) then
          a._priority < b._priority
        else
          false
      ) (mapAttrsToList (n: v: v) values)
    else
      values;

  getDefaults =
    resource: group: version: kind:
    catAttrs "default" (
      filter (
        default:
        (default.resource == null || default.resource == resource)
        && (default.group == null || default.group == group)
        && (default.version == null || default.version == version)
        && (default.kind == null || default.kind == kind)
      ) config.defaults
    );

  types = lib.types // rec {
    str = mkOptionType {
      name = "str";
      description = "string";
      check = isString;
      merge = mergeEqualOption;
    };

    # Either value of type `finalType` or `coercedType`, the latter is
    # converted to `finalType` using `coerceFunc`.
    coercedTo =
      coercedType: coerceFunc: finalType:
      mkOptionType rec {
        inherit (finalType) getSubOptions getSubModules;

        name = "coercedTo";
        description = "${finalType.description} or ${coercedType.description}";
        check = x: finalType.check x || coercedType.check x;
        merge =
          loc: defs:
          let
            coerceVal =
              val:
              if finalType.check val then
                val
              else
                let
                  coerced = coerceFunc val;
                in
                assert finalType.check coerced;
                coerced;

          in
          finalType.merge loc (map (def: def // { value = coerceVal def.value; }) defs);
        substSubModules = m: coercedTo coercedType coerceFunc (finalType.substSubModules m);
        typeMerge = t1: t2: null;
        functor = (defaultFunctor name) // {
          wrapped = finalType;
        };
      };
  };

  mkOptionDefault = mkOverride 1001;

  mergeValuesByKey =
    attrMergeKey: listMergeKeys: values:
    listToAttrs (
      imap0 (
        i: value:
        nameValuePair (
          if hasAttr attrMergeKey value then
            if isAttrs value.${attrMergeKey} then
              toString value.${attrMergeKey}.content
            else
              (toString value.${attrMergeKey})
          else
            # generate merge key for list elements if it's not present
            "__kubenix_list_merge_key_"
            + (concatStringsSep "" (
              map (
                key: if isAttrs value.${key} then toString value.${key}.content else (toString value.${key})
              ) listMergeKeys
            ))
        ) (value // { _priority = i; })
      ) values
    );

  submoduleOf =
    ref:
    types.submodule (
      { name, ... }:
      {
        options = definitions."${ref}".options or { };
        config = definitions."${ref}".config or { };
      }
    );

  globalSubmoduleOf =
    ref:
    types.submodule (
      { name, ... }:
      {
        options = config.definitions."${ref}".options or { };
        config = config.definitions."${ref}".config or { };
      }
    );

  submoduleWithMergeOf =
    ref: mergeKey:
    types.submodule (
      { name, ... }:
      let
        convertName =
          name: if definitions."${ref}".options.${mergeKey}.type == types.int then toInt name else name;
      in
      {
        options = definitions."${ref}".options // {
          # position in original array
          _priority = mkOption {
            type = types.nullOr types.int;
            default = null;
            internal = true;
          };
        };
        config = definitions."${ref}".config // {
          ${mergeKey} = mkOverride 1002 (
            # use name as mergeKey only if it is not coming from mergeValuesByKey
            if (!hasPrefix "__kubenix_list_merge_key_" name) then convertName name else null
          );
        };
      }
    );

  submoduleForDefinition =
    ref: resource: kind: group: version:
    let
      apiVersion = if group == "core" then version else "${group}/${version}";
    in
    types.submodule (
      { name, ... }:
      {
        inherit (definitions."${ref}") options;

        imports = getDefaults resource group version kind;
        config = mkMerge [
          definitions."${ref}".config
          {
            kind = mkOptionDefault kind;
            apiVersion = mkOptionDefault apiVersion;

            # metdata.name cannot use option default, due deep config
            metadata.name = mkOptionDefault name;
          }
        ];
      }
    );

  coerceAttrsOfSubmodulesToListByKey =
    ref: attrMergeKey: listMergeKeys:
    (types.coercedTo (types.listOf (submoduleOf ref)) (mergeValuesByKey attrMergeKey listMergeKeys) (
      types.attrsOf (submoduleWithMergeOf ref attrMergeKey)
    ));

  definitions = {
    "operator.victoriametrics.com.v1.VLAgent" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VLAgentSpec defines the desired state of VLAgent";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpec"));
        };
        "status" = mkOption {
          description = "VLAgentStatus defines the observed state of VLAgent";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpec" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for VLAgent in Mode: StatefulSet";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplates")
            )
          );
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvs" "name" [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvsFrom"))
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecHostAliases"))
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecHost_aliases"))
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLAgentSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VLAgent to be configured with.";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VLAgent to be configured with.\nINFO, WARN, ERROR, FATAL, PANIC";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecManagedMetadata"));
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecPersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecPodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the vlagent pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecPodMetadata"));
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "remoteWrite" = mkOption {
          description = "RemoteWrite list of victoria logs endpoints\nfor victorialogs it must looks like: http://victoria-logs-single:9428/\nor for cluster different url\nhttps://docs.victoriametrics.com/victorialogs/vlagent/#replication-and-high-availability";
          type = (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWrite"));
        };
        "remoteWriteSettings" = mkOption {
          description = "RemoteWriteSettings defines global settings for all remoteWrite urls.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteSettings")
          );
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecResources"));
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdateStrategy" = mkOption {
          description = "StatefulRollingUpdateStrategy allows configuration for strategyType\nset it to RollingUpdate for disabling operator statefulSet rollingUpdate";
          type = (types.nullOr types.str);
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vlagent VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vlagent service spec";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecServiceSpec"));
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "StatefulStorage configures storage for StatefulSet";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorage"));
        };
        "syslogSpec" = mkOption {
          description = "SyslogSpec defines syslog listener configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpec"));
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecTolerations"))
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLAgentSpecVolumeMounts" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "remoteWriteSettings" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdateStrategy" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "syslogSpec" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplates" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr types.attrs);
        };
        "spec" = mkOption {
          description = "spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpec"));
        };
        "status" = mkOption {
          description = "status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesStatus")
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecDataSource")
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecResources")
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecSelector")
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesSpecSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesStatusConditions" = {

      options = {
        "lastProbeTime" = mkOption {
          description = "lastProbeTime is the time we probed the condition.";
          type = (types.nullOr types.str);
        };
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the time the condition transitioned from one status to another.";
          type = (types.nullOr types.str);
        };
        "message" = mkOption {
          description = "message is the human-readable message indicating details about last transition.";
          type = (types.nullOr types.str);
        };
        "reason" = mkOption {
          description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
          type = (types.nullOr types.str);
        };
        "status" = mkOption {
          description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
          type = types.str;
        };
      };

      config = {
        "lastProbeTime" = mkOverride 1002 null;
        "lastTransitionTime" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecClaimTemplatesStatusModifyVolumeStatus" = {

      options = {
        "status" = mkOption {
          description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
          type = types.str;
        };
        "targetVolumeAttributesClassName" = mkOption {
          description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "targetVolumeAttributesClassName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLAgentSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvsFromConfigMapRef")
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecPersistentVolumeClaimRetentionPolicy" = {

      options = {
        "whenDeleted" = mkOption {
          description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
          type = (types.nullOr types.str);
        };
        "whenScaled" = mkOption {
          description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "whenDeleted" = mkOverride 1002 null;
        "whenScaled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWrite" = {

      options = {
        "bearerTokenPath" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteBearerTokenSecret")
          );
        };
        "headers" = mkOption {
          description = "Headers allow configuring custom http headers\nMust be in form of semicolon separated header with value\ne.g.\nheaderName: headerValue";
          type = (types.nullOr (types.listOf types.str));
        };
        "maxDiskUsage" = mkOption {
          description = "MaxDiskUsage defines the maximum file-based buffer size in bytes for the given remoteWrite\nIt overrides global configuration defined at remoteWriteSettings.maxDiskUsagePerURL";
          type = (types.nullOr types.attrs);
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteOauth2"));
        };
        "proxyURL" = mkOption {
          description = "ProxyURL for -remoteWrite.url. Supported proxies: http, https, socks5. Example: socks5://proxy:1234";
          type = (types.nullOr types.str);
        };
        "sendTimeout" = mkOption {
          description = "Timeout for sending a single block of data to -remoteWrite.url (default 1m0s)";
          type = (types.nullOr types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig describes tls configuration for remote write target";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfig")
          );
        };
        "url" = mkOption {
          description = "URL of the endpoint to send samples to.";
          type = types.str;
        };
      };

      config = {
        "bearerTokenPath" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "maxDiskUsage" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "sendTimeout" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteOauth2" = {

      options = {
        "clientIDFile" = mkOption {
          description = "ClientIDFile defines path to pre-mounted OAuth2 client id";
          type = (types.nullOr types.str);
        };
        "clientIDSecret" = mkOption {
          description = "ClientIDSecret defines secret or configmap containing the OAuth2 client id";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteOauth2ClientIDSecret"
            )
          );
        };
        "clientSecret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteOauth2ClientSecret"
            )
          );
        };
        "clientSecretFile" = mkOption {
          description = "ClientSecretFile defines path to pre-mounted OAuth2 client secret";
          type = (types.nullOr types.str);
        };
        "endpointParams" = mkOption {
          description = "EndpointParams to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "scopes" = mkOption {
          description = "Scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tokenURL" = mkOption {
          description = "TokenURL defines URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "clientIDFile" = mkOverride 1002 null;
        "clientIDSecret" = mkOverride 1002 null;
        "clientSecret" = mkOverride 1002 null;
        "clientSecretFile" = mkOverride 1002 null;
        "endpointParams" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteOauth2ClientIDSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteOauth2ClientSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteSettings" = {

      options = {
        "flushInterval" = mkOption {
          description = "Interval for flushing the data to remote storage. (default 1s)";
          type = (types.nullOr types.str);
        };
        "maxBlockSize" = mkOption {
          description = "The maximum size of unpacked request to send to remote storage";
          type = (types.nullOr types.attrs);
        };
        "maxDiskUsagePerURL" = mkOption {
          description = "The maximum file-based buffer size in bytes at -remoteWrite.tmpDataPath";
          type = (types.nullOr types.attrs);
        };
        "queues" = mkOption {
          description = "The number of concurrent queues";
          type = (types.nullOr types.int);
        };
        "showURL" = mkOption {
          description = "Whether to show -remoteWrite.url in the exported metrics. It is hidden by default, since it can contain sensitive auth info";
          type = (types.nullOr types.bool);
        };
        "tmpDataPath" = mkOption {
          description = "Path to directory where temporary data for remote write component is stored (default /vlagent_pq/vlagent-remotewrite-data)\nIf defined, operator ignores spec.storage field and skips adding volume and volumeMount for pq";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "flushInterval" = mkOverride 1002 null;
        "maxBlockSize" = mkOverride 1002 null;
        "maxDiskUsagePerURL" = mkOverride 1002 null;
        "queues" = mkOverride 1002 null;
        "showURL" = mkOverride 1002 null;
        "tmpDataPath" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfig" = {

      options = {
        "caFile" = mkOption {
          description = "CAFile defines path to the pre-mounted file with TLS ca certificate";
          type = (types.nullOr types.str);
        };
        "caSecretKeyRef" = mkOption {
          description = "CASecret defines secret reference with tls CA key by given key";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfigCaSecretKeyRef"
            )
          );
        };
        "certFile" = mkOption {
          description = "CertFile defines path to the pre-mounted file with TLS certificate\nmutually exclusive with CertSecret";
          type = (types.nullOr types.str);
        };
        "certSecretKeyRef" = mkOption {
          description = "CertSecret defines secret reference with TLS cert by given key\nmutually exclusive with CASecret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfigCertSecretKeyRef"
            )
          );
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "KeyFile defines path to the pre-mounted file with TLS cert key\nmutually exclusive with CertSecret";
          type = (types.nullOr types.str);
        };
        "keySecretKeyRef" = mkOption {
          description = "CertSecret defines secret reference with TLS key by given key";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfigKeySecretKeyRef"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "caFile" = mkOverride 1002 null;
        "caSecretKeyRef" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "certSecretKeyRef" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecretKeyRef" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfigCaSecretKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfigCertSecretKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecRemoteWriteTlsConfigKeySecretKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLAgentSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageEmptyDir"));
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplate")
          );
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplate" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "EmbeddedMetadata contains metadata relevant to an EmbeddedResource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "Spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpec"
            )
          );
        };
        "status" = mkOption {
          description = "Status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateStatus"
            )
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecSelector"
            )
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateStatusConditions" = {

      options = {
        "lastProbeTime" = mkOption {
          description = "lastProbeTime is the time we probed the condition.";
          type = (types.nullOr types.str);
        };
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the time the condition transitioned from one status to another.";
          type = (types.nullOr types.str);
        };
        "message" = mkOption {
          description = "message is the human-readable message indicating details about last transition.";
          type = (types.nullOr types.str);
        };
        "reason" = mkOption {
          description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
          type = (types.nullOr types.str);
        };
        "status" = mkOption {
          description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
          type = types.str;
        };
      };

      config = {
        "lastProbeTime" = mkOverride 1002 null;
        "lastTransitionTime" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus" = {

      options = {
        "status" = mkOption {
          description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
          type = types.str;
        };
        "targetVolumeAttributesClassName" = mkOption {
          description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "targetVolumeAttributesClassName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpec" = {

      options = {
        "tcpListeners" = mkOption {
          description = "TCPListeners defines syslog server TCP listener configuration";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListeners")
            )
          );
        };
        "udpListeners" = mkOption {
          description = "UDPListeners defines syslog server UDP listener configuration";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecUdpListeners")
            )
          );
        };
      };

      config = {
        "tcpListeners" = mkOverride 1002 null;
        "udpListeners" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListeners" = {

      options = {
        "compressMethod" = mkOption {
          description = "CompressMethod for syslog messages\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression";
          type = (types.nullOr types.str);
        };
        "decolorizeFields" = mkOption {
          description = "DecolorizeFields to remove ANSI color codes across logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields";
          type = (types.nullOr types.str);
        };
        "ignoreFields" = mkOption {
          description = "IgnoreFields to ignore at logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields";
          type = (types.nullOr types.str);
        };
        "listenPort" = mkOption {
          description = "ListenPort defines listen port";
          type = types.int;
        };
        "streamFields" = mkOption {
          description = "StreamFields to use as log stream labels\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields";
          type = (types.nullOr types.str);
        };
        "tenantID" = mkOption {
          description = "TenantID for logs ingested in form of accountID:projectID\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs";
          type = (types.nullOr types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListenersTlsConfig"
            )
          );
        };
      };

      config = {
        "compressMethod" = mkOverride 1002 null;
        "decolorizeFields" = mkOverride 1002 null;
        "ignoreFields" = mkOverride 1002 null;
        "streamFields" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListenersTlsConfig" = {

      options = {
        "certFile" = mkOption {
          description = "CertFile defines path to the pre-mounted file with certificate\nmutually exclusive with CertSecret";
          type = (types.nullOr types.str);
        };
        "certSecret" = mkOption {
          description = "CertSecretRef defines reference for secret with certificate content under given key\nmutually exclusive with CertFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret"
            )
          );
        };
        "keyFile" = mkOption {
          description = "KeyFile defines path to the pre-mounted file with certificate key\nmutually exclusive with KeySecretRef";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Key defines reference for secret with certificate key content under given key\nmutually exclusive with KeyFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret"
            )
          );
        };
      };

      config = {
        "certFile" = mkOverride 1002 null;
        "certSecret" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListenersTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecTcpListenersTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecSyslogSpecUdpListeners" = {

      options = {
        "compressMethod" = mkOption {
          description = "CompressMethod for syslog messages\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression";
          type = (types.nullOr types.str);
        };
        "decolorizeFields" = mkOption {
          description = "DecolorizeFields to remove ANSI color codes across logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields";
          type = (types.nullOr types.str);
        };
        "ignoreFields" = mkOption {
          description = "IgnoreFields to ignore at logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields";
          type = (types.nullOr types.str);
        };
        "listenPort" = mkOption {
          description = "ListenPort defines listen port";
          type = types.int;
        };
        "streamFields" = mkOption {
          description = "StreamFields to use as log stream labels\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields";
          type = (types.nullOr types.str);
        };
        "tenantID" = mkOption {
          description = "TenantID for logs ingested in form of accountID:projectID\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "compressMethod" = mkOverride 1002 null;
        "decolorizeFields" = mkOverride 1002 null;
        "ignoreFields" = mkOverride 1002 null;
        "streamFields" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLAgentStatusConditions"))
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "replicas" = mkOption {
          description = "ReplicaCount Total number of pods targeted by this VLAgent";
          type = (types.nullOr types.int);
        };
        "selector" = mkOption {
          description = "Selector string form of label value set for autoscaling";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "replicas" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLAgentStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLCluster" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VLClusterSpec defines the desired state of VLCluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpec"));
        };
        "status" = mkOption {
          description = "VLClusterStatus defines the observed state of VLCluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpec" = {

      options = {
        "clusterDomainName" = mkOption {
          description = "ClusterDomainName defines domain name suffix for in-cluster dns addresses\naka .cluster.local\nused by vlinsert and vlselect to build vlstorage address";
          type = (types.nullOr types.str);
        };
        "clusterVersion" = mkOption {
          description = "ClusterVersion defines default images tag for all components.\nit can be overwritten with component specific image.tag value.";
          type = (types.nullOr types.str);
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLClusterSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecManagedMetadata"));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "requestsLoadBalancer" = mkOption {
          description = "RequestsLoadBalancer configures load-balancing for vlinsert and vlselect requests.\nIt helps to evenly spread load across pods.\nUsually it's not possible with Kubernetes TCP-based services.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecRequestsLoadBalancer")
          );
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the\nVLSelect, VLInsert and VLStorage Pods.";
          type = (types.nullOr types.str);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "vlinsert" = mkOption {
          description = "VLInsert defines vlinsert component configuration at victoria-logs cluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsert"));
        };
        "vlselect" = mkOption {
          description = "VLSelect defines vlselect component configuration at victoria-logs cluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselect"));
        };
        "vlstorage" = mkOption {
          description = "VLStorage defines vlstorage component configuration at victoria-logs cluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorage"));
        };
      };

      config = {
        "clusterDomainName" = mkOverride 1002 null;
        "clusterVersion" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "requestsLoadBalancer" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "vlinsert" = mkOverride 1002 null;
        "vlselect" = mkOverride 1002 null;
        "vlstorage" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecRequestsLoadBalancer" = {

      options = {
        "disableInsertBalancing" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "disableSelectBalancing" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "enabled" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "spec" = mkOption {
          description = "VMAuthLoadBalancerSpec defines configuration spec for VMAuth used as load-balancer\nfor VMCluster component";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "disableInsertBalancing" = mkOverride 1002 null;
        "disableSelectBalancing" = mkOverride 1002 null;
        "enabled" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsert" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertDnsConfig")
          );
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertHost_aliases")
            )
          );
        };
        "hpa" = mkOption {
          description = "Configures horizontal pod autoscaling.";
          type = (types.nullOr types.attrs);
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlinsertImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VLSelect to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VLSelect to be configured with.";
          type = (types.nullOr types.str);
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertPodDisruptionBudget"
            )
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertPodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertResources")
          );
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertRollingUpdate")
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vlselect service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "syslogSpec" = mkOption {
          description = "SyslogSpec defines syslog listener configuration";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpec")
          );
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlinsertVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "hpa" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "syslogSpec" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlinsertDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlinsertResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertServiceSpecMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpec" = {

      options = {
        "tcpListeners" = mkOption {
          description = "TCPListeners defines syslog server TCP listener configuration";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListeners"
              )
            )
          );
        };
        "udpListeners" = mkOption {
          description = "UDPListeners defines syslog server UDP listener configuration";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecUdpListeners"
              )
            )
          );
        };
      };

      config = {
        "tcpListeners" = mkOverride 1002 null;
        "udpListeners" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListeners" = {

      options = {
        "compressMethod" = mkOption {
          description = "CompressMethod for syslog messages\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression";
          type = (types.nullOr types.str);
        };
        "decolorizeFields" = mkOption {
          description = "DecolorizeFields to remove ANSI color codes across logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields";
          type = (types.nullOr types.str);
        };
        "ignoreFields" = mkOption {
          description = "IgnoreFields to ignore at logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields";
          type = (types.nullOr types.str);
        };
        "listenPort" = mkOption {
          description = "ListenPort defines listen port";
          type = types.int;
        };
        "streamFields" = mkOption {
          description = "StreamFields to use as log stream labels\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields";
          type = (types.nullOr types.str);
        };
        "tenantID" = mkOption {
          description = "TenantID for logs ingested in form of accountID:projectID\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs";
          type = (types.nullOr types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig"
            )
          );
        };
      };

      config = {
        "compressMethod" = mkOverride 1002 null;
        "decolorizeFields" = mkOverride 1002 null;
        "ignoreFields" = mkOverride 1002 null;
        "streamFields" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListenersTlsConfig" = {

      options = {
        "certFile" = mkOption {
          description = "CertFile defines path to the pre-mounted file with certificate\nmutually exclusive with CertSecret";
          type = (types.nullOr types.str);
        };
        "certSecret" = mkOption {
          description = "CertSecretRef defines reference for secret with certificate content under given key\nmutually exclusive with CertFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret"
            )
          );
        };
        "keyFile" = mkOption {
          description = "KeyFile defines path to the pre-mounted file with certificate key\nmutually exclusive with KeySecretRef";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Key defines reference for secret with certificate key content under given key\nmutually exclusive with KeyFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret"
            )
          );
        };
      };

      config = {
        "certFile" = mkOverride 1002 null;
        "certSecret" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecTcpListenersTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertSyslogSpecUdpListeners" = {

      options = {
        "compressMethod" = mkOption {
          description = "CompressMethod for syslog messages\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression";
          type = (types.nullOr types.str);
        };
        "decolorizeFields" = mkOption {
          description = "DecolorizeFields to remove ANSI color codes across logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields";
          type = (types.nullOr types.str);
        };
        "ignoreFields" = mkOption {
          description = "IgnoreFields to ignore at logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields";
          type = (types.nullOr types.str);
        };
        "listenPort" = mkOption {
          description = "ListenPort defines listen port";
          type = types.int;
        };
        "streamFields" = mkOption {
          description = "StreamFields to use as log stream labels\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields";
          type = (types.nullOr types.str);
        };
        "tenantID" = mkOption {
          description = "TenantID for logs ingested in form of accountID:projectID\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "compressMethod" = mkOverride 1002 null;
        "decolorizeFields" = mkOverride 1002 null;
        "ignoreFields" = mkOverride 1002 null;
        "streamFields" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlinsertVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselect" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectDnsConfig")
          );
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvsFrom")
            )
          );
        };
        "extraStorageNodes" = mkOption {
          description = "ExtraStorageNodes - defines additional storage nodes to VLSelect";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraStorageNodes")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectHost_aliases")
            )
          );
        };
        "hpa" = mkOption {
          description = "Configures horizontal pod autoscaling.";
          type = (types.nullOr types.attrs);
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlselectImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VLSelect to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VLSelect to be configured with.";
          type = (types.nullOr types.str);
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectPodDisruptionBudget"
            )
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VLSelect pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectPodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectResources")
          );
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectRollingUpdate")
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vlselect service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlselectVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "extraStorageNodes" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "hpa" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlselectDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectExtraStorageNodes" = {

      options = {
        "addr" = mkOption {
          description = "Addr defines storage node address";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlselectResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlselectServiceSpecMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlselectVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorage" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageDnsConfig")
          );
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvsFrom")
            )
          );
        };
        "futureRetention" = mkOption {
          description = "FutureRetention for the stored logs\nLog entries with timestamps bigger than now+futureRetention are rejected during data ingestion; see https://docs.victoriametrics.com/victorialogs/#retention";
          type = (types.nullOr types.str);
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageHost_aliases")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlstorageImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VLStorage to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logIngestedRows" = mkOption {
          description = "Whether to log all the ingested log entries; this can be useful for debugging of data ingestion; see https://docs.victoriametrics.com/victorialogs/data-ingestion/";
          type = (types.nullOr types.bool);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VLStorage to be configured with.";
          type = (types.nullOr types.str);
        };
        "logNewStreams" = mkOption {
          description = "LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams; see https://docs.victoriametrics.com/victorialogs/keyconcepts/#stream-fields";
          type = (types.nullOr types.bool);
        };
        "maintenanceInsertNodeIDs" = mkOption {
          description = "MaintenanceInsertNodeIDs - excludes given node ids from insert requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.\nlets say, you have pod-0, pod-1, pod-2, pod-3. to exclude pod-0 and pod-3 from insert routing, define nodeIDs: [0,3].\nUseful at storage expanding, when you want to rebalance some data at cluster.";
          type = (types.nullOr (types.listOf types.int));
        };
        "maintenanceSelectNodeIDs" = mkOption {
          description = "MaintenanceInsertNodeIDs - excludes given node ids from select requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.";
          type = (types.nullOr (types.listOf types.int));
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstoragePodDisruptionBudget"
            )
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VLStorage pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstoragePodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageResources")
          );
        };
        "retentionMaxDiskSpaceUsageBytes" = mkOption {
          description = "RetentionMaxDiskSpaceUsageBytes for the stored logs\nVictoriaLogs keeps at least two last days of data in order to guarantee that the logs for the last day can be returned in queries.\nThis means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,\nif the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.\nhttps://docs.victoriametrics.com/victorialogs/#retention-by-disk-space-usage";
          type = (types.nullOr types.str);
        };
        "retentionPeriod" = mkOption {
          description = "RetentionPeriod for the stored logs\nhttps://docs.victoriametrics.com/victorialogs/#retention";
          type = (types.nullOr types.str);
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdateStrategy" = mkOption {
          description = "RollingUpdateStrategy defines strategy for application updates\nDefault is OnDelete, in this case operator handles update process\nCan be changed for RollingUpdate";
          type = (types.nullOr types.str);
        };
        "rollingUpdateStrategyBehavior" = mkOption {
          description = "RollingUpdateStrategyBehavior defines customized behavior for rolling updates.\nIt applies if the RollingUpdateStrategy is set to OnDelete, which is the default.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageRollingUpdateStrategyBehavior"
            )
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vlselect VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vlselect service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage configures persistent volume for VLStorage";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageStorage"));
        };
        "storageDataPath" = mkOption {
          description = "StorageDataPath - path to storage data";
          type = (types.nullOr types.str);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlstorageVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "futureRetention" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logIngestedRows" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "logNewStreams" = mkOverride 1002 null;
        "maintenanceInsertNodeIDs" = mkOverride 1002 null;
        "maintenanceSelectNodeIDs" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "retentionMaxDiskSpaceUsageBytes" = mkOverride 1002 null;
        "retentionPeriod" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdateStrategy" = mkOverride 1002 null;
        "rollingUpdateStrategyBehavior" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "storageDataPath" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlstorageDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstoragePersistentVolumeClaimRetentionPolicy" = {

      options = {
        "whenDeleted" = mkOption {
          description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
          type = (types.nullOr types.str);
        };
        "whenScaled" = mkOption {
          description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "whenDeleted" = mkOverride 1002 null;
        "whenScaled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstoragePodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstoragePodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VLClusterSpecVlstorageResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageRollingUpdateStrategyBehavior" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "MaxUnavailable defines the maximum number of pods that can be unavailable during the update.\nIt can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. \"50%\").\nFor example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageServiceSpecMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLClusterSpecVlstorageStorageEmptyDir")
          );
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterSpecVlstorageVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLClusterStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLClusterStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingle" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VLSingleSpec defines the desired state of VLSingle";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpec"));
        };
        "status" = mkOption {
          description = "VLSingleStatus defines the observed state of VLSingle";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpec" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvs" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvsFrom")
            )
          );
        };
        "futureRetention" = mkOption {
          description = "FutureRetention for the stored logs\nLog entries with timestamps bigger than now+futureRetention are rejected during data ingestion; see https://docs.victoriametrics.com/victorialogs/#retention";
          type = (types.nullOr types.str);
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecHostAliases"))
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecHost_aliases"))
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLSingleSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VLSingle to be configured with.";
          type = (types.nullOr types.str);
        };
        "logIngestedRows" = mkOption {
          description = "Whether to log all the ingested log entries; this can be useful for debugging of data ingestion; see https://docs.victoriametrics.com/victorialogs/data-ingestion/";
          type = (types.nullOr types.bool);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VictoriaLogs to be configured with.";
          type = (types.nullOr types.str);
        };
        "logNewStreams" = mkOption {
          description = "LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams; see https://docs.victoriametrics.com/victorialogs/keyconcepts/#stream-fields";
          type = (types.nullOr types.bool);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecManagedMetadata"));
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VLSingle pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecPodMetadata"));
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecResources"));
        };
        "retentionMaxDiskSpaceUsageBytes" = mkOption {
          description = "RetentionMaxDiskSpaceUsageBytes for the stored logs\nVictoriaLogs keeps at least two last days of data in order to guarantee that the logs for the last day can be returned in queries.\nThis means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,\nif the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.\nhttps://docs.victoriametrics.com/victorialogs/#retention-by-disk-space-usage";
          type = (types.nullOr types.str);
        };
        "retentionPeriod" = mkOption {
          description = "RetentionPeriod for the stored logs\nhttps://docs.victoriametrics.com/victorialogs/#retention";
          type = (types.nullOr types.str);
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vlsingle VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vlsingle service spec";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecServiceSpec"));
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage is the definition of how storage will be used by the VLSingle\nby default it`s empty dir";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecStorage"));
        };
        "storageDataPath" = mkOption {
          description = "StorageDataPath disables spec.storage option and overrides arg for victoria-logs binary --storageDataPath,\nits users responsibility to mount proper device into given path.";
          type = (types.nullOr types.str);
        };
        "storageMetadata" = mkOption {
          description = "StorageMeta defines annotations and labels attached to PVC for given vlsingle CR";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecStorageMetadata"));
        };
        "syslogSpec" = mkOption {
          description = "SyslogSpec defines syslog listener configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpec"));
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecTolerations"))
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLSingleSpecVolumeMounts" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "futureRetention" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logIngestedRows" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "logNewStreams" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "retentionMaxDiskSpaceUsageBytes" = mkOverride 1002 null;
        "retentionPeriod" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "storageDataPath" = mkOverride 1002 null;
        "storageMetadata" = mkOverride 1002 null;
        "syslogSpec" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLSingleSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvsFromConfigMapRef")
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VLSingleSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecStorage" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecStorageDataSource"));
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecStorageDataSourceRef")
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecStorageResources"));
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecStorageSelector"));
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecStorageDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecStorageDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecStorageMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecStorageResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecStorageSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecStorageSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecStorageSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpec" = {

      options = {
        "tcpListeners" = mkOption {
          description = "TCPListeners defines syslog server TCP listener configuration";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListeners")
            )
          );
        };
        "udpListeners" = mkOption {
          description = "UDPListeners defines syslog server UDP listener configuration";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecUdpListeners")
            )
          );
        };
      };

      config = {
        "tcpListeners" = mkOverride 1002 null;
        "udpListeners" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListeners" = {

      options = {
        "compressMethod" = mkOption {
          description = "CompressMethod for syslog messages\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression";
          type = (types.nullOr types.str);
        };
        "decolorizeFields" = mkOption {
          description = "DecolorizeFields to remove ANSI color codes across logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields";
          type = (types.nullOr types.str);
        };
        "ignoreFields" = mkOption {
          description = "IgnoreFields to ignore at logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields";
          type = (types.nullOr types.str);
        };
        "listenPort" = mkOption {
          description = "ListenPort defines listen port";
          type = types.int;
        };
        "streamFields" = mkOption {
          description = "StreamFields to use as log stream labels\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields";
          type = (types.nullOr types.str);
        };
        "tenantID" = mkOption {
          description = "TenantID for logs ingested in form of accountID:projectID\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs";
          type = (types.nullOr types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSServerConfig defines VictoriaMetrics TLS configuration for the application's server";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListenersTlsConfig"
            )
          );
        };
      };

      config = {
        "compressMethod" = mkOverride 1002 null;
        "decolorizeFields" = mkOverride 1002 null;
        "ignoreFields" = mkOverride 1002 null;
        "streamFields" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListenersTlsConfig" = {

      options = {
        "certFile" = mkOption {
          description = "CertFile defines path to the pre-mounted file with certificate\nmutually exclusive with CertSecret";
          type = (types.nullOr types.str);
        };
        "certSecret" = mkOption {
          description = "CertSecretRef defines reference for secret with certificate content under given key\nmutually exclusive with CertFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret"
            )
          );
        };
        "keyFile" = mkOption {
          description = "KeyFile defines path to the pre-mounted file with certificate key\nmutually exclusive with KeySecretRef";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Key defines reference for secret with certificate key content under given key\nmutually exclusive with KeyFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret"
            )
          );
        };
      };

      config = {
        "certFile" = mkOverride 1002 null;
        "certSecret" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListenersTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecTcpListenersTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecSyslogSpecUdpListeners" = {

      options = {
        "compressMethod" = mkOption {
          description = "CompressMethod for syslog messages\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#compression";
          type = (types.nullOr types.str);
        };
        "decolorizeFields" = mkOption {
          description = "DecolorizeFields to remove ANSI color codes across logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#decolorizing-fields";
          type = (types.nullOr types.str);
        };
        "ignoreFields" = mkOption {
          description = "IgnoreFields to ignore at logs\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#dropping-fields";
          type = (types.nullOr types.str);
        };
        "listenPort" = mkOption {
          description = "ListenPort defines listen port";
          type = types.int;
        };
        "streamFields" = mkOption {
          description = "StreamFields to use as log stream labels\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#stream-fields";
          type = (types.nullOr types.str);
        };
        "tenantID" = mkOption {
          description = "TenantID for logs ingested in form of accountID:projectID\nsee https://docs.victoriametrics.com/victorialogs/data-ingestion/syslog/#multiple-configs";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "compressMethod" = mkOverride 1002 null;
        "decolorizeFields" = mkOverride 1002 null;
        "ignoreFields" = mkOverride 1002 null;
        "streamFields" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VLSingleStatusConditions"))
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VLSingleStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomaly" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMAnomalySpec defines the desired state of VMAnomaly.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpec"));
        };
        "status" = mkOption {
          description = "VMAnomalyStatus defines the observed state of VMAnomaly.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalyStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpec" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for VMAnomaly";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplates")
            )
          );
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "configRawYaml" = mkOption {
          description = "ConfigRawYaml - raw configuration for anomaly,\nit helps it to start without secret.\npriority -> hardcoded ConfigRaw -> ConfigRaw, provided by user -> ConfigSecret.";
          type = (types.nullOr types.str);
        };
        "configSecret" = mkOption {
          description = "ConfigSecret is the name of a Kubernetes Secret in the same namespace as the\nVMAnomaly object, which contains configuration for this VMAnomaly,\nconfiguration must be inside secret key: anomaly.yaml.\nIt must be created by user.\ninstance. Defaults to 'vmanomaly-<anomaly-name>'\nThe secret is mounted into /etc/anomaly/config.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecConfigSecret"));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvs" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecHostAliases"))
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecHost_aliases")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VMAnomalySpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "license" = mkOption {
          description = "License allows to configure license key to be used for enterprise features.\nUsing license key is supported starting from VictoriaMetrics v1.94.0.\nSee [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecLicense"));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMAnomaly to be configured with.\nINFO, WARN, ERROR, FATAL, PANIC";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecManagedMetadata"));
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "monitoring" = mkOption {
          description = "Monitoring configures how expose anomaly metrics\nSee https://docs.victoriametrics.com/anomaly-detection/components/monitoring/";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoring"));
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecPersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecPodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the vmanomaly pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecPodMetadata"));
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "reader" = mkOption {
          description = "Metrics source for VMAnomaly\nSee https://docs.victoriametrics.com/anomaly-detection/components/reader/";
          type = (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReader");
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecResources"));
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdateStrategy" = mkOption {
          description = "RollingUpdateStrategy allows configuration for strategyType\nset it to RollingUpdate for disabling operator statefulSet rollingUpdate";
          type = (types.nullOr types.str);
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmanomaly VMPodScrape spec";
          type = (types.nullOr types.attrs);
        };
        "shardCount" = mkOption {
          description = "ShardCount - numbers of shards of VMAnomaly\nin this case operator will use 1 sts per shard with\nreplicas count according to spec.replicas.";
          type = (types.nullOr types.int);
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage configures storage for StatefulSet";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorage"));
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecTolerations"))
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VMAnomalySpecVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "writer" = mkOption {
          description = "Metrics destination for VMAnomaly\nSee https://docs.victoriametrics.com/anomaly-detection/components/writer/";
          type = (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriter");
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "configRawYaml" = mkOverride 1002 null;
        "configSecret" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "license" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "monitoring" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdateStrategy" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "shardCount" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplates" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr types.attrs);
        };
        "spec" = mkOption {
          description = "spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpec")
          );
        };
        "status" = mkOption {
          description = "status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesStatus")
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecSelector")
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesSpecSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesStatusConditions" = {

      options = {
        "lastProbeTime" = mkOption {
          description = "lastProbeTime is the time we probed the condition.";
          type = (types.nullOr types.str);
        };
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the time the condition transitioned from one status to another.";
          type = (types.nullOr types.str);
        };
        "message" = mkOption {
          description = "message is the human-readable message indicating details about last transition.";
          type = (types.nullOr types.str);
        };
        "reason" = mkOption {
          description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
          type = (types.nullOr types.str);
        };
        "status" = mkOption {
          description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
          type = types.str;
        };
      };

      config = {
        "lastProbeTime" = mkOverride 1002 null;
        "lastTransitionTime" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecClaimTemplatesStatusModifyVolumeStatus" = {

      options = {
        "status" = mkOption {
          description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
          type = types.str;
        };
        "targetVolumeAttributesClassName" = mkOption {
          description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "targetVolumeAttributesClassName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecConfigSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VMAnomalySpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvsFromConfigMapRef")
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecLicense" = {

      options = {
        "forceOffline" = mkOption {
          description = "Enforce offline verification of the license key.";
          type = (types.nullOr types.bool);
        };
        "key" = mkOption {
          description = "Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).\nTo request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)";
          type = (types.nullOr types.str);
        };
        "keyRef" = mkOption {
          description = "KeyRef is reference to secret with license key for enterprise features.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecLicenseKeyRef"));
        };
        "reloadInterval" = mkOption {
          description = "Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "forceOffline" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "keyRef" = mkOverride 1002 null;
        "reloadInterval" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecLicenseKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoring" = {

      options = {
        "pull" = mkOption {
          description = "VMAnomalyMonitoringPullSpec defines pull monitoring configuration\nwhich is enabled by default and served at POD_IP:8490/metrics";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPull"));
        };
        "push" = mkOption {
          description = "VMAnomalyMonitoringPushSpec defines metrics push configuration\n\nVMAnomaly uses prometheus text exposition format";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPush"));
        };
      };

      config = {
        "pull" = mkOverride 1002 null;
        "push" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPull" = {

      options = {
        "port" = mkOption {
          description = "Port defines a port for metrics scrape";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPush" = {

      options = {
        "basicAuth" = mkOption {
          description = "Basic auth defines basic authorization configuration";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBasicAuth")
          );
        };
        "bearer" = mkOption {
          description = "BearerAuth defines authorization with Authorization: Bearer header";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBearer")
          );
        };
        "extraLabels" = mkOption {
          description = "ExtraLabels defines a set of labels to attach to the pushed metrics";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "healthPath" = mkOption {
          description = "HealthPath defines absolute or relative URL address where to check availability of the remote webserver";
          type = (types.nullOr types.str);
        };
        "pushFrequency" = mkOption {
          description = "PushFrequency defines push interval";
          type = (types.nullOr types.str);
        };
        "tenantID" = mkOption {
          description = "TenantID defines for VictoriaMetrics Cluster version only, tenants are identified by accountID, accountID:projectID or multitenant.";
          type = (types.nullOr types.str);
        };
        "timeout" = mkOption {
          description = "Timeout for the requests, passed as a string";
          type = (types.nullOr types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig defines tls connection configuration";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfig")
          );
        };
        "url" = mkOption {
          description = "defines target url for push requests";
          type = types.str;
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearer" = mkOverride 1002 null;
        "extraLabels" = mkOverride 1002 null;
        "healthPath" = mkOverride 1002 null;
        "pushFrequency" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBearer" = {

      options = {
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBearerBearerTokenSecret"
            )
          );
        };
      };

      config = {
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushBearerBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCa")
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecMonitoringPushTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecPersistentVolumeClaimRetentionPolicy" = {

      options = {
        "whenDeleted" = mkOption {
          description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
          type = (types.nullOr types.str);
        };
        "whenScaled" = mkOption {
          description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "whenDeleted" = mkOverride 1002 null;
        "whenScaled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReader" = {

      options = {
        "basicAuth" = mkOption {
          description = "Basic auth defines basic authorization configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderBasicAuth"));
        };
        "bearer" = mkOption {
          description = "BearerAuth defines authorization with Authorization: Bearer header";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderBearer"));
        };
        "dataRange" = mkOption {
          description = "Optional argumentallows defining valid data ranges for input of all the queries in queries";
          type = (types.nullOr (types.listOf types.str));
        };
        "datasourceURL" = mkOption {
          description = "DatasourceURL address\ndatasource must serve /api/v1/query and /api/v1/query_range APIs";
          type = types.str;
        };
        "extraFilters" = mkOption {
          description = "List of strings with series selector.";
          type = (types.nullOr (types.listOf types.str));
        };
        "healthPath" = mkOption {
          description = "HealthPath defines absolute or relative URL address where to check availability of the remote webserver";
          type = (types.nullOr types.str);
        };
        "latencyOffset" = mkOption {
          description = "It allows overriding the default -search.latencyOffsetflag of VictoriaMetrics";
          type = (types.nullOr types.str);
        };
        "maxPointsPerQuery" = mkOption {
          description = "Optional argoverrides how search.maxPointsPerTimeseries flagimpacts vmanomaly on splitting long fitWindow queries into smaller sub-intervals";
          type = (types.nullOr types.int);
        };
        "queryFromLastSeenTimestamp" = mkOption {
          description = "If True, then query will be performed from the last seen timestamp for a given series.";
          type = (types.nullOr types.bool);
        };
        "queryRangePath" = mkOption {
          description = "Performs PromQL/MetricsQL range query";
          type = (types.nullOr types.str);
        };
        "samplingPeriod" = mkOption {
          description = "Frequency of the points returned";
          type = types.str;
        };
        "tenantID" = mkOption {
          description = "TenantID defines for VictoriaMetrics Cluster version only, tenants are identified by accountID, accountID:projectID or multitenant.";
          type = (types.nullOr types.str);
        };
        "timeout" = mkOption {
          description = "Timeout for the requests, passed as a string";
          type = (types.nullOr types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig defines tls connection configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfig"));
        };
        "tz" = mkOption {
          description = "Optional argumentspecifies the IANA timezone to account for local shifts, like DST, in models sensitive to seasonal patterns";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearer" = mkOverride 1002 null;
        "dataRange" = mkOverride 1002 null;
        "extraFilters" = mkOverride 1002 null;
        "healthPath" = mkOverride 1002 null;
        "latencyOffset" = mkOverride 1002 null;
        "maxPointsPerQuery" = mkOverride 1002 null;
        "queryFromLastSeenTimestamp" = mkOverride 1002 null;
        "queryRangePath" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "tz" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderBasicAuthPassword")
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderBasicAuthUsername")
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderBearer" = {

      options = {
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderBearerBearerTokenSecret"
            )
          );
        };
      };

      config = {
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderBearerBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCa")
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCert")
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigKeySecret")
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCaConfigMap")
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCaSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCertSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReaderTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VMAnomalySpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageEmptyDir"));
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplate")
          );
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplate" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "EmbeddedMetadata contains metadata relevant to an EmbeddedResource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "Spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpec"
            )
          );
        };
        "status" = mkOption {
          description = "Status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateStatus"
            )
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecSelector"
            )
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateStatusConditions" = {

      options = {
        "lastProbeTime" = mkOption {
          description = "lastProbeTime is the time we probed the condition.";
          type = (types.nullOr types.str);
        };
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the time the condition transitioned from one status to another.";
          type = (types.nullOr types.str);
        };
        "message" = mkOption {
          description = "message is the human-readable message indicating details about last transition.";
          type = (types.nullOr types.str);
        };
        "reason" = mkOption {
          description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
          type = (types.nullOr types.str);
        };
        "status" = mkOption {
          description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
          type = types.str;
        };
      };

      config = {
        "lastProbeTime" = mkOverride 1002 null;
        "lastTransitionTime" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecStorageVolumeClaimTemplateStatusModifyVolumeStatus" =
      {

        options = {
          "status" = mkOption {
            description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
            type = types.str;
          };
          "targetVolumeAttributesClassName" = mkOption {
            description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "targetVolumeAttributesClassName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1.VMAnomalySpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriter" = {

      options = {
        "basicAuth" = mkOption {
          description = "Basic auth defines basic authorization configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterBasicAuth"));
        };
        "bearer" = mkOption {
          description = "BearerAuth defines authorization with Authorization: Bearer header";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterBearer"));
        };
        "datasourceURL" = mkOption {
          description = "DatasourceURL defines remote write url for write requests\nprovided endpoint must serve /api/v1/import path\nvmanomaly joins datasourceURL + \"/api/v1/import\"";
          type = types.str;
        };
        "healthPath" = mkOption {
          description = "HealthPath defines absolute or relative URL address where to check availability of the remote webserver";
          type = (types.nullOr types.str);
        };
        "metricFormat" = mkOption {
          description = "Metrics to save the output (in metric names or labels)";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterMetricFormat")
          );
        };
        "tenantID" = mkOption {
          description = "TenantID defines for VictoriaMetrics Cluster version only, tenants are identified by accountID, accountID:projectID or multitenant.";
          type = (types.nullOr types.str);
        };
        "timeout" = mkOption {
          description = "Timeout for the requests, passed as a string";
          type = (types.nullOr types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig defines tls connection configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfig"));
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearer" = mkOverride 1002 null;
        "healthPath" = mkOverride 1002 null;
        "metricFormat" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterBasicAuthPassword")
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterBasicAuthUsername")
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterBearer" = {

      options = {
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterBearerBearerTokenSecret"
            )
          );
        };
      };

      config = {
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterBearerBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterMetricFormat" = {

      options = {
        "__name__" = mkOption {
          description = "Name of result metric\nMust have a value with $VAR placeholder in it to distinguish between resulting metrics";
          type = types.str;
        };
        "extraLabels" = mkOption {
          description = "ExtraLabels defines additional labels to be added to the resulting metrics";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "for" = mkOption {
          description = "For is a special label with $QUERY_KEY placeholder";
          type = types.str;
        };
      };

      config = {
        "extraLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCa")
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCert")
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigKeySecret")
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCaConfigMap")
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCaSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCertSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalySpecWriterTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalyStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VMAnomalyStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "shards" = mkOption {
          description = "Shards represents total number of vmanomaly statefulsets with uniq scrape targets";
          type = (types.nullOr types.int);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "shards" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VMAnomalyStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTCluster" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VTClusterSpec defines the desired state of VTCluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpec"));
        };
        "status" = mkOption {
          description = "VTClusterStatus defines the observed state of VTCluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpec" = {

      options = {
        "clusterDomainName" = mkOption {
          description = "ClusterDomainName defines domain name suffix for in-cluster dns addresses\naka .cluster.local\nused by vtinsert and vtselect to build vtstorage address";
          type = (types.nullOr types.str);
        };
        "clusterVersion" = mkOption {
          description = "ClusterVersion defines default images tag for all components.\nit can be overwritten with component specific image.tag value.";
          type = (types.nullOr types.str);
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTClusterSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "insert" = mkOption {
          description = "VTInsert defines vtinsert component configuration at victoria-traces cluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsert"));
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecManagedMetadata"));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "requestsLoadBalancer" = mkOption {
          description = "RequestsLoadBalancer configures load-balancing for vtinsert and vtselect requests.\nIt helps to evenly spread load across pods.\nUsually it's not possible with Kubernetes TCP-based services.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecRequestsLoadBalancer")
          );
        };
        "select" = mkOption {
          description = "VTSelect defines vtselect component configuration at victoria-traces cluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelect"));
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the\nVTSelect, VTInsert and VTStorage Pods.";
          type = (types.nullOr types.str);
        };
        "storage" = mkOption {
          description = "VTStorage defines vtstorage component configuration at victoria-traces cluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorage"));
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "clusterDomainName" = mkOverride 1002 null;
        "clusterVersion" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "insert" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "requestsLoadBalancer" = mkOverride 1002 null;
        "select" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsert" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertHost_aliases")
            )
          );
        };
        "hpa" = mkOption {
          description = "Configures horizontal pod autoscaling.";
          type = (types.nullOr types.attrs);
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecInsertImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VTInsert to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VTInsert to be configured with.";
          type = (types.nullOr types.str);
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertPodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VTInsert pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertPodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertResources"));
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertRollingUpdate")
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vtinsert VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vtinsert service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTClusterSpecInsertVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "hpa" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecInsertDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecInsertResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecInsertServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecInsertVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecRequestsLoadBalancer" = {

      options = {
        "disableInsertBalancing" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "disableSelectBalancing" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "enabled" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "spec" = mkOption {
          description = "VMAuthLoadBalancerSpec defines configuration spec for VMAuth used as load-balancer\nfor VMCluster component";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "disableInsertBalancing" = mkOverride 1002 null;
        "disableSelectBalancing" = mkOverride 1002 null;
        "enabled" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelect" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvsFrom")
            )
          );
        };
        "extraStorageNodes" = mkOption {
          description = "ExtraStorageNodes - defines additional storage nodes to VTSelect";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraStorageNodes")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectHost_aliases")
            )
          );
        };
        "hpa" = mkOption {
          description = "Configures horizontal pod autoscaling.";
          type = (types.nullOr types.attrs);
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecSelectImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VTSelect to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VTSelect to be configured with.";
          type = (types.nullOr types.str);
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectPodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VTSelect pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectPodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectResources"));
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectRollingUpdate")
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vtselect VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vtselect service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTClusterSpecSelectVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "extraStorageNodes" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "hpa" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecSelectDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectExtraStorageNodes" = {

      options = {
        "addr" = mkOption {
          description = "Addr defines storage node address";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecSelectResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecSelectServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecSelectVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorage" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvsFrom")
            )
          );
        };
        "futureRetention" = mkOption {
          description = "FutureRetention for the stored traces\nLog entries with timestamps bigger than now+futureRetention are rejected during data ingestion\nsee https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.str);
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageHost_aliases")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecStorageImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VTStorage to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logIngestedRows" = mkOption {
          description = "Whether to log all the ingested log entries; this can be useful for debugging of data ingestion\nsee https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.bool);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VTStorage to be configured with.";
          type = (types.nullOr types.str);
        };
        "logNewStreams" = mkOption {
          description = "LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams\nsee https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.bool);
        };
        "maintenanceInsertNodeIDs" = mkOption {
          description = "MaintenanceInsertNodeIDs - excludes given node ids from insert requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.\nlets say, you have pod-0, pod-1, pod-2, pod-3. to exclude pod-0 and pod-3 from insert routing, define nodeIDs: [0,3].\nUseful at storage expanding, when you want to rebalance some data at cluster.";
          type = (types.nullOr (types.listOf types.int));
        };
        "maintenanceSelectNodeIDs" = mkOption {
          description = "MaintenanceInsertNodeIDs - excludes given node ids from select requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.";
          type = (types.nullOr (types.listOf types.int));
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStoragePersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStoragePodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VTStorage pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStoragePodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageResources"));
        };
        "retentionMaxDiskSpaceUsageBytes" = mkOption {
          description = "RetentionMaxDiskSpaceUsageBytes for the stored traces\nVictoriaTraces keeps at least two last days of data in order to guarantee that the traces for the last day can be returned in queries.\nThis means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,\nif the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.\nhttps://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.str);
        };
        "retentionPeriod" = mkOption {
          description = "RetentionPeriod for the stored traces\nhttps://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.str);
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdateStrategy" = mkOption {
          description = "RollingUpdateStrategy defines strategy for application updates\nDefault is OnDelete, in this case operator handles update process\nCan be changed for RollingUpdate";
          type = (types.nullOr types.str);
        };
        "rollingUpdateStrategyBehavior" = mkOption {
          description = "RollingUpdateStrategyBehavior defines customized behavior for rolling updates.\nIt applies if the RollingUpdateStrategy is set to OnDelete, which is the default.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageRollingUpdateStrategyBehavior"
            )
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vtstorage VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vtstorage service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage configures persistent volume for VTStorage";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageStorage"));
        };
        "storageDataPath" = mkOption {
          description = "StorageDataPath - path to storage data";
          type = (types.nullOr types.str);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecStorageVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "futureRetention" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logIngestedRows" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "logNewStreams" = mkOverride 1002 null;
        "maintenanceInsertNodeIDs" = mkOverride 1002 null;
        "maintenanceSelectNodeIDs" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "retentionMaxDiskSpaceUsageBytes" = mkOverride 1002 null;
        "retentionPeriod" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdateStrategy" = mkOverride 1002 null;
        "rollingUpdateStrategyBehavior" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "storageDataPath" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecStorageDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStoragePersistentVolumeClaimRetentionPolicy" = {

      options = {
        "whenDeleted" = mkOption {
          description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
          type = (types.nullOr types.str);
        };
        "whenScaled" = mkOption {
          description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "whenDeleted" = mkOverride 1002 null;
        "whenScaled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStoragePodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStoragePodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1.VTClusterSpecStorageResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageRollingUpdateStrategyBehavior" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "MaxUnavailable defines the maximum number of pods that can be unavailable during the update.\nIt can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. \"50%\").\nFor example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTClusterSpecStorageStorageEmptyDir")
          );
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterSpecStorageVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTClusterStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTClusterStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingle" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VTSingleSpec defines the desired state of VTSingle";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpec"));
        };
        "status" = mkOption {
          description = "VTSingleStatus defines the observed state of VTSingle";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpec" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvs" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvsFrom")
            )
          );
        };
        "futureRetention" = mkOption {
          description = "FutureRetention for the stored traces\nLog entries with timestamps bigger than now+futureRetention are rejected during data ingestion;\nsee https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.str);
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecHostAliases"))
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecHost_aliases"))
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTSingleSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VTSingle to be configured with.";
          type = (types.nullOr types.str);
        };
        "logIngestedRows" = mkOption {
          description = "Whether to log all the ingested log entries; this can be useful for debugging of data ingestion;\nsee https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.bool);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VictoriaTraces to be configured with.";
          type = (types.nullOr types.str);
        };
        "logNewStreams" = mkOption {
          description = "LogNewStreams Whether to log creation of new streams; this can be useful for debugging of high cardinality issues with log streams;\nsee https://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.bool);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecManagedMetadata"));
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VTSingle pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecPodMetadata"));
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecResources"));
        };
        "retentionMaxDiskSpaceUsageBytes" = mkOption {
          description = "RetentionMaxDiskSpaceUsageBytes for the stored traces\nVictoriaTraces keeps at least two last days of data in order to guarantee that the traces for the last day can be returned in queries.\nThis means that the total disk space usage may exceed the -retention.maxDiskSpaceUsageBytes,\nif the size of the last two days of data exceeds the -retention.maxDiskSpaceUsageBytes.\nhttps://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.str);
        };
        "retentionPeriod" = mkOption {
          description = "RetentionPeriod for the stored traces\nhttps://docs.victoriametrics.com/victoriatraces/#configure-and-run-victoriatraces";
          type = (types.nullOr types.str);
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vtsingle VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vtsingle service spec";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecServiceSpec"));
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage is the definition of how storage will be used by the VTSingle\nby default it`s empty dir";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecStorage"));
        };
        "storageDataPath" = mkOption {
          description = "StorageDataPath disables spec.storage option and overrides arg for victoria-traces binary --storageDataPath,\nits users responsibility to mount proper device into given path.";
          type = (types.nullOr types.str);
        };
        "storageMetadata" = mkOption {
          description = "StorageMeta defines annotations and labels attached to PVC for given vtsingle CR";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecStorageMetadata"));
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecTolerations"))
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTSingleSpecVolumeMounts" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "futureRetention" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logIngestedRows" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "logNewStreams" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "retentionMaxDiskSpaceUsageBytes" = mkOverride 1002 null;
        "retentionPeriod" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "storageDataPath" = mkOverride 1002 null;
        "storageMetadata" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTSingleSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvsFromConfigMapRef")
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1.VTSingleSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecStorage" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecStorageDataSource"));
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecStorageDataSourceRef")
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecStorageResources"));
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecStorageSelector"));
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecStorageDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecStorageDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecStorageMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecStorageResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecStorageSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1.VTSingleSpecStorageSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecStorageSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (types.listOf (submoduleOf "operator.victoriametrics.com.v1.VTSingleStatusConditions"))
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1.VTSingleStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VLogs" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VLogsSpec defines the desired state of VLogs\nVLogs is deprecated, migrate to the VLSingle";
          type = (types.nullOr types.attrs);
        };
        "status" = mkOption {
          description = "VLogsStatus defines the observed state of VLogs";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VLogsStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VLogsStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VLogsStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VLogsStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgent" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMAgentSpec defines the desired state of VMAgent";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpec"));
        };
        "status" = mkOption {
          description = "VMAgentStatus defines the observed state of VMAgent";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpec" = {

      options = {
        "aPIServerConfig" = mkOption {
          description = "APIServerConfig allows specifying a host and auth methods to access apiserver.\nIf left empty, VMAgent is assumed to run inside of the cluster\nand will discover API servers automatically and use the pod's CA certificate\nand bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.\naPIServerConfig is deprecated use apiServerConfig instead";
          type = (types.nullOr types.attrs);
        };
        "additionalScrapeConfigs" = mkOption {
          description = "AdditionalScrapeConfigs As scrape configs are appended, the user is responsible to make sure it\nis valid. Note that using this feature may expose the possibility to\nbreak upgrades of VMAgent. It is advised to review VMAgent release\nnotes to ensure that no incompatible scrape configs are going to break\nVMAgent after the upgrade.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecAdditionalScrapeConfigs")
          );
        };
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "apiServerConfig" = mkOption {
          description = "APIServerConfig allows specifying a host and auth methods to access apiserver.\nIf left empty, VMAgent is assumed to run inside of the cluster\nand will discover API servers automatically and use the pod's CA certificate\nand bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfig")
          );
        };
        "arbitraryFSAccessThroughSMs" = mkOption {
          description = "ArbitraryFSAccessThroughSMs configures whether configuration\nbased on EndpointAuth can access arbitrary files on the file system\nof the VMAgent container e.g. bearer token files, basic auth, tls certs";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecArbitraryFSAccessThroughSMs"
            )
          );
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for VMAgent in StatefulMode";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplates")
            )
          );
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "configReloadAuthKeySecret" = mkOption {
          description = "ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.\nGiven secret reference will be added to the application and vm-config-reloader as volume\navailable since v0.57.0 version";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecConfigReloadAuthKeySecret"
            )
          );
        };
        "configReloaderExtraArgs" = mkOption {
          description = "ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container\nfor example resyncInterval: \"30s\"";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "configReloaderImageTag" = mkOption {
          description = "ConfigReloaderImageTag defines image:tag for config-reloader container";
          type = (types.nullOr types.str);
        };
        "configReloaderResources" = mkOption {
          description = "ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecConfigReloaderResources")
          );
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "daemonSetMode" = mkOption {
          description = "DaemonSetMode enables DaemonSet deployment mode instead of Deployment.\nSupports only VMPodScrape\n(available from v0.55.0).\nCannot be used with statefulMode";
          type = (types.nullOr types.bool);
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "enableKubernetesAPISelectors" = mkOption {
          description = "EnableKubernetesAPISelectors instructs vmagent to use CRD scrape objects spec.selectors for\nKubernetes API list and watch requests.\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#list-and-watch-filtering\nIt could be useful to reduce Kubernetes API server resource usage for serving less than 100 CRD scrape objects in total.";
          type = (types.nullOr types.bool);
        };
        "enforcedNamespaceLabel" = mkOption {
          description = "EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert\nand metric that is user created. The label value will always be the namespace of the object that is\nbeing created.";
          type = (types.nullOr types.str);
        };
        "externalLabels" = mkOption {
          description = "ExternalLabels The labels to add to any time series scraped by vmagent.\nit doesn't affect metrics ingested directly by push API's";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvsFrom")
            )
          );
        };
        "globalScrapeMetricRelabelConfigs" = mkOption {
          description = "GlobalScrapeMetricRelabelConfigs is a global metric relabel configuration, which is applied to each scrape job.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecGlobalScrapeMetricRelabelConfigs"
              )
            )
          );
        };
        "globalScrapeRelabelConfigs" = mkOption {
          description = "GlobalScrapeRelabelConfigs is a global relabel configuration, which is applied to each samples of each scrape job during service discovery.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecGlobalScrapeRelabelConfigs"
              )
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecHost_aliases")
            )
          );
        };
        "ignoreNamespaceSelectors" = mkOption {
          description = "IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from\nscrape objects, and they will only discover endpoints\nwithin their current namespace.  Defaults to false.";
          type = (types.nullOr types.bool);
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAgentSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "ingestOnlyMode" = mkOption {
          description = "IngestOnlyMode switches vmagent into unmanaged mode\nit disables any config generation for scraping\nCurrently it prevents vmagent from managing tls and auth options for remote write";
          type = (types.nullOr types.bool);
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "inlineRelabelConfig" = mkOption {
          description = "InlineRelabelConfig - defines GlobalRelabelConfig for vmagent, can be defined directly at CRD.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecInlineRelabelConfig")
            )
          );
        };
        "inlineScrapeConfig" = mkOption {
          description = "InlineScrapeConfig As scrape configs are appended, the user is responsible to make sure it\nis valid. Note that using this feature may expose the possibility to\nbreak upgrades of VMAgent. It is advised to review VMAgent release\nnotes to ensure that no incompatible scrape configs are going to break\nVMAgent after the upgrade.\nit should be defined as single yaml file.\ninlineScrapeConfig: |\n    - job_name: \"prometheus\"\n      static_configs:\n      - targets: [\"localhost:9090\"]";
          type = (types.nullOr types.str);
        };
        "insertPorts" = mkOption {
          description = "InsertPorts - additional listen ports for data ingestion.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecInsertPorts"));
        };
        "license" = mkOption {
          description = "License allows to configure license key to be used for enterprise features.\nUsing license key is supported starting from VictoriaMetrics v1.94.0.\nSee [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecLicense"));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMAgent to be configured with.";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMAgent to be configured with.\nINFO, WARN, ERROR, FATAL, PANIC";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecManagedMetadata")
          );
        };
        "maxScrapeInterval" = mkOption {
          description = "MaxScrapeInterval allows limiting maximum scrape interval for VMServiceScrape, VMPodScrape and other scrapes\nIf interval is higher than defined limit, `maxScrapeInterval` will be used.";
          type = (types.nullOr types.str);
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "minScrapeInterval" = mkOption {
          description = "MinScrapeInterval allows limiting minimal scrape interval for VMServiceScrape, VMPodScrape and other scrapes\nIf interval is lower than defined limit, `minScrapeInterval` will be used.";
          type = (types.nullOr types.str);
        };
        "nodeScrapeNamespaceSelector" = mkOption {
          description = "NodeScrapeNamespaceSelector defines Namespaces to be selected for VMNodeScrape discovery.\nWorks in combination with Selector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeNamespaceSelector"
            )
          );
        };
        "nodeScrapeRelabelTemplate" = mkOption {
          description = "NodeScrapeRelabelTemplate defines relabel config, that will be added to each VMNodeScrape.\nit's useful for adding specific labels to all targets";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeRelabelTemplate"
              )
            )
          );
        };
        "nodeScrapeSelector" = mkOption {
          description = "NodeScrapeSelector defines VMNodeScrape to be selected for scraping.\nWorks in combination with NamespaceSelector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeSelector")
          );
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "overrideHonorLabels" = mkOption {
          description = "OverrideHonorLabels if set to true overrides all user configured honor_labels.\nIf HonorLabels is set in scrape objects  to true, this overrides honor_labels to false.";
          type = (types.nullOr types.bool);
        };
        "overrideHonorTimestamps" = mkOption {
          description = "OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.";
          type = (types.nullOr types.bool);
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the vmagent pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPodMetadata"));
        };
        "podScrapeNamespaceSelector" = mkOption {
          description = "PodScrapeNamespaceSelector defines Namespaces to be selected for VMPodScrape discovery.\nWorks in combination with Selector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeNamespaceSelector"
            )
          );
        };
        "podScrapeRelabelTemplate" = mkOption {
          description = "PodScrapeRelabelTemplate defines relabel config, that will be added to each VMPodScrape.\nit's useful for adding specific labels to all targets";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeRelabelTemplate"
              )
            )
          );
        };
        "podScrapeSelector" = mkOption {
          description = "PodScrapeSelector defines PodScrapes to be selected for target discovery.\nWorks in combination with NamespaceSelector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeSelector")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "probeNamespaceSelector" = mkOption {
          description = "ProbeNamespaceSelector defines Namespaces to be selected for VMProbe discovery.\nWorks in combination with Selector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeNamespaceSelector")
          );
        };
        "probeScrapeRelabelTemplate" = mkOption {
          description = "ProbeScrapeRelabelTemplate defines relabel config, that will be added to each VMProbeScrape.\nit's useful for adding specific labels to all targets";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeScrapeRelabelTemplate"
              )
            )
          );
        };
        "probeSelector" = mkOption {
          description = "ProbeSelector defines VMProbe to be selected for target probing.\nWorks in combination with NamespaceSelector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeSelector"));
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "relabelConfig" = mkOption {
          description = "RelabelConfig ConfigMap with global relabel config -remoteWrite.relabelConfig\nThis relabeling is applied to all the collected metrics before sending them to remote storage.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRelabelConfig"));
        };
        "remoteWrite" = mkOption {
          description = "RemoteWrite list of victoria metrics /some other remote write system\nfor vm it must looks like: http://victoria-metrics-single:8428/api/v1/write\nor for cluster different url\nhttps://docs.victoriametrics.com/victoriametrics/vmagent/#splitting-data-streams-among-multiple-systems";
          type = (types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWrite"));
        };
        "remoteWriteSettings" = mkOption {
          description = "RemoteWriteSettings defines global settings for all remoteWrite urls.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteSettings")
          );
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecResources"));
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRollingUpdate"));
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "scrapeClasses" = mkOption {
          description = "ScrapeClasses defines the list of scrape classes to expose to scraping objects such as\nPodScrapes, ServiceScrapes, Probes and ScrapeConfigs.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClasses"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "scrapeConfigNamespaceSelector" = mkOption {
          description = "ScrapeConfigNamespaceSelector defines Namespaces to be selected for VMScrapeConfig discovery.\nWorks in combination with Selector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigNamespaceSelector"
            )
          );
        };
        "scrapeConfigRelabelTemplate" = mkOption {
          description = "ScrapeConfigRelabelTemplate defines relabel config, that will be added to each VMScrapeConfig.\nit's useful for adding specific labels to all targets";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigRelabelTemplate"
              )
            )
          );
        };
        "scrapeConfigSelector" = mkOption {
          description = "ScrapeConfigSelector defines VMScrapeConfig to be selected for target discovery.\nWorks in combination with NamespaceSelector.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigSelector")
          );
        };
        "scrapeInterval" = mkOption {
          description = "ScrapeInterval defines how often scrape targets by default";
          type = (types.nullOr types.str);
        };
        "scrapeTimeout" = mkOption {
          description = "ScrapeTimeout defines global timeout for targets scrape";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "selectAllByDefault" = mkOption {
          description = "SelectAllByDefault changes default behavior for empty CRD selectors, such ServiceScrapeSelector.\nwith selectAllByDefault: true and empty serviceScrapeSelector and ServiceScrapeNamespaceSelector\nOperator selects all exist serviceScrapes\nwith selectAllByDefault: false - selects nothing";
          type = (types.nullOr types.bool);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeNamespaceSelector" = mkOption {
          description = "ServiceScrapeNamespaceSelector Namespaces to be selected for VMServiceScrape discovery.\nWorks in combination with Selector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeNamespaceSelector"
            )
          );
        };
        "serviceScrapeRelabelTemplate" = mkOption {
          description = "ServiceScrapeRelabelTemplate defines relabel config, that will be added to each VMServiceScrape.\nit's useful for adding specific labels to all targets";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeRelabelTemplate"
              )
            )
          );
        };
        "serviceScrapeSelector" = mkOption {
          description = "ServiceScrapeSelector defines ServiceScrapes to be selected for target discovery.\nWorks in combination with NamespaceSelector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeSelector")
          );
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmagent VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vmagent service spec";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceSpec"));
        };
        "shardCount" = mkOption {
          description = "ShardCount - numbers of shards of VMAgent\nin this case operator will use 1 deployment/sts per shard with\nreplicas count according to spec.replicas,\nsee [here](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-big-number-of-targets)";
          type = (types.nullOr types.int);
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "statefulMode" = mkOption {
          description = "StatefulMode enables StatefulSet for `VMAgent` instead of Deployment\nit allows using persistent storage for vmagent's persistentQueue";
          type = (types.nullOr types.bool);
        };
        "statefulRollingUpdateStrategy" = mkOption {
          description = "StatefulRollingUpdateStrategy allows configuration for strategyType\nset it to RollingUpdate for disabling operator statefulSet rollingUpdate";
          type = (types.nullOr types.str);
        };
        "statefulStorage" = mkOption {
          description = "StatefulStorage configures storage for StatefulSet";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorage")
          );
        };
        "staticScrapeNamespaceSelector" = mkOption {
          description = "StaticScrapeNamespaceSelector defines Namespaces to be selected for VMStaticScrape discovery.\nWorks in combination with NamespaceSelector.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeNamespaceSelector"
            )
          );
        };
        "staticScrapeRelabelTemplate" = mkOption {
          description = "StaticScrapeRelabelTemplate defines relabel config, that will be added to each VMStaticScrape.\nit's useful for adding specific labels to all targets";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeRelabelTemplate"
              )
            )
          );
        };
        "staticScrapeSelector" = mkOption {
          description = "StaticScrapeSelector defines VMStaticScrape to be selected for target discovery.\nWorks in combination with NamespaceSelector.\nIf both nil - match everything.\nNamespaceSelector nil - only objects at VMAgent namespace.\nSelector nil - only objects at NamespaceSelector namespaces.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeSelector")
          );
        };
        "streamAggrConfig" = mkOption {
          description = "StreamAggrConfig defines global stream aggregation configuration for VMAgent";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfig")
          );
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.\nworks only for deployments, statefulset always use OnDelete.";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "useVMConfigReloader" = mkOption {
          description = "UseVMConfigReloader replaces prometheus-like config-reloader\nwith vm one. It uses secrets watch instead of file watch\nwhich greatly increases speed of config updates";
          type = (types.nullOr types.bool);
        };
        "vmAgentExternalLabelName" = mkOption {
          description = "VMAgentExternalLabelName Name of vmAgent external label used to denote vmAgent instance\nname. Defaults to the value of `prometheus`. External label will\n_not_ be added when value is set to empty string (`\"\"`).";
          type = (types.nullOr types.str);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAgentSpecVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "aPIServerConfig" = mkOverride 1002 null;
        "additionalScrapeConfigs" = mkOverride 1002 null;
        "affinity" = mkOverride 1002 null;
        "apiServerConfig" = mkOverride 1002 null;
        "arbitraryFSAccessThroughSMs" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "configReloadAuthKeySecret" = mkOverride 1002 null;
        "configReloaderExtraArgs" = mkOverride 1002 null;
        "configReloaderImageTag" = mkOverride 1002 null;
        "configReloaderResources" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "daemonSetMode" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "enableKubernetesAPISelectors" = mkOverride 1002 null;
        "enforcedNamespaceLabel" = mkOverride 1002 null;
        "externalLabels" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "globalScrapeMetricRelabelConfigs" = mkOverride 1002 null;
        "globalScrapeRelabelConfigs" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "ignoreNamespaceSelectors" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "ingestOnlyMode" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "inlineRelabelConfig" = mkOverride 1002 null;
        "inlineScrapeConfig" = mkOverride 1002 null;
        "insertPorts" = mkOverride 1002 null;
        "license" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "maxScrapeInterval" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "minScrapeInterval" = mkOverride 1002 null;
        "nodeScrapeNamespaceSelector" = mkOverride 1002 null;
        "nodeScrapeRelabelTemplate" = mkOverride 1002 null;
        "nodeScrapeSelector" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "overrideHonorLabels" = mkOverride 1002 null;
        "overrideHonorTimestamps" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "podScrapeNamespaceSelector" = mkOverride 1002 null;
        "podScrapeRelabelTemplate" = mkOverride 1002 null;
        "podScrapeSelector" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "probeNamespaceSelector" = mkOverride 1002 null;
        "probeScrapeRelabelTemplate" = mkOverride 1002 null;
        "probeSelector" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "relabelConfig" = mkOverride 1002 null;
        "remoteWriteSettings" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "scrapeClasses" = mkOverride 1002 null;
        "scrapeConfigNamespaceSelector" = mkOverride 1002 null;
        "scrapeConfigRelabelTemplate" = mkOverride 1002 null;
        "scrapeConfigSelector" = mkOverride 1002 null;
        "scrapeInterval" = mkOverride 1002 null;
        "scrapeTimeout" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "selectAllByDefault" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeNamespaceSelector" = mkOverride 1002 null;
        "serviceScrapeRelabelTemplate" = mkOverride 1002 null;
        "serviceScrapeSelector" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "shardCount" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "statefulMode" = mkOverride 1002 null;
        "statefulRollingUpdateStrategy" = mkOverride 1002 null;
        "statefulStorage" = mkOverride 1002 null;
        "staticScrapeNamespaceSelector" = mkOverride 1002 null;
        "staticScrapeRelabelTemplate" = mkOverride 1002 null;
        "staticScrapeSelector" = mkOverride 1002 null;
        "streamAggrConfig" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "useVMConfigReloader" = mkOverride 1002 null;
        "vmAgentExternalLabelName" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecAdditionalScrapeConfigs" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfig" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization configures generic authorization params";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigBasicAuth"
            )
          );
        };
        "bearerToken" = mkOption {
          description = "Bearer token for accessing apiserver.";
          type = (types.nullOr types.str);
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for accessing apiserver.";
          type = (types.nullOr types.str);
        };
        "host" = mkOption {
          description = "Host of apiserver.\nA valid string consisting of a hostname or IP followed by an optional port number";
          type = types.str;
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig Config to use for accessing apiserver.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfig"
            )
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerToken" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecApiServerConfigTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecArbitraryFSAccessThroughSMs" = {

      options = {
        "deny" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "deny" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplates" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr types.attrs);
        };
        "spec" = mkOption {
          description = "spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpec")
          );
        };
        "status" = mkOption {
          description = "status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesStatus")
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecSelector"
            )
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesSpecSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesStatusConditions" = {

      options = {
        "lastProbeTime" = mkOption {
          description = "lastProbeTime is the time we probed the condition.";
          type = (types.nullOr types.str);
        };
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the time the condition transitioned from one status to another.";
          type = (types.nullOr types.str);
        };
        "message" = mkOption {
          description = "message is the human-readable message indicating details about last transition.";
          type = (types.nullOr types.str);
        };
        "reason" = mkOption {
          description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
          type = (types.nullOr types.str);
        };
        "status" = mkOption {
          description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
          type = types.str;
        };
      };

      config = {
        "lastProbeTime" = mkOverride 1002 null;
        "lastTransitionTime" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecClaimTemplatesStatusModifyVolumeStatus" = {

      options = {
        "status" = mkOption {
          description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
          type = types.str;
        };
        "targetVolumeAttributesClassName" = mkOption {
          description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "targetVolumeAttributesClassName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecConfigReloadAuthKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecConfigReloaderResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAgentSpecConfigReloaderResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecConfigReloaderResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAgentSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecGlobalScrapeMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecGlobalScrapeRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecInlineRelabelConfig" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecInsertPorts" = {

      options = {
        "graphitePort" = mkOption {
          description = "GraphitePort listen port";
          type = (types.nullOr types.str);
        };
        "influxPort" = mkOption {
          description = "InfluxPort listen port";
          type = (types.nullOr types.str);
        };
        "openTSDBHTTPPort" = mkOption {
          description = "OpenTSDBHTTPPort for http connections.";
          type = (types.nullOr types.str);
        };
        "openTSDBPort" = mkOption {
          description = "OpenTSDBPort for tcp and udp listen";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "graphitePort" = mkOverride 1002 null;
        "influxPort" = mkOverride 1002 null;
        "openTSDBHTTPPort" = mkOverride 1002 null;
        "openTSDBPort" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecLicense" = {

      options = {
        "forceOffline" = mkOption {
          description = "Enforce offline verification of the license key.";
          type = (types.nullOr types.bool);
        };
        "key" = mkOption {
          description = "Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).\nTo request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)";
          type = (types.nullOr types.str);
        };
        "keyRef" = mkOption {
          description = "KeyRef is reference to secret with license key for enterprise features.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecLicenseKeyRef"));
        };
        "reloadInterval" = mkOption {
          description = "Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "forceOffline" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "keyRef" = mkOverride 1002 null;
        "reloadInterval" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecLicenseKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeRelabelTemplate" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecNodeScrapeSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPersistentVolumeClaimRetentionPolicy" = {

      options = {
        "whenDeleted" = mkOption {
          description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
          type = (types.nullOr types.str);
        };
        "whenScaled" = mkOption {
          description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "whenDeleted" = mkOverride 1002 null;
        "whenScaled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeRelabelTemplate" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecPodScrapeSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeScrapeRelabelTemplate" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecProbeSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRelabelConfig" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWrite" = {

      options = {
        "aws" = mkOption {
          description = "AWS describes params specific to AWS cloud";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteAws")
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBasicAuth")
          );
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBearerTokenSecret"
            )
          );
        };
        "forceVMProto" = mkOption {
          description = "ForceVMProto forces using VictoriaMetrics protocol for sending data to -remoteWrite.url";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers allow configuring custom http headers\nMust be in form of semicolon separated header with value\ne.g.\nheaderName: headerValue\nvmagent supports since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "inlineUrlRelabelConfig" = mkOption {
          description = "InlineUrlRelabelConfig defines relabeling config for remoteWriteURL, it can be defined at crd spec.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteInlineUrlRelabelConfig"
              )
            )
          );
        };
        "maxDiskUsage" = mkOption {
          description = "MaxDiskUsage defines the maximum file-based buffer size in bytes for the given remoteWrite\nIt overrides global configuration defined at remoteWriteSettings.maxDiskUsagePerURL";
          type = (types.nullOr types.attrs);
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2")
          );
        };
        "proxyURL" = mkOption {
          description = "ProxyURL for -remoteWrite.url. Supported proxies: http, https, socks5. Example: socks5://proxy:1234";
          type = (types.nullOr types.str);
        };
        "sendTimeout" = mkOption {
          description = "Timeout for sending a single block of data to -remoteWrite.url (default 1m0s)";
          type = (types.nullOr types.str);
        };
        "streamAggrConfig" = mkOption {
          description = "StreamAggrConfig defines stream aggregation configuration for VMAgent for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfig"
            )
          );
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig describes tls configuration for remote write target";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfig")
          );
        };
        "url" = mkOption {
          description = "URL of the endpoint to send samples to.";
          type = types.str;
        };
        "urlRelabelConfig" = mkOption {
          description = "ConfigMap with relabeling config which is applied to metrics before sending them to the corresponding -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteUrlRelabelConfig"
            )
          );
        };
      };

      config = {
        "aws" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "forceVMProto" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "inlineUrlRelabelConfig" = mkOverride 1002 null;
        "maxDiskUsage" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "sendTimeout" = mkOverride 1002 null;
        "streamAggrConfig" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "urlRelabelConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteAws" = {

      options = {
        "ec2Endpoint" = mkOption {
          description = "EC2Endpoint is an optional AWS EC2 API endpoint to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set";
          type = (types.nullOr types.str);
        };
        "region" = mkOption {
          description = "Region is an optional AWS region to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set";
          type = (types.nullOr types.str);
        };
        "roleARN" = mkOption {
          description = "RoleARN is an optional AWS region to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set";
          type = (types.nullOr types.str);
        };
        "service" = mkOption {
          description = "Service is an optional AWS Service to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set";
          type = (types.nullOr types.str);
        };
        "stsEndpoint" = mkOption {
          description = "STSEndpoint is an optional AWS STS API endpoint to use for the corresponding -remoteWrite.url if -remoteWrite.aws.useSigv4 is set";
          type = (types.nullOr types.str);
        };
        "useSigv4" = mkOption {
          description = "UseSigv4 enables SigV4 request signing for the corresponding -remoteWrite.url";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "ec2Endpoint" = mkOverride 1002 null;
        "region" = mkOverride 1002 null;
        "roleARN" = mkOverride 1002 null;
        "service" = mkOverride 1002 null;
        "stsEndpoint" = mkOverride 1002 null;
        "useSigv4" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteInlineUrlRelabelConfig" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_id");
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteSettings" = {

      options = {
        "flushInterval" = mkOption {
          description = "Interval for flushing the data to remote storage. (default 1s)";
          type = (types.nullOr types.str);
        };
        "label" = mkOption {
          description = "Labels in the form 'name=value' to add to all the metrics before sending them. This overrides the label if it already exists.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "maxBlockSize" = mkOption {
          description = "The maximum size in bytes of unpacked request to send to remote storage";
          type = (types.nullOr types.int);
        };
        "maxDiskUsagePerURL" = mkOption {
          description = "The maximum file-based buffer size in bytes at -remoteWrite.tmpDataPath";
          type = (types.nullOr types.attrs);
        };
        "queues" = mkOption {
          description = "The number of concurrent queues";
          type = (types.nullOr types.int);
        };
        "showURL" = mkOption {
          description = "Whether to show -remoteWrite.url in the exported metrics. It is hidden by default, since it can contain sensitive auth info";
          type = (types.nullOr types.bool);
        };
        "tmpDataPath" = mkOption {
          description = "Path to directory where temporary data for remote write component is stored (default vmagent-remotewrite-data)";
          type = (types.nullOr types.str);
        };
        "useMultiTenantMode" = mkOption {
          description = "Configures vmagent accepting data via the same multitenant endpoints as vminsert at VictoriaMetrics cluster does,\nsee [here](https://docs.victoriametrics.com/victoriametrics/vmagent/#multitenancy).\nit's global setting and affects all remote storage configurations";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "flushInterval" = mkOverride 1002 null;
        "label" = mkOverride 1002 null;
        "maxBlockSize" = mkOverride 1002 null;
        "maxDiskUsagePerURL" = mkOverride 1002 null;
        "queues" = mkOverride 1002 null;
        "showURL" = mkOverride 1002 null;
        "tmpDataPath" = mkOverride 1002 null;
        "useMultiTenantMode" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfig" = {

      options = {
        "configmap" = mkOption {
          description = "ConfigMap with stream aggregation rules";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigConfigmap"
            )
          );
        };
        "dedupInterval" = mkOption {
          description = "Allows setting different de-duplication intervals per each configured remote storage";
          type = (types.nullOr types.str);
        };
        "dropInput" = mkOption {
          description = "Allow drop all the input samples after the aggregation";
          type = (types.nullOr types.bool);
        };
        "dropInputLabels" = mkOption {
          description = "labels to drop from samples for aggregator before stream de-duplication and aggregation";
          type = (types.nullOr (types.listOf types.str));
        };
        "enableWindows" = mkOption {
          description = "EnableWindows enables aggregating data in separate windows ( available from v0.54.0).";
          type = (types.nullOr types.bool);
        };
        "ignoreFirstIntervals" = mkOption {
          description = "IgnoreFirstIntervals instructs to ignore first interval";
          type = (types.nullOr types.int);
        };
        "ignoreFirstSampleInterval" = mkOption {
          description = "IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored";
          type = (types.nullOr types.str);
        };
        "ignoreOldSamples" = mkOption {
          description = "IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.";
          type = (types.nullOr types.bool);
        };
        "keepInput" = mkOption {
          description = "Allows writing both raw and aggregate data";
          type = (types.nullOr types.bool);
        };
        "rules" = mkOption {
          description = "Stream aggregation rules";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigRules"
              )
            )
          );
        };
      };

      config = {
        "configmap" = mkOverride 1002 null;
        "dedupInterval" = mkOverride 1002 null;
        "dropInput" = mkOverride 1002 null;
        "dropInputLabels" = mkOverride 1002 null;
        "enableWindows" = mkOverride 1002 null;
        "ignoreFirstIntervals" = mkOverride 1002 null;
        "ignoreFirstSampleInterval" = mkOverride 1002 null;
        "ignoreOldSamples" = mkOverride 1002 null;
        "keepInput" = mkOverride 1002 null;
        "rules" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigConfigmap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigRules" = {

      options = {
        "by" = mkOption {
          description = "By is an optional list of labels for grouping input series.\n\nSee also Without.\n\nIf neither By nor Without are set, then the Outputs are calculated\nindividually per each input time series.";
          type = (types.nullOr (types.listOf types.str));
        };
        "dedup_interval" = mkOption {
          description = "DedupInterval is an optional interval for deduplication.";
          type = (types.nullOr types.str);
        };
        "drop_input_labels" = mkOption {
          description = "DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.\n\nLabels are dropped before de-duplication and aggregation.";
          type = (types.nullOr (types.listOf types.str));
        };
        "enable_windows" = mkOption {
          description = "EnableWindows enables aggregating data in separate windows";
          type = (types.nullOr types.bool);
        };
        "flush_on_shutdown" = mkOption {
          description = "FlushOnShutdown defines whether to flush the aggregation state on process termination\nor config reload. Is `false` by default.\nIt is not recommended changing this setting, unless unfinished aggregations states\nare preferred to missing data points.";
          type = (types.nullOr types.bool);
        };
        "ignoreFirstSampleInterval" = mkOption {
          description = "IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored";
          type = (types.nullOr types.str);
        };
        "ignore_first_intervals" = mkOption {
          description = "";
          type = (types.nullOr types.int);
        };
        "ignore_old_samples" = mkOption {
          description = "IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.";
          type = (types.nullOr types.bool);
        };
        "input_relabel_configs" = mkOption {
          description = "InputRelabelConfigs is an optional relabeling rules, which are applied on the input\nbefore aggregation.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigRulesInput_relabel_configs"
              )
            )
          );
        };
        "interval" = mkOption {
          description = "Interval is the interval between aggregations.";
          type = types.str;
        };
        "keep_metric_names" = mkOption {
          description = "KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.";
          type = (types.nullOr types.bool);
        };
        "match" = mkOption {
          description = "Match is a label selector (or list of label selectors) for filtering time series for the given selector.\n\nIf the match isn't set, then all the input time series are processed.";
          type = (types.nullOr types.attrs);
        };
        "no_align_flush_to_interval" = mkOption {
          description = "NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.\nBy default flushes are aligned to Interval.";
          type = (types.nullOr types.bool);
        };
        "output_relabel_configs" = mkOption {
          description = "OutputRelabelConfigs is an optional relabeling rules, which are applied\non the aggregated output before being sent to remote storage.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigRulesOutput_relabel_configs"
              )
            )
          );
        };
        "outputs" = mkOption {
          description = "Outputs is a list of output aggregate functions to produce.\n\nThe following names are allowed:\n\n- total - aggregates input counters\n- increase - counts the increase over input counters\n- count_series - counts the input series\n- count_samples - counts the input samples\n- sum_samples - sums the input samples\n- last - the last biggest sample value\n- min - the minimum sample value\n- max - the maximum sample value\n- avg - the average value across all the samples\n- stddev - standard deviation across all the samples\n- stdvar - standard variance across all the samples\n- histogram_bucket - creates VictoriaMetrics histogram for input samples\n- quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]\n\nThe output time series will have the following names:\n\n  input_name:aggr_<interval>_<output>";
          type = (types.listOf types.str);
        };
        "staleness_interval" = mkOption {
          description = "Staleness interval is interval after which the series state will be reset if no samples have been sent during it.\nThe parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.";
          type = (types.nullOr types.str);
        };
        "without" = mkOption {
          description = "Without is an optional list of labels, which must be excluded when grouping input series.\n\nSee also By.\n\nIf neither By nor Without are set, then the Outputs are calculated\nindividually per each input time series.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "by" = mkOverride 1002 null;
        "dedup_interval" = mkOverride 1002 null;
        "drop_input_labels" = mkOverride 1002 null;
        "enable_windows" = mkOverride 1002 null;
        "flush_on_shutdown" = mkOverride 1002 null;
        "ignoreFirstSampleInterval" = mkOverride 1002 null;
        "ignore_first_intervals" = mkOverride 1002 null;
        "ignore_old_samples" = mkOverride 1002 null;
        "input_relabel_configs" = mkOverride 1002 null;
        "keep_metric_names" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "no_align_flush_to_interval" = mkOverride 1002 null;
        "output_relabel_configs" = mkOverride 1002 null;
        "staleness_interval" = mkOverride 1002 null;
        "without" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigRulesInput_relabel_configs" =
      {

        options = {
          "action" = mkOption {
            description = "Action to perform based on regex matching. Default is 'replace'";
            type = (types.nullOr types.str);
          };
          "if" = mkOption {
            description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
            type = (types.nullOr types.attrs);
          };
          "labels" = mkOption {
            description = "Labels is used together with Match for `action: graphite`";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "match" = mkOption {
            description = "Match is used together with Labels for `action: graphite`";
            type = (types.nullOr types.str);
          };
          "modulus" = mkOption {
            description = "Modulus to take of the hash of the source label values.";
            type = (types.nullOr types.int);
          };
          "regex" = mkOption {
          type = (types.nullOr types.str);
          };
          "replacement" = mkOption {
            description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
            type = (types.nullOr types.str);
          };
          "separator" = mkOption {
            description = "Separator placed between concatenated source label values. default is ';'.";
            type = (types.nullOr types.str);
          };
          "sourceLabels" = mkOption {
            description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
            type = (types.nullOr (types.listOf types.str));
          };
          "source_labels" = mkOption {
            description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
            type = (types.nullOr (types.listOf types.str));
          };
          "targetLabel" = mkOption {
            description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
            type = (types.nullOr types.str);
          };
          "target_label" = mkOption {
            description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "action" = mkOverride 1002 null;
          "if" = mkOverride 1002 null;
          "labels" = mkOverride 1002 null;
          "match" = mkOverride 1002 null;
          "modulus" = mkOverride 1002 null;
          "regex" = mkOverride 1002 null;
          "replacement" = mkOverride 1002 null;
          "separator" = mkOverride 1002 null;
          "sourceLabels" = mkOverride 1002 null;
          "source_labels" = mkOverride 1002 null;
          "targetLabel" = mkOverride 1002 null;
          "target_label" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteStreamAggrConfigRulesOutput_relabel_configs" =
      {

        options = {
          "action" = mkOption {
            description = "Action to perform based on regex matching. Default is 'replace'";
            type = (types.nullOr types.str);
          };
          "if" = mkOption {
            description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
            type = (types.nullOr types.attrs);
          };
          "labels" = mkOption {
            description = "Labels is used together with Match for `action: graphite`";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "match" = mkOption {
            description = "Match is used together with Labels for `action: graphite`";
            type = (types.nullOr types.str);
          };
          "modulus" = mkOption {
            description = "Modulus to take of the hash of the source label values.";
            type = (types.nullOr types.int);
          };
          "regex" = mkOption {
          type = (types.nullOr types.str);
          };
          "replacement" = mkOption {
            description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
            type = (types.nullOr types.str);
          };
          "separator" = mkOption {
            description = "Separator placed between concatenated source label values. default is ';'.";
            type = (types.nullOr types.str);
          };
          "sourceLabels" = mkOption {
            description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
            type = (types.nullOr (types.listOf types.str));
          };
          "source_labels" = mkOption {
            description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
            type = (types.nullOr (types.listOf types.str));
          };
          "targetLabel" = mkOption {
            description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
            type = (types.nullOr types.str);
          };
          "target_label" = mkOption {
            description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "action" = mkOverride 1002 null;
          "if" = mkOverride 1002 null;
          "labels" = mkOverride 1002 null;
          "match" = mkOverride 1002 null;
          "modulus" = mkOverride 1002 null;
          "regex" = mkOverride 1002 null;
          "replacement" = mkOverride 1002 null;
          "separator" = mkOverride 1002 null;
          "sourceLabels" = mkOverride 1002 null;
          "source_labels" = mkOverride 1002 null;
          "targetLabel" = mkOverride 1002 null;
          "target_label" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCa")
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRemoteWriteUrlRelabelConfig" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAgentSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClasses" = {

      options = {
        "attachMetadata" = mkOption {
          description = "AttachMetadata defines additional metadata to the discovered targets.\nWhen the scrape object defines its own configuration, it takes\nprecedence over the scrape class configuration.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesAttachMetadata"
            )
          );
        };
        "authorization" = mkOption {
          description = "Authorization with http header Authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for scraping targets.";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Secret to mount to read bearer token for scraping targets. The secret\nneeds to be in the same namespace as the scrape object and accessible by\nthe victoria-metrics operator.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBearerTokenSecret"
            )
          );
        };
        "default" = mkOption {
          description = "default defines that the scrape applies to all scrape objects that\ndon't configure an explicit scrape class name.\n\nOnly one scrape class can be set as the default.";
          type = (types.nullOr types.bool);
        };
        "metricRelabelConfigs" = mkOption {
          description = "MetricRelabelConfigs to apply to samples after scrapping.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesMetricRelabelConfigs"
              )
            )
          );
        };
        "name" = mkOption {
          description = "name of the scrape class.";
          type = types.str;
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2")
          );
        };
        "relabelConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesRelabelConfigs"
              )
            )
          );
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig configuration to use when scraping the endpoint";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfig")
          );
        };
      };

      config = {
        "attachMetadata" = mkOverride 1002 null;
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "default" = mkOverride 1002 null;
        "metricRelabelConfigs" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "relabelConfigs" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesAttachMetadata" = {

      options = {
        "node" = mkOption {
          description = "Node instructs vmagent to add node specific metadata from service discovery\nValid for roles: pod, endpoints, endpointslice.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "node" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_id");
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeClassesTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigRelabelTemplate" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecScrapeConfigSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeRelabelTemplate" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceScrapeSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageEmptyDir")
          );
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplate"
            )
          );
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplate" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "EmbeddedMetadata contains metadata relevant to an EmbeddedResource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "Spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpec"
            )
          );
        };
        "status" = mkOption {
          description = "Status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateStatus"
            )
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector"
            )
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSource" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecDataSourceRef" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
          "namespace" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecResources" =
      {

        options = {
          "limits" = mkOption {
            description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
          "requests" = mkOption {
            description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
        };

        config = {
          "limits" = mkOverride 1002 null;
          "requests" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateStatusConditions" =
      {

        options = {
          "lastProbeTime" = mkOption {
            description = "lastProbeTime is the time we probed the condition.";
            type = (types.nullOr types.str);
          };
          "lastTransitionTime" = mkOption {
            description = "lastTransitionTime is the time the condition transitioned from one status to another.";
            type = (types.nullOr types.str);
          };
          "message" = mkOption {
            description = "message is the human-readable message indicating details about last transition.";
            type = (types.nullOr types.str);
          };
          "reason" = mkOption {
            description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
            type = (types.nullOr types.str);
          };
          "status" = mkOption {
            description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
            type = types.str;
          };
        };

        config = {
          "lastProbeTime" = mkOverride 1002 null;
          "lastTransitionTime" = mkOverride 1002 null;
          "message" = mkOverride 1002 null;
          "reason" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStatefulStorageVolumeClaimTemplateStatusModifyVolumeStatus" =
      {

        options = {
          "status" = mkOption {
            description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
            type = types.str;
          };
          "targetVolumeAttributesClassName" = mkOption {
            description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "targetVolumeAttributesClassName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeRelabelTemplate" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStaticScrapeSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfig" = {

      options = {
        "configmap" = mkOption {
          description = "ConfigMap with stream aggregation rules";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigConfigmap"
            )
          );
        };
        "dedupInterval" = mkOption {
          description = "Allows setting different de-duplication intervals per each configured remote storage";
          type = (types.nullOr types.str);
        };
        "dropInput" = mkOption {
          description = "Allow drop all the input samples after the aggregation";
          type = (types.nullOr types.bool);
        };
        "dropInputLabels" = mkOption {
          description = "labels to drop from samples for aggregator before stream de-duplication and aggregation";
          type = (types.nullOr (types.listOf types.str));
        };
        "enableWindows" = mkOption {
          description = "EnableWindows enables aggregating data in separate windows ( available from v0.54.0).";
          type = (types.nullOr types.bool);
        };
        "ignoreFirstIntervals" = mkOption {
          description = "IgnoreFirstIntervals instructs to ignore first interval";
          type = (types.nullOr types.int);
        };
        "ignoreFirstSampleInterval" = mkOption {
          description = "IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored";
          type = (types.nullOr types.str);
        };
        "ignoreOldSamples" = mkOption {
          description = "IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.";
          type = (types.nullOr types.bool);
        };
        "keepInput" = mkOption {
          description = "Allows writing both raw and aggregate data";
          type = (types.nullOr types.bool);
        };
        "rules" = mkOption {
          description = "Stream aggregation rules";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigRules")
            )
          );
        };
      };

      config = {
        "configmap" = mkOverride 1002 null;
        "dedupInterval" = mkOverride 1002 null;
        "dropInput" = mkOverride 1002 null;
        "dropInputLabels" = mkOverride 1002 null;
        "enableWindows" = mkOverride 1002 null;
        "ignoreFirstIntervals" = mkOverride 1002 null;
        "ignoreFirstSampleInterval" = mkOverride 1002 null;
        "ignoreOldSamples" = mkOverride 1002 null;
        "keepInput" = mkOverride 1002 null;
        "rules" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigConfigmap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigRules" = {

      options = {
        "by" = mkOption {
          description = "By is an optional list of labels for grouping input series.\n\nSee also Without.\n\nIf neither By nor Without are set, then the Outputs are calculated\nindividually per each input time series.";
          type = (types.nullOr (types.listOf types.str));
        };
        "dedup_interval" = mkOption {
          description = "DedupInterval is an optional interval for deduplication.";
          type = (types.nullOr types.str);
        };
        "drop_input_labels" = mkOption {
          description = "DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.\n\nLabels are dropped before de-duplication and aggregation.";
          type = (types.nullOr (types.listOf types.str));
        };
        "enable_windows" = mkOption {
          description = "EnableWindows enables aggregating data in separate windows";
          type = (types.nullOr types.bool);
        };
        "flush_on_shutdown" = mkOption {
          description = "FlushOnShutdown defines whether to flush the aggregation state on process termination\nor config reload. Is `false` by default.\nIt is not recommended changing this setting, unless unfinished aggregations states\nare preferred to missing data points.";
          type = (types.nullOr types.bool);
        };
        "ignoreFirstSampleInterval" = mkOption {
          description = "IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored";
          type = (types.nullOr types.str);
        };
        "ignore_first_intervals" = mkOption {
          description = "";
          type = (types.nullOr types.int);
        };
        "ignore_old_samples" = mkOption {
          description = "IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.";
          type = (types.nullOr types.bool);
        };
        "input_relabel_configs" = mkOption {
          description = "InputRelabelConfigs is an optional relabeling rules, which are applied on the input\nbefore aggregation.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigRulesInput_relabel_configs"
              )
            )
          );
        };
        "interval" = mkOption {
          description = "Interval is the interval between aggregations.";
          type = types.str;
        };
        "keep_metric_names" = mkOption {
          description = "KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.";
          type = (types.nullOr types.bool);
        };
        "match" = mkOption {
          description = "Match is a label selector (or list of label selectors) for filtering time series for the given selector.\n\nIf the match isn't set, then all the input time series are processed.";
          type = (types.nullOr types.attrs);
        };
        "no_align_flush_to_interval" = mkOption {
          description = "NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.\nBy default flushes are aligned to Interval.";
          type = (types.nullOr types.bool);
        };
        "output_relabel_configs" = mkOption {
          description = "OutputRelabelConfigs is an optional relabeling rules, which are applied\non the aggregated output before being sent to remote storage.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigRulesOutput_relabel_configs"
              )
            )
          );
        };
        "outputs" = mkOption {
          description = "Outputs is a list of output aggregate functions to produce.\n\nThe following names are allowed:\n\n- total - aggregates input counters\n- increase - counts the increase over input counters\n- count_series - counts the input series\n- count_samples - counts the input samples\n- sum_samples - sums the input samples\n- last - the last biggest sample value\n- min - the minimum sample value\n- max - the maximum sample value\n- avg - the average value across all the samples\n- stddev - standard deviation across all the samples\n- stdvar - standard variance across all the samples\n- histogram_bucket - creates VictoriaMetrics histogram for input samples\n- quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]\n\nThe output time series will have the following names:\n\n  input_name:aggr_<interval>_<output>";
          type = (types.listOf types.str);
        };
        "staleness_interval" = mkOption {
          description = "Staleness interval is interval after which the series state will be reset if no samples have been sent during it.\nThe parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.";
          type = (types.nullOr types.str);
        };
        "without" = mkOption {
          description = "Without is an optional list of labels, which must be excluded when grouping input series.\n\nSee also By.\n\nIf neither By nor Without are set, then the Outputs are calculated\nindividually per each input time series.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "by" = mkOverride 1002 null;
        "dedup_interval" = mkOverride 1002 null;
        "drop_input_labels" = mkOverride 1002 null;
        "enable_windows" = mkOverride 1002 null;
        "flush_on_shutdown" = mkOverride 1002 null;
        "ignoreFirstSampleInterval" = mkOverride 1002 null;
        "ignore_first_intervals" = mkOverride 1002 null;
        "ignore_old_samples" = mkOverride 1002 null;
        "input_relabel_configs" = mkOverride 1002 null;
        "keep_metric_names" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "no_align_flush_to_interval" = mkOverride 1002 null;
        "output_relabel_configs" = mkOverride 1002 null;
        "staleness_interval" = mkOverride 1002 null;
        "without" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigRulesInput_relabel_configs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecStreamAggrConfigRulesOutput_relabel_configs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAgentStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "replicas" = mkOption {
          description = "ReplicaCount Total number of pods targeted by this VMAgent";
          type = (types.nullOr types.int);
        };
        "selector" = mkOption {
          description = "Selector string form of label value set for autoscaling";
          type = (types.nullOr types.str);
        };
        "shards" = mkOption {
          description = "Shards represents total number of vmagent deployments with uniq scrape targets";
          type = (types.nullOr types.int);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "replicas" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "shards" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAgentStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlert" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMAlertSpec defines the desired state of VMAlert";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpec"));
        };
        "status" = mkOption {
          description = "VMAlertStatus defines the observed state of VMAlert";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpec" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "configReloadAuthKeySecret" = mkOption {
          description = "ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.\nGiven secret reference will be added to the application and vm-config-reloader as volume\navailable since v0.57.0 version";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecConfigReloadAuthKeySecret"
            )
          );
        };
        "configReloaderExtraArgs" = mkOption {
          description = "ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container\nfor example resyncInterval: \"30s\"";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "configReloaderImageTag" = mkOption {
          description = "ConfigReloaderImageTag defines image:tag for config-reloader container";
          type = (types.nullOr types.str);
        };
        "configReloaderResources" = mkOption {
          description = "ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecConfigReloaderResources")
          );
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "datasource" = mkOption {
          description = "Datasource Victoria Metrics or VMSelect url. Required parameter. e.g. http://127.0.0.1:8428";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasource");
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "enforcedNamespaceLabel" = mkOption {
          description = "EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert\nand metric that is user created. The label value will always be the namespace of the object that is\nbeing created.";
          type = (types.nullOr types.str);
        };
        "evaluationInterval" = mkOption {
          description = "EvaluationInterval defines how often to evaluate rules by default";
          type = (types.nullOr types.str);
        };
        "externalLabels" = mkOption {
          description = "ExternalLabels in the form 'name: value' to add to all generated recording rules and alerts.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecHost_aliases")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "license" = mkOption {
          description = "License allows to configure license key to be used for enterprise features.\nUsing license key is supported starting from VictoriaMetrics v1.94.0.\nSee [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecLicense"));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMAlert to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMAlert to be configured with.";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecManagedMetadata")
          );
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "notifier" = mkOption {
          description = "Notifier prometheus alertmanager endpoint spec. Required at least one of notifier or notifiers when there are alerting rules. e.g. http://127.0.0.1:9093\nIf specified both notifier and notifiers, notifier will be added as last element to notifiers.\nonly one of notifier options could be chosen: notifierConfigRef or notifiers + notifier";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifier"));
        };
        "notifierConfigRef" = mkOption {
          description = "NotifierConfigRef reference for secret with notifier configuration for vmalert\nonly one of notifier options could be chosen: notifierConfigRef or notifiers + notifier";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierConfigRef")
          );
        };
        "notifiers" = mkOption {
          description = "Notifiers prometheus alertmanager endpoints. Required at least one of notifier or notifiers when there are alerting rules. e.g. http://127.0.0.1:9093\nIf specified both notifier and notifiers, notifier will be added as last element to notifiers.\nonly one of notifier options could be chosen: notifierConfigRef or notifiers + notifier";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiers")
            )
          );
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecPodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VMAlert pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecPodMetadata"));
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "remoteRead" = mkOption {
          description = "RemoteRead Optional URL to read vmalert state (persisted via RemoteWrite)\nThis configuration only makes sense if alerts state has been successfully\npersisted (via RemoteWrite) before.\nsee -remoteRead.url docs in vmalerts for details.\nE.g. http://127.0.0.1:8428";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteRead"));
        };
        "remoteWrite" = mkOption {
          description = "RemoteWrite Optional URL to remote-write compatible storage to persist\nvmalert state and rule results to.\nRule results will be persisted according to each rule.\nAlerts state will be persisted in the form of time series named ALERTS and ALERTS_FOR_STATE\nsee -remoteWrite.url docs in vmalerts for details.\nE.g. http://127.0.0.1:8428";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWrite"));
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecResources"));
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRollingUpdate"));
        };
        "ruleNamespaceSelector" = mkOption {
          description = "RuleNamespaceSelector to be selected for VMRules discovery.\nWorks in combination with Selector.\nIf both nil - behaviour controlled by selectAllByDefault\nNamespaceSelector nil - only objects at VMAlert namespace.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleNamespaceSelector")
          );
        };
        "rulePath" = mkOption {
          description = "RulePath to the file with alert rules.\nSupports patterns. Flag can be specified multiple times.\nExamples:\n-rule /path/to/file. Path to a single file with alerting rules\n-rule dir/*.yaml -rule /*.yaml. Relative path to all .yaml files in folder,\nabsolute path to all .yaml files in root.\nby default operator adds /etc/vmalert/configs/base/vmalert.yaml";
          type = (types.nullOr (types.listOf types.str));
        };
        "ruleSelector" = mkOption {
          description = "RuleSelector selector to select which VMRules to mount for loading alerting\nrules from.\nWorks in combination with NamespaceSelector.\nIf both nil - behaviour controlled by selectAllByDefault\nNamespaceSelector nil - only objects at VMAlert namespace.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleSelector"));
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "selectAllByDefault" = mkOption {
          description = "SelectAllByDefault changes default behavior for empty CRD selectors, such RuleSelector.\nwith selectAllByDefault: true and empty serviceScrapeSelector and RuleNamespaceSelector\nOperator selects all exist serviceScrapes\nwith selectAllByDefault: false - selects nothing";
          type = (types.nullOr types.bool);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmalert VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vmalert service spec";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecServiceSpec"));
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "useVMConfigReloader" = mkOption {
          description = "UseVMConfigReloader replaces prometheus-like config-reloader\nwith vm one. It uses secrets watch instead of file watch\nwhich greatly increases speed of config updates";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAlertSpecVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "configReloadAuthKeySecret" = mkOverride 1002 null;
        "configReloaderExtraArgs" = mkOverride 1002 null;
        "configReloaderImageTag" = mkOverride 1002 null;
        "configReloaderResources" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "enforcedNamespaceLabel" = mkOverride 1002 null;
        "evaluationInterval" = mkOverride 1002 null;
        "externalLabels" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "license" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "notifier" = mkOverride 1002 null;
        "notifierConfigRef" = mkOverride 1002 null;
        "notifiers" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "remoteRead" = mkOverride 1002 null;
        "remoteWrite" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "ruleNamespaceSelector" = mkOverride 1002 null;
        "rulePath" = mkOverride 1002 null;
        "ruleSelector" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "selectAllByDefault" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "useVMConfigReloader" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecConfigReloadAuthKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecConfigReloaderResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertSpecConfigReloaderResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecConfigReloaderResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasource" = {

      options = {
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBearerTokenSecret"
            )
          );
        };
        "headers" = mkOption {
          description = "Headers allow configuring custom http headers\nMust be in form of semicolon separated header with value\ne.g.\nheaderName:headerValue\nvmalert supports it since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines OAuth2 configuration";
          type = (types.nullOr types.attrs);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig specifies TLSConfig configuration parameters.";
          type = (types.nullOr types.attrs);
        };
        "url" = mkOption {
          description = "Victoria Metrics or VMSelect url. Required parameter. E.g. http://127.0.0.1:8428";
          type = types.str;
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecDatasourceBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecLicense" = {

      options = {
        "forceOffline" = mkOption {
          description = "Enforce offline verification of the license key.";
          type = (types.nullOr types.bool);
        };
        "key" = mkOption {
          description = "Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).\nTo request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)";
          type = (types.nullOr types.str);
        };
        "keyRef" = mkOption {
          description = "KeyRef is reference to secret with license key for enterprise features.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecLicenseKeyRef"));
        };
        "reloadInterval" = mkOption {
          description = "Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "forceOffline" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "keyRef" = mkOverride 1002 null;
        "reloadInterval" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecLicenseKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifier" = {

      options = {
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBearerTokenSecret"
            )
          );
        };
        "headers" = mkOption {
          description = "Headers allow configuring custom http headers\nMust be in form of semicolon separated header with value\ne.g.\nheaderName:headerValue\nvmalert supports it since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines OAuth2 configuration";
          type = (types.nullOr types.attrs);
        };
        "selector" = mkOption {
          description = "Selector allows service discovery for alertmanager\nin this case all matched vmalertmanager replicas will be added into vmalert notifier.url\nas statefulset pod.fqdn";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelector")
          );
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig specifies TLSConfig configuration parameters.";
          type = (types.nullOr types.attrs);
        };
        "url" = mkOption {
          description = "AlertManager url.  E.g. http://127.0.0.1:9093";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "url" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierConfigRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelector" = {

      options = {
        "labelSelector" = mkOption {
          description = "A label selector is a label query over a set of resources. The result of matchLabels and\nmatchExpressions are ANDed. An empty label selector matches all objects. A null\nlabel selector matches no objects.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelectorLabelSelector"
            )
          );
        };
        "namespaceSelector" = mkOption {
          description = "NamespaceSelector is a selector for selecting either all namespaces or a\nlist of namespaces.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelectorNamespaceSelector"
            )
          );
        };
      };

      config = {
        "labelSelector" = mkOverride 1002 null;
        "namespaceSelector" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelectorLabelSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelectorLabelSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelectorLabelSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifierSelectorNamespaceSelector" = {

      options = {
        "any" = mkOption {
          description = "Boolean describing whether all namespaces are selected in contrast to a\nlist restricting them.";
          type = (types.nullOr types.bool);
        };
        "matchNames" = mkOption {
          description = "List of namespace names.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "any" = mkOverride 1002 null;
        "matchNames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiers" = {

      options = {
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBearerTokenSecret"
            )
          );
        };
        "headers" = mkOption {
          description = "Headers allow configuring custom http headers\nMust be in form of semicolon separated header with value\ne.g.\nheaderName:headerValue\nvmalert supports it since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines OAuth2 configuration";
          type = (types.nullOr types.attrs);
        };
        "selector" = mkOption {
          description = "Selector allows service discovery for alertmanager\nin this case all matched vmalertmanager replicas will be added into vmalert notifier.url\nas statefulset pod.fqdn";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelector")
          );
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig specifies TLSConfig configuration parameters.";
          type = (types.nullOr types.attrs);
        };
        "url" = mkOption {
          description = "AlertManager url.  E.g. http://127.0.0.1:9093";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "url" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelector" = {

      options = {
        "labelSelector" = mkOption {
          description = "A label selector is a label query over a set of resources. The result of matchLabels and\nmatchExpressions are ANDed. An empty label selector matches all objects. A null\nlabel selector matches no objects.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelectorLabelSelector"
            )
          );
        };
        "namespaceSelector" = mkOption {
          description = "NamespaceSelector is a selector for selecting either all namespaces or a\nlist of namespaces.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelectorNamespaceSelector"
            )
          );
        };
      };

      config = {
        "labelSelector" = mkOverride 1002 null;
        "namespaceSelector" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelectorLabelSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelectorLabelSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelectorLabelSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecNotifiersSelectorNamespaceSelector" = {

      options = {
        "any" = mkOption {
          description = "Boolean describing whether all namespaces are selected in contrast to a\nlist restricting them.";
          type = (types.nullOr types.bool);
        };
        "matchNames" = mkOption {
          description = "List of namespace names.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "any" = mkOverride 1002 null;
        "matchNames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteRead" = {

      options = {
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBearerTokenSecret"
            )
          );
        };
        "headers" = mkOption {
          description = "Headers allow configuring custom http headers\nMust be in form of semicolon separated header with value\ne.g.\nheaderName:headerValue\nvmalert supports it since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "lookback" = mkOption {
          description = "Lookback defines how far to look into past for alerts timeseries. For example, if lookback=1h then range from now() to now()-1h will be scanned. (default 1h0m0s)\nApplied only to RemoteReadSpec";
          type = (types.nullOr types.str);
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines OAuth2 configuration";
          type = (types.nullOr types.attrs);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig specifies TLSConfig configuration parameters.";
          type = (types.nullOr types.attrs);
        };
        "url" = mkOption {
          description = "URL of the endpoint to send samples to.";
          type = types.str;
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "lookback" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteReadBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWrite" = {

      options = {
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "Path to bearer token file";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Optional bearer auth token to use for -remoteWrite.url";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBearerTokenSecret"
            )
          );
        };
        "concurrency" = mkOption {
          description = "Defines number of readers that concurrently write into remote storage (default 1)";
          type = (types.nullOr types.int);
        };
        "flushInterval" = mkOption {
          description = "Defines interval of flushes to remote write endpoint (default 5s)";
          type = (types.nullOr types.str);
        };
        "headers" = mkOption {
          description = "Headers allow configuring custom http headers\nMust be in form of semicolon separated header with value\ne.g.\nheaderName:headerValue\nvmalert supports it since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "maxBatchSize" = mkOption {
          description = "Defines defines max number of timeseries to be flushed at once (default 1000)";
          type = (types.nullOr types.int);
        };
        "maxQueueSize" = mkOption {
          description = "Defines the max number of pending datapoints to remote write endpoint (default 100000)";
          type = (types.nullOr types.int);
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines OAuth2 configuration";
          type = (types.nullOr types.attrs);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig specifies TLSConfig configuration parameters.";
          type = (types.nullOr types.attrs);
        };
        "url" = mkOption {
          description = "URL of the endpoint to send samples to.";
          type = types.str;
        };
      };

      config = {
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "concurrency" = mkOverride 1002 null;
        "flushInterval" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "maxBatchSize" = mkOverride 1002 null;
        "maxQueueSize" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRemoteWriteBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAlertSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecRuleSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertSpecServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanager" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "Specification of the desired behavior of the VMAlertmanager cluster. More info:\nhttps://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpec");
        };
        "status" = mkOption {
          description = "Most recent observed status of the VMAlertmanager cluster.\nOperator API itself. More info:\nhttps://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfig" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMAlertmanagerConfigSpec defines configuration for VMAlertmanagerConfig\nit must reference only locally defined objects";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpec"));
        };
        "status" = mkOption {
          description = "VMAlertmanagerConfigStatus defines the observed state of VMAlertmanagerConfig";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigStatus")
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpec" = {

      options = {
        "inhibit_rules" = mkOption {
          description = "InhibitRules will only apply for alerts matching\nthe resource's namespace.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecInhibit_rules"
              )
            )
          );
        };
        "receivers" = mkOption {
          description = "Receivers defines alert receivers";
          type = (
            coerceAttrsOfSubmodulesToListByKey
              "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceivers"
              "name"
              [ ]
          );
          apply = attrsToList;
        };
        "route" = mkOption {
          description = "Route definition for alertmanager, may include nested routes.";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecRoute");
        };
        "time_intervals" = mkOption {
          description = "TimeIntervals defines named interval for active/mute notifications interval\nSee https://prometheus.io/docs/alerting/latest/configuration/#time_interval";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecTime_intervals"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "inhibit_rules" = mkOverride 1002 null;
        "time_intervals" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecInhibit_rules" = {

      options = {
        "equal" = mkOption {
          description = "Labels that must have an equal value in the source and target alert for\nthe inhibition to take effect.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_matchers" = mkOption {
          description = "SourceMatchers defines a list of matchers for which one or more alerts have\nto exist for the inhibition to take effect.";
          type = (types.nullOr (types.listOf types.str));
        };
        "target_matchers" = mkOption {
          description = "TargetMatchers defines a list of matchers that have to be fulfilled by the target\nalerts to be muted.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "equal" = mkOverride 1002 null;
        "source_matchers" = mkOverride 1002 null;
        "target_matchers" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceivers" = {

      options = {
        "discord_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configs"
              )
            )
          );
        };
        "email_configs" = mkOption {
          description = "EmailConfigs defines email notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configs"
              )
            )
          );
        };
        "incidentio_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversIncidentio_configs"
              )
            )
          );
        };
        "jira_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversJira_configs"
              )
            )
          );
        };
        "msteams_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configs"
              )
            )
          );
        };
        "msteamsv2_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteamsv2_configs"
              )
            )
          );
        };
        "name" = mkOption {
          description = "Name of the receiver. Must be unique across all items from the list.";
          type = types.str;
        };
        "opsgenie_configs" = mkOption {
          description = "OpsGenieConfigs defines ops genie notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversOpsgenie_configs"
              )
            )
          );
        };
        "pagerduty_configs" = mkOption {
          description = "PagerDutyConfigs defines pager duty notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configs"
              )
            )
          );
        };
        "pushover_configs" = mkOption {
          description = "PushoverConfigs defines push over notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPushover_configs"
              )
            )
          );
        };
        "rocketchat_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configs"
              )
            )
          );
        };
        "slack_configs" = mkOption {
          description = "SlackConfigs defines slack notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configs"
              )
            )
          );
        };
        "sns_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configs"
              )
            )
          );
        };
        "telegram_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversTelegram_configs"
              )
            )
          );
        };
        "victorops_configs" = mkOption {
          description = "VictorOpsConfigs defines victor ops notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configs"
              )
            )
          );
        };
        "webex_configs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configs"
              )
            )
          );
        };
        "webhook_configs" = mkOption {
          description = "WebhookConfigs defines webhook notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebhook_configs"
              )
            )
          );
        };
        "wechat_configs" = mkOption {
          description = "WeChatConfigs defines wechat notification configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configs"
              )
            )
          );
        };
      };

      config = {
        "discord_configs" = mkOverride 1002 null;
        "email_configs" = mkOverride 1002 null;
        "incidentio_configs" = mkOverride 1002 null;
        "jira_configs" = mkOverride 1002 null;
        "msteams_configs" = mkOverride 1002 null;
        "msteamsv2_configs" = mkOverride 1002 null;
        "opsgenie_configs" = mkOverride 1002 null;
        "pagerduty_configs" = mkOverride 1002 null;
        "pushover_configs" = mkOverride 1002 null;
        "rocketchat_configs" = mkOverride 1002 null;
        "slack_configs" = mkOverride 1002 null;
        "sns_configs" = mkOverride 1002 null;
        "telegram_configs" = mkOverride 1002 null;
        "victorops_configs" = mkOverride 1002 null;
        "webex_configs" = mkOverride 1002 null;
        "webhook_configs" = mkOverride 1002 null;
        "wechat_configs" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configs" = {

      options = {
        "avatar_url" = mkOption {
          description = "AvatarURL defines message avatar URL\nAvailable from operator v0.55.0 and alertmanager v0.28.0";
          type = (types.nullOr types.str);
        };
        "content" = mkOption {
          description = "Content defines message content template\nAvailable from operator v0.55.0 and alertmanager v0.28.0";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_config"
            )
          );
        };
        "message" = mkOption {
          description = "The message body template";
          type = (types.nullOr types.str);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "title" = mkOption {
          description = "The message title template";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines message username\nAvailable from operator v0.55.0 and alertmanager v0.28.0";
          type = (types.nullOr types.str);
        };
        "webhook_url" = mkOption {
          description = "The discord webhook URL\none of `urlSecret` and `url` must be defined.";
          type = (types.nullOr types.str);
        };
        "webhook_url_secret" = mkOption {
          description = "URLSecret defines secret name and key at the CRD namespace.\nIt must contain the webhook URL.\none of `urlSecret` and `url` must be defined.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsWebhook_url_secret"
            )
          );
        };
      };

      config = {
        "avatar_url" = mkOverride 1002 null;
        "content" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "title" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
        "webhook_url" = mkOverride 1002 null;
        "webhook_url_secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_config" =
      {

        options = {
          "authorization" = mkOption {
            description = "Authorization header configuration for the client.\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configAuthorization"
              )
            );
          };
          "basic_auth" = mkOption {
            description = "BasicAuth for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBasic_auth"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "BearerTokenFile defines filename for bearer token, it must be mounted to pod.";
            type = (types.nullOr types.str);
          };
          "bearer_token_secret" = mkOption {
            description = "The secret's key that contains the bearer token\nIt must be at them same namespace as CRD";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBearer_token_secret"
              )
            );
          };
          "oauth2" = mkOption {
            description = "OAuth2 client credentials used to fetch a token for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2"
              )
            );
          };
          "proxyURL" = mkOption {
            description = "Optional proxy URL.";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "TLS configuration for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_config"
              )
            );
          };
        };

        config = {
          "authorization" = mkOverride 1002 null;
          "basic_auth" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "bearer_token_secret" = mkOverride 1002 null;
          "oauth2" = mkOverride 1002 null;
          "proxyURL" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configAuthorization" =
      {

        options = {
          "credentials" = mkOption {
            description = "Reference to the secret with value for authorization";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configAuthorizationCredentials"
              )
            );
          };
          "credentialsFile" = mkOption {
            description = "File with value for authorization";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type of authorization, default to bearer";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "credentials" = mkOverride 1002 null;
          "credentialsFile" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configBearer_token_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2" =
      {

        options = {
          "client_id" = mkOption {
            description = "The secret or configmap containing the OAuth2 client id";
            type = (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_id"
            );
          };
          "client_secret" = mkOption {
            description = "The secret containing the OAuth2 client secret";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_secret"
              )
            );
          };
          "client_secret_file" = mkOption {
            description = "ClientSecretFile defines path for client secret file.";
            type = (types.nullOr types.str);
          };
          "endpoint_params" = mkOption {
            description = "Parameters to append to the token URL";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "proxy_url" = mkOption {
            description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.str);
          };
          "scopes" = mkOption {
            description = "OAuth2 scopes used for the token request";
            type = (types.nullOr (types.listOf types.str));
          };
          "tls_config" = mkOption {
            description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.attrs);
          };
          "token_url" = mkOption {
            description = "The URL to fetch the token from";
            type = types.str;
          };
        };

        config = {
          "client_secret" = mkOverride 1002 null;
          "client_secret_file" = mkOverride 1002 null;
          "endpoint_params" = mkOverride 1002 null;
          "proxy_url" = mkOverride 1002 null;
          "scopes" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_id" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_idConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_idSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configOauth2Client_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_config" =
      {

        options = {
          "ca" = mkOption {
            description = "Struct containing the CA cert to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCa"
              )
            );
          };
          "caFile" = mkOption {
            description = "Path to the CA cert in the container to use for the targets.";
            type = (types.nullOr types.str);
          };
          "cert" = mkOption {
            description = "Struct containing the client cert file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCert"
              )
            );
          };
          "certFile" = mkOption {
            description = "Path to the client cert file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "insecureSkipVerify" = mkOption {
            description = "Disable target certificate validation.";
            type = (types.nullOr types.bool);
          };
          "keyFile" = mkOption {
            description = "Path to the client key file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "keySecret" = mkOption {
            description = "Secret containing the client key file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configKeySecret"
              )
            );
          };
          "serverName" = mkOption {
            description = "Used to verify the hostname for the targets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "ca" = mkOverride 1002 null;
          "caFile" = mkOverride 1002 null;
          "cert" = mkOverride 1002 null;
          "certFile" = mkOverride 1002 null;
          "insecureSkipVerify" = mkOverride 1002 null;
          "keyFile" = mkOverride 1002 null;
          "keySecret" = mkOverride 1002 null;
          "serverName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCa" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCaConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCaSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCaSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCert" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCertConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCertSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsHttp_configTls_configKeySecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversDiscord_configsWebhook_url_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configs" = {

      options = {
        "auth_identity" = mkOption {
          description = "The identity to use for authentication.";
          type = (types.nullOr types.str);
        };
        "auth_password" = mkOption {
          description = "AuthPassword defines secret name and key at CRD namespace.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsAuth_password"
            )
          );
        };
        "auth_secret" = mkOption {
          description = "AuthSecret defines secret name and key at CRD namespace.\nIt must contain the CRAM-MD5 secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsAuth_secret"
            )
          );
        };
        "auth_username" = mkOption {
          description = "The username to use for authentication.";
          type = (types.nullOr types.str);
        };
        "from" = mkOption {
          description = "The sender address.\nfallback to global setting if empty";
          type = (types.nullOr types.str);
        };
        "headers" = mkOption {
          description = "Further headers email header key/value pairs. Overrides any headers\npreviously set by the notification implementation.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "hello" = mkOption {
          description = "The hostname to identify to the SMTP server.";
          type = (types.nullOr types.str);
        };
        "html" = mkOption {
          description = "The HTML body of the email notification.";
          type = (types.nullOr types.str);
        };
        "require_tls" = mkOption {
          description = "The SMTP TLS requirement.\nNote that Go does not support unencrypted connections to remote SMTP endpoints.";
          type = (types.nullOr types.bool);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "smarthost" = mkOption {
          description = "The SMTP host through which emails are sent.\nfallback to global setting if empty";
          type = (types.nullOr types.str);
        };
        "text" = mkOption {
          description = "The text body of the email notification.";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "TLS configuration";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_config"
            )
          );
        };
        "to" = mkOption {
          description = "The email address to send notifications to.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "auth_identity" = mkOverride 1002 null;
        "auth_password" = mkOverride 1002 null;
        "auth_secret" = mkOverride 1002 null;
        "auth_username" = mkOverride 1002 null;
        "from" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "hello" = mkOverride 1002 null;
        "html" = mkOverride 1002 null;
        "require_tls" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "smarthost" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
        "to" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsAuth_password" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsAuth_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_config" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCa" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCaConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCaSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCaSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCert" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCertConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCertSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversEmail_configsTls_configKeySecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversIncidentio_configs" = {

      options = {
        "alert_source_token" = mkOption {
          description = "AlertSourceToken is used to authenticate with incident.io";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversIncidentio_configsAlert_source_token"
            )
          );
        };
        "http_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
        "max_alerts" = mkOption {
          description = "MaxAlerts defines maximum number of alerts to be sent per incident.io message.";
          type = (types.nullOr types.int);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "timeout" = mkOption {
          description = "Timeout is the maximum time allowed to invoke incident.io";
          type = (types.nullOr types.str);
        };
        "url" = mkOption {
          description = "The URL to send the incident.io alert. This would typically be provided by the\nincident.io team when setting up an alert source.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "alert_source_token" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "max_alerts" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "url" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversIncidentio_configsAlert_source_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversJira_configs" = {

      options = {
        "api_url" = mkOption {
          description = "The URL to send API requests to. The full API path must be included.\nExample: https://company.atlassian.net/rest/api/2/";
          type = (types.nullOr types.str);
        };
        "custom_fields" = mkOption {
          description = "Other issue and custom fields.\nJira issue field can have multiple types.\nDepends on the field type, the values must be provided differently.\nSee https://developer.atlassian.com/server/jira/platform/jira-rest-api-examples/#setting-custom-field-data-for-other-field-types for further examples.";
          type = (types.nullOr types.attrs);
        };
        "description" = mkOption {
          description = "Issue description template.";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "The HTTP client's configuration. You must use this configuration to supply the personal access token (PAT) as part of the HTTP `Authorization` header.\nFor Jira Cloud, use basic_auth with the email address as the username and the PAT as the password.\nFor Jira Data Center, use the 'authorization' field with 'credentials: <PAT value>'.";
          type = (types.nullOr types.attrs);
        };
        "issue_type" = mkOption {
          description = "Type of the issue (e.g. Bug)";
          type = types.str;
        };
        "labels" = mkOption {
          description = "Labels to be added to the issue";
          type = (types.nullOr (types.listOf types.str));
        };
        "priority" = mkOption {
          description = "Priority of the issue";
          type = (types.nullOr types.str);
        };
        "project" = mkOption {
          description = "The project key where issues are created";
          type = types.str;
        };
        "reopen_duration" = mkOption {
          description = "If reopen_transition is defined, reopen the issue when it is not older than this value (rounded down to the nearest minute).\nThe resolutiondate field is used to determine the age of the issue.";
          type = (types.nullOr types.str);
        };
        "reopen_transition" = mkOption {
          description = "Name of the workflow transition to resolve an issue.\nThe target status must have the category \"done\".";
          type = (types.nullOr types.str);
        };
        "resolve_transition" = mkOption {
          description = "Name of the workflow transition to reopen an issue.\nThe target status should not have the category \"done\".";
          type = (types.nullOr types.str);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "summary" = mkOption {
          description = "Issue summary template";
          type = (types.nullOr types.str);
        };
        "wont_fix_resolution" = mkOption {
          description = "If reopen_transition is defined, ignore issues with that resolution.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "api_url" = mkOverride 1002 null;
        "custom_fields" = mkOverride 1002 null;
        "description" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "priority" = mkOverride 1002 null;
        "reopen_duration" = mkOverride 1002 null;
        "reopen_transition" = mkOverride 1002 null;
        "resolve_transition" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "summary" = mkOverride 1002 null;
        "wont_fix_resolution" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configs" = {

      options = {
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_config"
            )
          );
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "text" = mkOption {
          description = "The text body of the teams notification.";
          type = (types.nullOr types.str);
        };
        "title" = mkOption {
          description = "The title of the teams notification.";
          type = (types.nullOr types.str);
        };
        "webhook_url" = mkOption {
          description = "The incoming webhook URL\none of `urlSecret` and `url` must be defined.";
          type = (types.nullOr types.str);
        };
        "webhook_url_secret" = mkOption {
          description = "URLSecret defines secret name and key at the CRD namespace.\nIt must contain the webhook URL.\none of `urlSecret` and `url` must be defined.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsWebhook_url_secret"
            )
          );
        };
      };

      config = {
        "http_config" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
        "title" = mkOverride 1002 null;
        "webhook_url" = mkOverride 1002 null;
        "webhook_url_secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_config" =
      {

        options = {
          "authorization" = mkOption {
            description = "Authorization header configuration for the client.\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configAuthorization"
              )
            );
          };
          "basic_auth" = mkOption {
            description = "BasicAuth for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBasic_auth"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "BearerTokenFile defines filename for bearer token, it must be mounted to pod.";
            type = (types.nullOr types.str);
          };
          "bearer_token_secret" = mkOption {
            description = "The secret's key that contains the bearer token\nIt must be at them same namespace as CRD";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBearer_token_secret"
              )
            );
          };
          "oauth2" = mkOption {
            description = "OAuth2 client credentials used to fetch a token for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2"
              )
            );
          };
          "proxyURL" = mkOption {
            description = "Optional proxy URL.";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "TLS configuration for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_config"
              )
            );
          };
        };

        config = {
          "authorization" = mkOverride 1002 null;
          "basic_auth" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "bearer_token_secret" = mkOverride 1002 null;
          "oauth2" = mkOverride 1002 null;
          "proxyURL" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configAuthorization" =
      {

        options = {
          "credentials" = mkOption {
            description = "Reference to the secret with value for authorization";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configAuthorizationCredentials"
              )
            );
          };
          "credentialsFile" = mkOption {
            description = "File with value for authorization";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type of authorization, default to bearer";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "credentials" = mkOverride 1002 null;
          "credentialsFile" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configBearer_token_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2" =
      {

        options = {
          "client_id" = mkOption {
            description = "The secret or configmap containing the OAuth2 client id";
            type = (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_id"
            );
          };
          "client_secret" = mkOption {
            description = "The secret containing the OAuth2 client secret";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_secret"
              )
            );
          };
          "client_secret_file" = mkOption {
            description = "ClientSecretFile defines path for client secret file.";
            type = (types.nullOr types.str);
          };
          "endpoint_params" = mkOption {
            description = "Parameters to append to the token URL";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "proxy_url" = mkOption {
            description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.str);
          };
          "scopes" = mkOption {
            description = "OAuth2 scopes used for the token request";
            type = (types.nullOr (types.listOf types.str));
          };
          "tls_config" = mkOption {
            description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.attrs);
          };
          "token_url" = mkOption {
            description = "The URL to fetch the token from";
            type = types.str;
          };
        };

        config = {
          "client_secret" = mkOverride 1002 null;
          "client_secret_file" = mkOverride 1002 null;
          "endpoint_params" = mkOverride 1002 null;
          "proxy_url" = mkOverride 1002 null;
          "scopes" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_id" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_idConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_idSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configOauth2Client_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_config" =
      {

        options = {
          "ca" = mkOption {
            description = "Struct containing the CA cert to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCa"
              )
            );
          };
          "caFile" = mkOption {
            description = "Path to the CA cert in the container to use for the targets.";
            type = (types.nullOr types.str);
          };
          "cert" = mkOption {
            description = "Struct containing the client cert file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCert"
              )
            );
          };
          "certFile" = mkOption {
            description = "Path to the client cert file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "insecureSkipVerify" = mkOption {
            description = "Disable target certificate validation.";
            type = (types.nullOr types.bool);
          };
          "keyFile" = mkOption {
            description = "Path to the client key file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "keySecret" = mkOption {
            description = "Secret containing the client key file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configKeySecret"
              )
            );
          };
          "serverName" = mkOption {
            description = "Used to verify the hostname for the targets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "ca" = mkOverride 1002 null;
          "caFile" = mkOverride 1002 null;
          "cert" = mkOverride 1002 null;
          "certFile" = mkOverride 1002 null;
          "insecureSkipVerify" = mkOverride 1002 null;
          "keyFile" = mkOverride 1002 null;
          "keySecret" = mkOverride 1002 null;
          "serverName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCa" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCaConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCaSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCaSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCert" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCertConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCertSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsHttp_configTls_configKeySecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteams_configsWebhook_url_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteamsv2_configs" = {

      options = {
        "http_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "text" = mkOption {
          description = "Message body template.";
          type = (types.nullOr types.str);
        };
        "title" = mkOption {
          description = "Message title template.";
          type = (types.nullOr types.str);
        };
        "webhook_url" = mkOption {
          description = "The incoming webhook URL\none of `urlSecret` and `url` must be defined.";
          type = (types.nullOr types.str);
        };
        "webhook_url_secret" = mkOption {
          description = "URLSecret defines secret name and key at the CRD namespace.\nIt must contain the webhook URL.\none of `webhook_url` or `webhook_url_secret` must be defined.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteamsv2_configsWebhook_url_secret"
            )
          );
        };
      };

      config = {
        "http_config" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
        "title" = mkOverride 1002 null;
        "webhook_url" = mkOverride 1002 null;
        "webhook_url_secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversMsteamsv2_configsWebhook_url_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversOpsgenie_configs" = {

      options = {
        "actions" = mkOption {
          description = "Comma separated list of actions that will be available for the alert.";
          type = (types.nullOr types.str);
        };
        "apiURL" = mkOption {
          description = "The URL to send OpsGenie API requests to.";
          type = (types.nullOr types.str);
        };
        "api_key" = mkOption {
          description = "The secret's key that contains the OpsGenie API key.\nIt must be at them same namespace as CRD\nfallback to global setting if empty";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversOpsgenie_configsApi_key"
            )
          );
        };
        "description" = mkOption {
          description = "Description of the incident.";
          type = (types.nullOr types.str);
        };
        "details" = mkOption {
          description = "A set of arbitrary key/value pairs that provide further detail about the incident.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "entity" = mkOption {
          description = "Optional field that can be used to specify which domain alert is related to.";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (types.nullOr types.attrs);
        };
        "message" = mkOption {
          description = "Alert text limited to 130 characters.";
          type = (types.nullOr types.str);
        };
        "note" = mkOption {
          description = "Additional alert note.";
          type = (types.nullOr types.str);
        };
        "priority" = mkOption {
          description = "Priority level of alert. Possible values are P1, P2, P3, P4, and P5.";
          type = (types.nullOr types.str);
        };
        "responders" = mkOption {
          description = "List of responders responsible for notifications.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversOpsgenie_configsResponders"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "source" = mkOption {
          description = "Backlink to the sender of the notification.";
          type = (types.nullOr types.str);
        };
        "tags" = mkOption {
          description = "Comma separated list of tags attached to the notifications.";
          type = (types.nullOr types.str);
        };
        "update_alerts" = mkOption {
          description = "Whether to update message and description of the alert in OpsGenie if it already exists\nBy default, the alert is never updated in OpsGenie, the new message only appears in activity log.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "actions" = mkOverride 1002 null;
        "apiURL" = mkOverride 1002 null;
        "api_key" = mkOverride 1002 null;
        "description" = mkOverride 1002 null;
        "details" = mkOverride 1002 null;
        "entity" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "note" = mkOverride 1002 null;
        "priority" = mkOverride 1002 null;
        "responders" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "source" = mkOverride 1002 null;
        "tags" = mkOverride 1002 null;
        "update_alerts" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversOpsgenie_configsApi_key" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversOpsgenie_configsResponders" =
      {

        options = {
          "id" = mkOption {
            description = "ID of the responder.";
            type = (types.nullOr types.str);
          };
          "name" = mkOption {
            description = "Name of the responder.";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type of responder.";
            type = types.str;
          };
          "username" = mkOption {
            description = "Username of the responder.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "id" = mkOverride 1002 null;
          "name" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configs" = {

      options = {
        "class" = mkOption {
          description = "The class/type of the event.";
          type = (types.nullOr types.str);
        };
        "client" = mkOption {
          description = "Client identification.";
          type = (types.nullOr types.str);
        };
        "client_url" = mkOption {
          description = "Backlink to the sender of notification.";
          type = (types.nullOr types.str);
        };
        "component" = mkOption {
          description = "The part or component of the affected system that is broken.";
          type = (types.nullOr types.str);
        };
        "description" = mkOption {
          description = "Description of the incident.";
          type = (types.nullOr types.str);
        };
        "details" = mkOption {
          description = "Arbitrary key/value pairs that provide further detail about the incident.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "group" = mkOption {
          description = "A cluster or grouping of sources.";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (types.nullOr types.attrs);
        };
        "images" = mkOption {
          description = "Images to attach to the incident.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsImages"
              )
            )
          );
        };
        "links" = mkOption {
          description = "Links to attach to the incident.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsLinks"
              )
            )
          );
        };
        "routing_key" = mkOption {
          description = "The secret's key that contains the PagerDuty integration key (when using\nEvents API v2). Either this field or `serviceKey` needs to be defined.\nIt must be at them same namespace as CRD";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsRouting_key"
            )
          );
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "service_key" = mkOption {
          description = "The secret's key that contains the PagerDuty service key (when using\nintegration type \"Prometheus\"). Either this field or `routingKey` needs to\nbe defined.\nIt must be at them same namespace as CRD";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsService_key"
            )
          );
        };
        "severity" = mkOption {
          description = "Severity of the incident.";
          type = (types.nullOr types.str);
        };
        "url" = mkOption {
          description = "The URL to send requests to.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "class" = mkOverride 1002 null;
        "client" = mkOverride 1002 null;
        "client_url" = mkOverride 1002 null;
        "component" = mkOverride 1002 null;
        "description" = mkOverride 1002 null;
        "details" = mkOverride 1002 null;
        "group" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "images" = mkOverride 1002 null;
        "links" = mkOverride 1002 null;
        "routing_key" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "service_key" = mkOverride 1002 null;
        "severity" = mkOverride 1002 null;
        "url" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsImages" = {

      options = {
        "alt" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "href" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "source" = mkOption {
          description = "";
          type = types.str;
        };
      };

      config = {
        "alt" = mkOverride 1002 null;
        "href" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsLinks" = {

      options = {
        "href" = mkOption {
          description = "";
          type = types.str;
        };
        "text" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "text" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsRouting_key" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPagerduty_configsService_key" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPushover_configs" = {

      options = {
        "expire" = mkOption {
          description = "How long your notification will continue to be retried for, unless the user\nacknowledges the notification.";
          type = (types.nullOr types.str);
        };
        "html" = mkOption {
          description = "Whether notification message is HTML or plain text.";
          type = (types.nullOr types.bool);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (types.nullOr types.attrs);
        };
        "message" = mkOption {
          description = "Notification message.";
          type = (types.nullOr types.str);
        };
        "priority" = mkOption {
          description = "Priority, see https://pushover.net/api#priority";
          type = (types.nullOr types.str);
        };
        "retry" = mkOption {
          description = "How often the Pushover servers will send the same notification to the user.\nMust be at least 30 seconds.";
          type = (types.nullOr types.str);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "sound" = mkOption {
          description = "The name of one of the sounds supported by device clients to override the user's default sound choice";
          type = (types.nullOr types.str);
        };
        "title" = mkOption {
          description = "Notification title.";
          type = (types.nullOr types.str);
        };
        "token" = mkOption {
          description = "The secret's key that contains the registered applications API token, see https://pushover.net/apps.\nIt must be at them same namespace as CRD";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPushover_configsToken"
            )
          );
        };
        "url" = mkOption {
          description = "A supplementary URL shown alongside the message.";
          type = (types.nullOr types.str);
        };
        "url_title" = mkOption {
          description = "A title for supplementary URL, otherwise just the URL is shown";
          type = (types.nullOr types.str);
        };
        "user_key" = mkOption {
          description = "The secret's key that contains the recipient users user key.\nIt must be at them same namespace as CRD";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPushover_configsUser_key"
            )
          );
        };
      };

      config = {
        "expire" = mkOverride 1002 null;
        "html" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "priority" = mkOverride 1002 null;
        "retry" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "sound" = mkOverride 1002 null;
        "title" = mkOverride 1002 null;
        "token" = mkOverride 1002 null;
        "url" = mkOverride 1002 null;
        "url_title" = mkOverride 1002 null;
        "user_key" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPushover_configsToken" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversPushover_configsUser_key" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configs" = {

      options = {
        "actions" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsActions"
              )
            )
          );
        };
        "api_url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "channel" = mkOption {
          description = "RocketChat channel override, (like #other-channel or @username).";
          type = (types.nullOr types.str);
        };
        "color" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "emoji" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "fields" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsFields"
              )
            )
          );
        };
        "http_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
        "icon_url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "image_url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "link_names" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "short_fields" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "text" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "thumb_url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "title" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "title_link" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "token" = mkOption {
          description = "SecretKeySelector selects a key of a Secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsToken"
            )
          );
        };
        "token_id" = mkOption {
          description = "The sender token and token_id\nSee https://docs.rocket.chat/use-rocket.chat/user-guides/user-panel/my-account#personal-access-tokens";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsToken_id"
            )
          );
        };
      };

      config = {
        "actions" = mkOverride 1002 null;
        "api_url" = mkOverride 1002 null;
        "channel" = mkOverride 1002 null;
        "color" = mkOverride 1002 null;
        "emoji" = mkOverride 1002 null;
        "fields" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "icon_url" = mkOverride 1002 null;
        "image_url" = mkOverride 1002 null;
        "link_names" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "short_fields" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
        "thumb_url" = mkOverride 1002 null;
        "title" = mkOverride 1002 null;
        "title_link" = mkOverride 1002 null;
        "token" = mkOverride 1002 null;
        "token_id" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsActions" =
      {

        options = {
          "msg" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "url" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "msg" = mkOverride 1002 null;
          "text" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
          "url" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsFields" = {

      options = {
        "short" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "title" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "short" = mkOverride 1002 null;
        "title" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsToken" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversRocketchat_configsToken_id" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configs" = {

      options = {
        "actions" = mkOption {
          description = "A list of Slack actions that are sent with each notification.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsActions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "api_url" = mkOption {
          description = "The secret's key that contains the Slack webhook URL.\nIt must be at them same namespace as CRD\nfallback to global setting if empty";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsApi_url"
            )
          );
        };
        "callback_id" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "channel" = mkOption {
          description = "The channel or user to send notifications to.";
          type = (types.nullOr types.str);
        };
        "color" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "fallback" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "fields" = mkOption {
          description = "A list of Slack fields that are sent with each notification.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsFields"
              )
            )
          );
        };
        "footer" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (types.nullOr types.attrs);
        };
        "icon_emoji" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "icon_url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "image_url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "link_names" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "mrkdwn_in" = mkOption {
          description = "";
          type = (types.nullOr (types.listOf types.str));
        };
        "pretext" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "short_fields" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "text" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "thumb_url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "title" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "title_link" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "actions" = mkOverride 1002 null;
        "api_url" = mkOverride 1002 null;
        "callback_id" = mkOverride 1002 null;
        "channel" = mkOverride 1002 null;
        "color" = mkOverride 1002 null;
        "fallback" = mkOverride 1002 null;
        "fields" = mkOverride 1002 null;
        "footer" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "icon_emoji" = mkOverride 1002 null;
        "icon_url" = mkOverride 1002 null;
        "image_url" = mkOverride 1002 null;
        "link_names" = mkOverride 1002 null;
        "mrkdwn_in" = mkOverride 1002 null;
        "pretext" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "short_fields" = mkOverride 1002 null;
        "text" = mkOverride 1002 null;
        "thumb_url" = mkOverride 1002 null;
        "title" = mkOverride 1002 null;
        "title_link" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsActions" = {

      options = {
        "confirm" = mkOption {
          description = "SlackConfirmationField protect users from destructive actions or\nparticularly distinguished decisions by asking them to confirm their button\nclick one more time.\nSee https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields\nfor more information.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsActionsConfirm"
            )
          );
        };
        "name" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "style" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "text" = mkOption {
          description = "";
          type = types.str;
        };
        "type" = mkOption {
          description = "";
          type = types.str;
        };
        "url" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "confirm" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "style" = mkOverride 1002 null;
        "url" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsActionsConfirm" =
      {

        options = {
          "dismiss_text" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "ok_text" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "text" = mkOption {
            description = "";
            type = types.str;
          };
          "title" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "dismiss_text" = mkOverride 1002 null;
          "ok_text" = mkOverride 1002 null;
          "title" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsApi_url" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSlack_configsFields" = {

      options = {
        "short" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "title" = mkOption {
          description = "";
          type = types.str;
        };
        "value" = mkOption {
          description = "";
          type = types.str;
        };
      };

      config = {
        "short" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configs" = {

      options = {
        "api_url" = mkOption {
          description = "The api URL";
          type = (types.nullOr types.str);
        };
        "attributes" = mkOption {
          description = "SNS message attributes";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_config"
            )
          );
        };
        "message" = mkOption {
          description = "The message content of the SNS notification.";
          type = (types.nullOr types.str);
        };
        "phone_number" = mkOption {
          description = "Phone number if message is delivered via SMS\nSpecify this, topic_arn or target_arn";
          type = (types.nullOr types.str);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "sigv4" = mkOption {
          description = "Configure the AWS Signature Verification 4 signing process";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsSigv4"
            )
          );
        };
        "subject" = mkOption {
          description = "The subject line if message is delivered to an email endpoint.";
          type = (types.nullOr types.str);
        };
        "target_arn" = mkOption {
          description = "Mobile platform endpoint ARN if message is delivered via mobile notifications\nSpecify this, topic_arn or phone_number";
          type = (types.nullOr types.str);
        };
        "topic_arn" = mkOption {
          description = "SNS topic ARN, either specify this, phone_number or target_arn";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "api_url" = mkOverride 1002 null;
        "attributes" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "phone_number" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "sigv4" = mkOverride 1002 null;
        "subject" = mkOverride 1002 null;
        "target_arn" = mkOverride 1002 null;
        "topic_arn" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_config" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization header configuration for the client.\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configAuthorization"
            )
          );
        };
        "basic_auth" = mkOption {
          description = "BasicAuth for the client.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBasic_auth"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "BearerTokenFile defines filename for bearer token, it must be mounted to pod.";
          type = (types.nullOr types.str);
        };
        "bearer_token_secret" = mkOption {
          description = "The secret's key that contains the bearer token\nIt must be at them same namespace as CRD";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBearer_token_secret"
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 client credentials used to fetch a token for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2"
            )
          );
        };
        "proxyURL" = mkOption {
          description = "Optional proxy URL.";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "TLS configuration for the client.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_config"
            )
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "basic_auth" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "bearer_token_secret" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configAuthorization" =
      {

        options = {
          "credentials" = mkOption {
            description = "Reference to the secret with value for authorization";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configAuthorizationCredentials"
              )
            );
          };
          "credentialsFile" = mkOption {
            description = "File with value for authorization";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type of authorization, default to bearer";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "credentials" = mkOverride 1002 null;
          "credentialsFile" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configBearer_token_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2" =
      {

        options = {
          "client_id" = mkOption {
            description = "The secret or configmap containing the OAuth2 client id";
            type = (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_id"
            );
          };
          "client_secret" = mkOption {
            description = "The secret containing the OAuth2 client secret";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_secret"
              )
            );
          };
          "client_secret_file" = mkOption {
            description = "ClientSecretFile defines path for client secret file.";
            type = (types.nullOr types.str);
          };
          "endpoint_params" = mkOption {
            description = "Parameters to append to the token URL";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "proxy_url" = mkOption {
            description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.str);
          };
          "scopes" = mkOption {
            description = "OAuth2 scopes used for the token request";
            type = (types.nullOr (types.listOf types.str));
          };
          "tls_config" = mkOption {
            description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.attrs);
          };
          "token_url" = mkOption {
            description = "The URL to fetch the token from";
            type = types.str;
          };
        };

        config = {
          "client_secret" = mkOverride 1002 null;
          "client_secret_file" = mkOverride 1002 null;
          "endpoint_params" = mkOverride 1002 null;
          "proxy_url" = mkOverride 1002 null;
          "scopes" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_id" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_idConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_idSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configOauth2Client_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_config" =
      {

        options = {
          "ca" = mkOption {
            description = "Struct containing the CA cert to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCa"
              )
            );
          };
          "caFile" = mkOption {
            description = "Path to the CA cert in the container to use for the targets.";
            type = (types.nullOr types.str);
          };
          "cert" = mkOption {
            description = "Struct containing the client cert file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCert"
              )
            );
          };
          "certFile" = mkOption {
            description = "Path to the client cert file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "insecureSkipVerify" = mkOption {
            description = "Disable target certificate validation.";
            type = (types.nullOr types.bool);
          };
          "keyFile" = mkOption {
            description = "Path to the client key file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "keySecret" = mkOption {
            description = "Secret containing the client key file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configKeySecret"
              )
            );
          };
          "serverName" = mkOption {
            description = "Used to verify the hostname for the targets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "ca" = mkOverride 1002 null;
          "caFile" = mkOverride 1002 null;
          "cert" = mkOverride 1002 null;
          "certFile" = mkOverride 1002 null;
          "insecureSkipVerify" = mkOverride 1002 null;
          "keyFile" = mkOverride 1002 null;
          "keySecret" = mkOverride 1002 null;
          "serverName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCa" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCaConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCaSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCaSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCert" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCertConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCertSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsHttp_configTls_configKeySecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsSigv4" = {

      options = {
        "access_key" = mkOption {
          description = "The AWS API keys. Both access_key and secret_key must be supplied or both must be blank.\nIf blank the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are used.";
          type = (types.nullOr types.str);
        };
        "access_key_selector" = mkOption {
          description = "secret key selector to get the keys from a Kubernetes Secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsSigv4Access_key_selector"
            )
          );
        };
        "profile" = mkOption {
          description = "Named AWS profile used to authenticate";
          type = (types.nullOr types.str);
        };
        "region" = mkOption {
          description = "AWS region, if blank the region from the default credentials chain is used";
          type = (types.nullOr types.str);
        };
        "role_arn" = mkOption {
          description = "AWS Role ARN, an alternative to using AWS API keys";
          type = (types.nullOr types.str);
        };
        "secret_key_selector" = mkOption {
          description = "secret key selector to get the keys from a Kubernetes Secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsSigv4Secret_key_selector"
            )
          );
        };
      };

      config = {
        "access_key" = mkOverride 1002 null;
        "access_key_selector" = mkOverride 1002 null;
        "profile" = mkOverride 1002 null;
        "region" = mkOverride 1002 null;
        "role_arn" = mkOverride 1002 null;
        "secret_key_selector" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsSigv4Access_key_selector" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversSns_configsSigv4Secret_key_selector" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversTelegram_configs" = {

      options = {
        "api_url" = mkOption {
          description = "APIUrl the Telegram API URL i.e. https://api.telegram.org.";
          type = (types.nullOr types.str);
        };
        "bot_token" = mkOption {
          description = "BotToken token for the bot\nhttps://core.telegram.org/bots/api";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversTelegram_configsBot_token"
          );
        };
        "chat_id" = mkOption {
          description = "ChatID is ID of the chat where to send the messages.";
          type = types.int;
        };
        "disable_notifications" = mkOption {
          description = "DisableNotifications";
          type = (types.nullOr types.bool);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (types.nullOr types.attrs);
        };
        "message" = mkOption {
          description = "Message is templated message";
          type = (types.nullOr types.str);
        };
        "message_thread_id" = mkOption {
          description = "MessageThreadID defines ID of the message thread where to send the messages.";
          type = (types.nullOr types.int);
        };
        "parse_mode" = mkOption {
          description = "ParseMode for telegram message,\nsupported values are MarkdownV2, Markdown, Markdown and empty string for plain text.";
          type = (types.nullOr types.str);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "api_url" = mkOverride 1002 null;
        "disable_notifications" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "message_thread_id" = mkOverride 1002 null;
        "parse_mode" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversTelegram_configsBot_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configs" = {

      options = {
        "api_key" = mkOption {
          description = "The secret's key that contains the API key to use when talking to the VictorOps API.\nIt must be at them same namespace as CRD\nfallback to global setting if empty";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsApi_key"
            )
          );
        };
        "api_url" = mkOption {
          description = "The VictorOps API URL.";
          type = (types.nullOr types.str);
        };
        "custom_fields" = mkOption {
          description = "Adds optional custom fields\nhttps://github.com/prometheus/alertmanager/blob/v0.24.0/config/notifiers.go#L537";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "entity_display_name" = mkOption {
          description = "Contains summary of the alerted problem.";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "The HTTP client's configuration.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_config"
            )
          );
        };
        "message_type" = mkOption {
          description = "Describes the behavior of the alert (CRITICAL, WARNING, INFO).";
          type = (types.nullOr types.str);
        };
        "monitoring_tool" = mkOption {
          description = "The monitoring tool the state message is from.";
          type = (types.nullOr types.str);
        };
        "routing_key" = mkOption {
          description = "A key used to map the alert to a team.";
          type = types.str;
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "state_message" = mkOption {
          description = "Contains long explanation of the alerted problem.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "api_key" = mkOverride 1002 null;
        "api_url" = mkOverride 1002 null;
        "custom_fields" = mkOverride 1002 null;
        "entity_display_name" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message_type" = mkOverride 1002 null;
        "monitoring_tool" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "state_message" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsApi_key" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_config" =
      {

        options = {
          "authorization" = mkOption {
            description = "Authorization header configuration for the client.\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configAuthorization"
              )
            );
          };
          "basic_auth" = mkOption {
            description = "BasicAuth for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBasic_auth"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "BearerTokenFile defines filename for bearer token, it must be mounted to pod.";
            type = (types.nullOr types.str);
          };
          "bearer_token_secret" = mkOption {
            description = "The secret's key that contains the bearer token\nIt must be at them same namespace as CRD";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBearer_token_secret"
              )
            );
          };
          "oauth2" = mkOption {
            description = "OAuth2 client credentials used to fetch a token for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2"
              )
            );
          };
          "proxyURL" = mkOption {
            description = "Optional proxy URL.";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "TLS configuration for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_config"
              )
            );
          };
        };

        config = {
          "authorization" = mkOverride 1002 null;
          "basic_auth" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "bearer_token_secret" = mkOverride 1002 null;
          "oauth2" = mkOverride 1002 null;
          "proxyURL" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configAuthorization" =
      {

        options = {
          "credentials" = mkOption {
            description = "Reference to the secret with value for authorization";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configAuthorizationCredentials"
              )
            );
          };
          "credentialsFile" = mkOption {
            description = "File with value for authorization";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type of authorization, default to bearer";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "credentials" = mkOverride 1002 null;
          "credentialsFile" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configBearer_token_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2" =
      {

        options = {
          "client_id" = mkOption {
            description = "The secret or configmap containing the OAuth2 client id";
            type = (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_id"
            );
          };
          "client_secret" = mkOption {
            description = "The secret containing the OAuth2 client secret";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_secret"
              )
            );
          };
          "client_secret_file" = mkOption {
            description = "ClientSecretFile defines path for client secret file.";
            type = (types.nullOr types.str);
          };
          "endpoint_params" = mkOption {
            description = "Parameters to append to the token URL";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "proxy_url" = mkOption {
            description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.str);
          };
          "scopes" = mkOption {
            description = "OAuth2 scopes used for the token request";
            type = (types.nullOr (types.listOf types.str));
          };
          "tls_config" = mkOption {
            description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.attrs);
          };
          "token_url" = mkOption {
            description = "The URL to fetch the token from";
            type = types.str;
          };
        };

        config = {
          "client_secret" = mkOverride 1002 null;
          "client_secret_file" = mkOverride 1002 null;
          "endpoint_params" = mkOverride 1002 null;
          "proxy_url" = mkOverride 1002 null;
          "scopes" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_id" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_idConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_idSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configOauth2Client_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_config" =
      {

        options = {
          "ca" = mkOption {
            description = "Struct containing the CA cert to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCa"
              )
            );
          };
          "caFile" = mkOption {
            description = "Path to the CA cert in the container to use for the targets.";
            type = (types.nullOr types.str);
          };
          "cert" = mkOption {
            description = "Struct containing the client cert file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCert"
              )
            );
          };
          "certFile" = mkOption {
            description = "Path to the client cert file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "insecureSkipVerify" = mkOption {
            description = "Disable target certificate validation.";
            type = (types.nullOr types.bool);
          };
          "keyFile" = mkOption {
            description = "Path to the client key file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "keySecret" = mkOption {
            description = "Secret containing the client key file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configKeySecret"
              )
            );
          };
          "serverName" = mkOption {
            description = "Used to verify the hostname for the targets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "ca" = mkOverride 1002 null;
          "caFile" = mkOverride 1002 null;
          "cert" = mkOverride 1002 null;
          "certFile" = mkOverride 1002 null;
          "insecureSkipVerify" = mkOverride 1002 null;
          "keyFile" = mkOverride 1002 null;
          "keySecret" = mkOverride 1002 null;
          "serverName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCa" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCaConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCaSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCaSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCert" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCertConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCertSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversVictorops_configsHttp_configTls_configKeySecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configs" = {

      options = {
        "api_url" = mkOption {
          description = "The Webex Teams API URL, i.e. https://webexapis.com/v1/messages";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration. You must use this configuration to supply the bot token as part of the HTTP `Authorization` header.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_config"
            )
          );
        };
        "message" = mkOption {
          description = "The message body template";
          type = (types.nullOr types.str);
        };
        "room_id" = mkOption {
          description = "The ID of the Webex Teams room where to send the messages";
          type = types.str;
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "api_url" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_config" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization header configuration for the client.\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configAuthorization"
            )
          );
        };
        "basic_auth" = mkOption {
          description = "BasicAuth for the client.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBasic_auth"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "BearerTokenFile defines filename for bearer token, it must be mounted to pod.";
          type = (types.nullOr types.str);
        };
        "bearer_token_secret" = mkOption {
          description = "The secret's key that contains the bearer token\nIt must be at them same namespace as CRD";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBearer_token_secret"
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 client credentials used to fetch a token for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2"
            )
          );
        };
        "proxyURL" = mkOption {
          description = "Optional proxy URL.";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "TLS configuration for the client.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_config"
            )
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "basic_auth" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "bearer_token_secret" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configAuthorization" =
      {

        options = {
          "credentials" = mkOption {
            description = "Reference to the secret with value for authorization";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configAuthorizationCredentials"
              )
            );
          };
          "credentialsFile" = mkOption {
            description = "File with value for authorization";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type of authorization, default to bearer";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "credentials" = mkOverride 1002 null;
          "credentialsFile" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configBearer_token_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2" =
      {

        options = {
          "client_id" = mkOption {
            description = "The secret or configmap containing the OAuth2 client id";
            type = (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_id"
            );
          };
          "client_secret" = mkOption {
            description = "The secret containing the OAuth2 client secret";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_secret"
              )
            );
          };
          "client_secret_file" = mkOption {
            description = "ClientSecretFile defines path for client secret file.";
            type = (types.nullOr types.str);
          };
          "endpoint_params" = mkOption {
            description = "Parameters to append to the token URL";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "proxy_url" = mkOption {
            description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.str);
          };
          "scopes" = mkOption {
            description = "OAuth2 scopes used for the token request";
            type = (types.nullOr (types.listOf types.str));
          };
          "tls_config" = mkOption {
            description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.attrs);
          };
          "token_url" = mkOption {
            description = "The URL to fetch the token from";
            type = types.str;
          };
        };

        config = {
          "client_secret" = mkOverride 1002 null;
          "client_secret_file" = mkOverride 1002 null;
          "endpoint_params" = mkOverride 1002 null;
          "proxy_url" = mkOverride 1002 null;
          "scopes" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_id" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_idConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_idSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configOauth2Client_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_config" =
      {

        options = {
          "ca" = mkOption {
            description = "Struct containing the CA cert to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCa"
              )
            );
          };
          "caFile" = mkOption {
            description = "Path to the CA cert in the container to use for the targets.";
            type = (types.nullOr types.str);
          };
          "cert" = mkOption {
            description = "Struct containing the client cert file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCert"
              )
            );
          };
          "certFile" = mkOption {
            description = "Path to the client cert file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "insecureSkipVerify" = mkOption {
            description = "Disable target certificate validation.";
            type = (types.nullOr types.bool);
          };
          "keyFile" = mkOption {
            description = "Path to the client key file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "keySecret" = mkOption {
            description = "Secret containing the client key file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configKeySecret"
              )
            );
          };
          "serverName" = mkOption {
            description = "Used to verify the hostname for the targets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "ca" = mkOverride 1002 null;
          "caFile" = mkOverride 1002 null;
          "cert" = mkOverride 1002 null;
          "certFile" = mkOverride 1002 null;
          "insecureSkipVerify" = mkOverride 1002 null;
          "keyFile" = mkOverride 1002 null;
          "keySecret" = mkOverride 1002 null;
          "serverName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCa" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCaConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCaSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCaSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCert" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCertConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCertSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebex_configsHttp_configTls_configKeySecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebhook_configs" = {

      options = {
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (types.nullOr types.attrs);
        };
        "max_alerts" = mkOption {
          description = "Maximum number of alerts to be sent per webhook message. When 0, all alerts are included.";
          type = (types.nullOr types.int);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "timeout" = mkOption {
          description = "Timeout is the maximum time allowed to invoke the webhook\navailable since v0.28.0 alertmanager version";
          type = (types.nullOr types.str);
        };
        "url" = mkOption {
          description = "URL to send requests to,\none of `urlSecret` and `url` must be defined.";
          type = (types.nullOr types.str);
        };
        "url_secret" = mkOption {
          description = "URLSecret defines secret name and key at the CRD namespace.\nIt must contain the webhook URL.\none of `urlSecret` and `url` must be defined.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebhook_configsUrl_secret"
            )
          );
        };
      };

      config = {
        "http_config" = mkOverride 1002 null;
        "max_alerts" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "timeout" = mkOverride 1002 null;
        "url" = mkOverride 1002 null;
        "url_secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWebhook_configsUrl_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configs" = {

      options = {
        "agent_id" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "api_secret" = mkOption {
          description = "The secret's key that contains the WeChat API key.\nThe secret needs to be in the same namespace as the AlertmanagerConfig\nfallback to global alertmanager setting if empty";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsApi_secret"
            )
          );
        };
        "api_url" = mkOption {
          description = "The WeChat API URL.\nfallback to global alertmanager setting if empty";
          type = (types.nullOr types.str);
        };
        "corp_id" = mkOption {
          description = "The corp id for authentication.\nfallback to global alertmanager setting if empty";
          type = (types.nullOr types.str);
        };
        "http_config" = mkOption {
          description = "HTTP client configuration.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_config"
            )
          );
        };
        "message" = mkOption {
          description = "API request data as defined by the WeChat API.";
          type = (types.nullOr types.str);
        };
        "message_type" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "send_resolved" = mkOption {
          description = "SendResolved controls notify about resolved alerts.";
          type = (types.nullOr types.bool);
        };
        "to_party" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "to_tag" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "to_user" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "agent_id" = mkOverride 1002 null;
        "api_secret" = mkOverride 1002 null;
        "api_url" = mkOverride 1002 null;
        "corp_id" = mkOverride 1002 null;
        "http_config" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "message_type" = mkOverride 1002 null;
        "send_resolved" = mkOverride 1002 null;
        "to_party" = mkOverride 1002 null;
        "to_tag" = mkOverride 1002 null;
        "to_user" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsApi_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_config" =
      {

        options = {
          "authorization" = mkOption {
            description = "Authorization header configuration for the client.\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configAuthorization"
              )
            );
          };
          "basic_auth" = mkOption {
            description = "BasicAuth for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBasic_auth"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "BearerTokenFile defines filename for bearer token, it must be mounted to pod.";
            type = (types.nullOr types.str);
          };
          "bearer_token_secret" = mkOption {
            description = "The secret's key that contains the bearer token\nIt must be at them same namespace as CRD";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBearer_token_secret"
              )
            );
          };
          "oauth2" = mkOption {
            description = "OAuth2 client credentials used to fetch a token for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2"
              )
            );
          };
          "proxyURL" = mkOption {
            description = "Optional proxy URL.";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "TLS configuration for the client.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_config"
              )
            );
          };
        };

        config = {
          "authorization" = mkOverride 1002 null;
          "basic_auth" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "bearer_token_secret" = mkOverride 1002 null;
          "oauth2" = mkOverride 1002 null;
          "proxyURL" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configAuthorization" =
      {

        options = {
          "credentials" = mkOption {
            description = "Reference to the secret with value for authorization";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configAuthorizationCredentials"
              )
            );
          };
          "credentialsFile" = mkOption {
            description = "File with value for authorization";
            type = (types.nullOr types.str);
          };
          "type" = mkOption {
            description = "Type of authorization, default to bearer";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "credentials" = mkOverride 1002 null;
          "credentialsFile" = mkOverride 1002 null;
          "type" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configBearer_token_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2" =
      {

        options = {
          "client_id" = mkOption {
            description = "The secret or configmap containing the OAuth2 client id";
            type = (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_id"
            );
          };
          "client_secret" = mkOption {
            description = "The secret containing the OAuth2 client secret";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_secret"
              )
            );
          };
          "client_secret_file" = mkOption {
            description = "ClientSecretFile defines path for client secret file.";
            type = (types.nullOr types.str);
          };
          "endpoint_params" = mkOption {
            description = "Parameters to append to the token URL";
            type = (types.nullOr (types.attrsOf types.str));
          };
          "proxy_url" = mkOption {
            description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.str);
          };
          "scopes" = mkOption {
            description = "OAuth2 scopes used for the token request";
            type = (types.nullOr (types.listOf types.str));
          };
          "tls_config" = mkOption {
            description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
            type = (types.nullOr types.attrs);
          };
          "token_url" = mkOption {
            description = "The URL to fetch the token from";
            type = types.str;
          };
        };

        config = {
          "client_secret" = mkOverride 1002 null;
          "client_secret_file" = mkOverride 1002 null;
          "endpoint_params" = mkOverride 1002 null;
          "proxy_url" = mkOverride 1002 null;
          "scopes" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_id" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_idConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_idSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configOauth2Client_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_config" =
      {

        options = {
          "ca" = mkOption {
            description = "Struct containing the CA cert to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCa"
              )
            );
          };
          "caFile" = mkOption {
            description = "Path to the CA cert in the container to use for the targets.";
            type = (types.nullOr types.str);
          };
          "cert" = mkOption {
            description = "Struct containing the client cert file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCert"
              )
            );
          };
          "certFile" = mkOption {
            description = "Path to the client cert file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "insecureSkipVerify" = mkOption {
            description = "Disable target certificate validation.";
            type = (types.nullOr types.bool);
          };
          "keyFile" = mkOption {
            description = "Path to the client key file in the container for the targets.";
            type = (types.nullOr types.str);
          };
          "keySecret" = mkOption {
            description = "Secret containing the client key file for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configKeySecret"
              )
            );
          };
          "serverName" = mkOption {
            description = "Used to verify the hostname for the targets.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "ca" = mkOverride 1002 null;
          "caFile" = mkOverride 1002 null;
          "cert" = mkOverride 1002 null;
          "certFile" = mkOverride 1002 null;
          "insecureSkipVerify" = mkOverride 1002 null;
          "keyFile" = mkOverride 1002 null;
          "keySecret" = mkOverride 1002 null;
          "serverName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCa" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCaConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCaSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCaSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCert" =
      {

        options = {
          "configMap" = mkOption {
            description = "ConfigMap containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCertConfigMap"
              )
            );
          };
          "secret" = mkOption {
            description = "Secret containing data to use for the targets.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCertSecret"
              )
            );
          };
        };

        config = {
          "configMap" = mkOverride 1002 null;
          "secret" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecReceiversWechat_configsHttp_configTls_configKeySecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecRoute" = {

      options = {
        "active_time_intervals" = mkOption {
          description = "ActiveTimeIntervals Times when the route should be active\nThese must match the name at time_intervals";
          type = (types.nullOr (types.listOf types.str));
        };
        "continue" = mkOption {
          description = "Continue indicating whether an alert should continue matching subsequent\nsibling nodes. It will always be true for the first-level route if disableRouteContinueEnforce for vmalertmanager not set.";
          type = (types.nullOr types.bool);
        };
        "group_by" = mkOption {
          description = "List of labels to group by.";
          type = (types.nullOr (types.listOf types.str));
        };
        "group_interval" = mkOption {
          description = "How long to wait before sending an updated notification.";
          type = (types.nullOr types.str);
        };
        "group_wait" = mkOption {
          description = "How long to wait before sending the initial notification.";
          type = (types.nullOr types.str);
        };
        "matchers" = mkOption {
          description = "List of matchers that the alerts labels should match. For the first\nlevel route, the operator adds a namespace: \"CRD_NS\" matcher.\nhttps://prometheus.io/docs/alerting/latest/configuration/#matcher";
          type = (types.nullOr (types.listOf types.str));
        };
        "mute_time_intervals" = mkOption {
          description = "MuteTimeIntervals is a list of interval names that will mute matched alert";
          type = (types.nullOr (types.listOf types.str));
        };
        "receiver" = mkOption {
          description = "Name of the receiver for this route.";
          type = types.str;
        };
        "repeat_interval" = mkOption {
          description = "How long to wait before repeating the last notification.";
          type = (types.nullOr types.str);
        };
        "routes" = mkOption {
          description = "Child routes.\nhttps://prometheus.io/docs/alerting/latest/configuration/#route";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "active_time_intervals" = mkOverride 1002 null;
        "continue" = mkOverride 1002 null;
        "group_by" = mkOverride 1002 null;
        "group_interval" = mkOverride 1002 null;
        "group_wait" = mkOverride 1002 null;
        "matchers" = mkOverride 1002 null;
        "mute_time_intervals" = mkOverride 1002 null;
        "repeat_interval" = mkOverride 1002 null;
        "routes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecTime_intervals" = {

      options = {
        "name" = mkOption {
          description = "Name of interval";
          type = types.str;
        };
        "time_intervals" = mkOption {
          description = "TimeIntervals interval configuration";
          type = (
            types.listOf (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecTime_intervalsTime_intervals"
            )
          );
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecTime_intervalsTime_intervals" = {

      options = {
        "days_of_month" = mkOption {
          description = "DayOfMonth defines list of numerical days in the month. Days begin at 1. Negative values are also accepted.\nfor example, ['1:5', '-3:-1']";
          type = (types.nullOr (types.listOf types.str));
        };
        "location" = mkOption {
          description = "Location in golang time location form, e.g. UTC";
          type = (types.nullOr types.str);
        };
        "months" = mkOption {
          description = "Months  defines list of calendar months identified by a case-insensitive name (e.g. January) or numeric 1.\nFor example, ['1:3', 'may:august', 'december']";
          type = (types.nullOr (types.listOf types.str));
        };
        "times" = mkOption {
          description = "Times defines time range for mute";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecTime_intervalsTime_intervalsTimes"
              )
            )
          );
        };
        "weekdays" = mkOption {
          description = "Weekdays defines list of days of the week, where the week begins on Sunday and ends on Saturday.";
          type = (types.nullOr (types.listOf types.str));
        };
        "years" = mkOption {
          description = "Years defines numerical list of years, ranges are accepted.\nFor example, ['2020:2022', '2030']";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "days_of_month" = mkOverride 1002 null;
        "location" = mkOverride 1002 null;
        "months" = mkOverride 1002 null;
        "times" = mkOverride 1002 null;
        "weekdays" = mkOverride 1002 null;
        "years" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigSpecTime_intervalsTime_intervalsTimes" = {

      options = {
        "end_time" = mkOption {
          description = "EndTime for example HH:MM";
          type = types.str;
        };
        "start_time" = mkOption {
          description = "StartTime for example  HH:MM";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigStatusConditions"
              )
            )
          );
        };
        "lastErrorParentAlertmanagerName" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "lastErrorParentAlertmanagerName" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfigStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpec" = {

      options = {
        "additionalPeers" = mkOption {
          description = "AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.";
          type = (types.nullOr (types.listOf types.str));
        };
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplates")
            )
          );
        };
        "clusterAdvertiseAddress" = mkOption {
          description = "ClusterAdvertiseAddress is the explicit address to advertise in cluster.\nNeeds to be provided for non RFC1918 [1] (public) addresses.\n[1] RFC1918: https://tools.ietf.org/html/rfc1918";
          type = (types.nullOr types.str);
        };
        "clusterDomainName" = mkOption {
          description = "ClusterDomainName defines domain name suffix for in-cluster dns addresses\naka .cluster.local\nused to build pod peer addresses for in-cluster communication";
          type = (types.nullOr types.str);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "configNamespaceSelector" = mkOption {
          description = " ConfigNamespaceSelector defines namespace selector for VMAlertmanagerConfig.\nWorks in combination with Selector.\nNamespaceSelector nil - only objects at VMAlertmanager namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigNamespaceSelector"
            )
          );
        };
        "configRawYaml" = mkOption {
          description = "ConfigRawYaml - raw configuration for alertmanager,\nit helps it to start without secret.\npriority -> hardcoded ConfigRaw -> ConfigRaw, provided by user -> ConfigSecret.";
          type = (types.nullOr types.str);
        };
        "configReloadAuthKeySecret" = mkOption {
          description = "ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.\nGiven secret reference will be added to the application and vm-config-reloader as volume\navailable since v0.57.0 version";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigReloadAuthKeySecret"
            )
          );
        };
        "configReloaderExtraArgs" = mkOption {
          description = "ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container\nfor example resyncInterval: \"30s\"";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "configReloaderImageTag" = mkOption {
          description = "ConfigReloaderImageTag defines image:tag for config-reloader container";
          type = (types.nullOr types.str);
        };
        "configReloaderResources" = mkOption {
          description = "ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigReloaderResources"
            )
          );
        };
        "configSecret" = mkOption {
          description = "ConfigSecret is the name of a Kubernetes Secret in the same namespace as the\nVMAlertmanager object, which contains configuration for this VMAlertmanager,\nconfiguration must be inside secret key: alertmanager.yaml.\nIt must be created by user.\ninstance. Defaults to 'vmalertmanager-<alertmanager-name>'\nThe secret is mounted into /etc/alertmanager/config.";
          type = (types.nullOr types.str);
        };
        "configSelector" = mkOption {
          description = "ConfigSelector defines selector for VMAlertmanagerConfig, result config will be merged with with Raw or Secret config.\nWorks in combination with NamespaceSelector.\nNamespaceSelector nil - only objects at VMAlertmanager namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigSelector")
          );
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableNamespaceMatcher" = mkOption {
          description = "DisableNamespaceMatcher disables adding top route label matcher \"namespace = <VMAlertmanagerConfig.namespace>\" for VMAlertmanagerConfig\nIt may be useful if alert doesn't have namespace label for some reason";
          type = (types.nullOr types.bool);
        };
        "disableRouteContinueEnforce" = mkOption {
          description = "DisableRouteContinueEnforce cancel the behavior for VMAlertmanagerConfig that always enforce first-level route continue to true";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecDnsConfig")
          );
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "enforcedNamespaceLabel" = mkOption {
          description = "EnforcedNamespaceLabel defines the namespace label key for top route matcher for VMAlertmanagerConfig\nDefault is \"namespace\"";
          type = (types.nullOr types.str);
        };
        "enforcedTopRouteMatchers" = mkOption {
          description = "EnforcedTopRouteMatchers defines label matchers to be added for the top route\nof VMAlertmanagerConfig\nIt allows to make some set of labels required for alerts.\nhttps://prometheus.io/docs/alerting/latest/configuration/#matcher";
          type = (types.nullOr (types.listOf types.str));
        };
        "externalURL" = mkOption {
          description = "ExternalURL the VMAlertmanager instances will be available under. This is\nnecessary to generate correct URLs. This is necessary if VMAlertmanager is not\nserved from root of a DNS name.";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvsFrom")
            )
          );
        };
        "gossipConfig" = mkOption {
          description = "GossipConfig defines gossip TLS configuration for Alertmanager cluster";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfig")
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecHost_aliases")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "listenLocal" = mkOption {
          description = "ListenLocal makes the VMAlertmanager server listen on loopback, so that it\ndoes not bind against the Pod IP. Note this is only for the VMAlertmanager\nUI, not the gossip communication.";
          type = (types.nullOr types.bool);
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMAlertmanager to be configured with.";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "Log level for VMAlertmanager to be configured with.";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecManagedMetadata")
          );
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecPersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecPodDisruptionBudget"
            )
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecPodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "portName" = mkOption {
          description = "PortName used for the pods and governing service.\nThis defaults to web";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecResources")
          );
        };
        "retention" = mkOption {
          description = "Retention Time duration VMAlertmanager shall retain data for. Default is '120h',\nand must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).";
          type = (types.nullOr types.str);
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdateStrategy" = mkOption {
          description = "RollingUpdateStrategy defines strategy for application updates\nDefault is OnDelete, in this case operator handles update process\nCan be changed for RollingUpdate";
          type = (types.nullOr types.str);
        };
        "routePrefix" = mkOption {
          description = "RoutePrefix VMAlertmanager registers HTTP handlers for. This is useful,\nif using ExternalURL and a proxy is rewriting HTTP routes of a request,\nand the actual ExternalURL is still true, but the server serves requests\nunder a different route prefix. For example for use with `kubectl proxy`.";
          type = (types.nullOr types.str);
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "selectAllByDefault" = mkOption {
          description = "SelectAllByDefault changes default behavior for empty CRD selectors, such ConfigSelector.\nwith selectAllByDefault: true and undefined ConfigSelector and ConfigNamespaceSelector\nOperator selects all exist alertManagerConfigs\nwith selectAllByDefault: false - selects nothing";
          type = (types.nullOr types.bool);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmalertmanager VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vmalertmanager service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage is the definition of how storage will be used by the VMAlertmanager\ninstances.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorage")
          );
        };
        "templates" = mkOption {
          description = "Templates is a list of ConfigMap key references for ConfigMaps in the same namespace as the VMAlertmanager\nobject, which shall be mounted into the VMAlertmanager Pods.\nThe Templates are mounted into /etc/vm/templates/<configmap-name>/<configmap-key>.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecTemplates"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "useVMConfigReloader" = mkOption {
          description = "UseVMConfigReloader replaces prometheus-like config-reloader\nwith vm one. It uses secrets watch instead of file watch\nwhich greatly increases speed of config updates";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "webConfig" = mkOption {
          description = "WebConfig defines configuration for webserver\nhttps://github.com/prometheus/alertmanager/blob/main/docs/https.md";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfig")
          );
        };
      };

      config = {
        "additionalPeers" = mkOverride 1002 null;
        "affinity" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "clusterAdvertiseAddress" = mkOverride 1002 null;
        "clusterDomainName" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "configNamespaceSelector" = mkOverride 1002 null;
        "configRawYaml" = mkOverride 1002 null;
        "configReloadAuthKeySecret" = mkOverride 1002 null;
        "configReloaderExtraArgs" = mkOverride 1002 null;
        "configReloaderImageTag" = mkOverride 1002 null;
        "configReloaderResources" = mkOverride 1002 null;
        "configSecret" = mkOverride 1002 null;
        "configSelector" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableNamespaceMatcher" = mkOverride 1002 null;
        "disableRouteContinueEnforce" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "enforcedNamespaceLabel" = mkOverride 1002 null;
        "enforcedTopRouteMatchers" = mkOverride 1002 null;
        "externalURL" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "gossipConfig" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "listenLocal" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "portName" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "retention" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdateStrategy" = mkOverride 1002 null;
        "routePrefix" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "selectAllByDefault" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "templates" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "useVMConfigReloader" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
        "webConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplates" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr types.attrs);
        };
        "spec" = mkOption {
          description = "spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpec"
            )
          );
        };
        "status" = mkOption {
          description = "status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesStatus"
            )
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecSelector"
            )
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesStatusConditions" = {

      options = {
        "lastProbeTime" = mkOption {
          description = "lastProbeTime is the time we probed the condition.";
          type = (types.nullOr types.str);
        };
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the time the condition transitioned from one status to another.";
          type = (types.nullOr types.str);
        };
        "message" = mkOption {
          description = "message is the human-readable message indicating details about last transition.";
          type = (types.nullOr types.str);
        };
        "reason" = mkOption {
          description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
          type = (types.nullOr types.str);
        };
        "status" = mkOption {
          description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
          type = types.str;
        };
      };

      config = {
        "lastProbeTime" = mkOverride 1002 null;
        "lastTransitionTime" = mkOverride 1002 null;
        "message" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecClaimTemplatesStatusModifyVolumeStatus" = {

      options = {
        "status" = mkOption {
          description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
          type = types.str;
        };
        "targetVolumeAttributesClassName" = mkOption {
          description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "targetVolumeAttributesClassName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigReloadAuthKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigReloaderResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigReloaderResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigReloaderResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecConfigSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfig" = {

      options = {
        "tls_client_config" = mkOption {
          description = "TLSClientConfig defines client TLS configuration for alertmanager";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_config"
            )
          );
        };
        "tls_server_config" = mkOption {
          description = "TLSServerConfig defines server TLS configuration for alertmanager";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_config"
            )
          );
        };
      };

      config = {
        "tls_client_config" = mkOverride 1002 null;
        "tls_server_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_config" = {

      options = {
        "ca_file" = mkOption {
          description = "CAFile defines path to the pre-mounted file with CA\nmutually exclusive with CASecretRef";
          type = (types.nullOr types.str);
        };
        "ca_secret_ref" = mkOption {
          description = "CA defines reference for secret with CA content under given key\nmutually exclusive with CAFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_configCa_secret_ref"
            )
          );
        };
        "cert_file" = mkOption {
          description = "CertFile defines path to the pre-mounted file with certificate\nmutually exclusive with CertSecretRef";
          type = (types.nullOr types.str);
        };
        "cert_secret_ref" = mkOption {
          description = "CertSecretRef defines reference for secret with certificate content under given key\nmutually exclusive with CertFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_configCert_secret_ref"
            )
          );
        };
        "insecure_skip_verify" = mkOption {
          description = "Cert defines reference for secret with CA content under given key\nmutually exclusive with CertFile";
          type = (types.nullOr types.bool);
        };
        "key_file" = mkOption {
          description = "KeyFile defines path to the pre-mounted file with certificate key\nmutually exclusive with KeySecretRef";
          type = (types.nullOr types.str);
        };
        "key_secret_ref" = mkOption {
          description = "Key defines reference for secret with certificate key content under given key\nmutually exclusive with KeyFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_configKey_secret_ref"
            )
          );
        };
        "server_name" = mkOption {
          description = "ServerName indicates a name of a server";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca_file" = mkOverride 1002 null;
        "ca_secret_ref" = mkOverride 1002 null;
        "cert_file" = mkOverride 1002 null;
        "cert_secret_ref" = mkOverride 1002 null;
        "insecure_skip_verify" = mkOverride 1002 null;
        "key_file" = mkOverride 1002 null;
        "key_secret_ref" = mkOverride 1002 null;
        "server_name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_configCa_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_configCert_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_client_configKey_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_config" = {

      options = {
        "cert_file" = mkOption {
          description = "CertFile defines path to the pre-mounted file with certificate\nmutually exclusive with CertSecretRef";
          type = (types.nullOr types.str);
        };
        "cert_secret_ref" = mkOption {
          description = "CertSecretRef defines reference for secret with certificate content under given key\nmutually exclusive with CertFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_configCert_secret_ref"
            )
          );
        };
        "cipher_suites" = mkOption {
          description = "CipherSuites defines list of supported cipher suites for TLS versions up to TLS 1.2\nhttps://golang.org/pkg/crypto/tls/#pkg-constants";
          type = (types.nullOr (types.listOf types.str));
        };
        "client_auth_type" = mkOption {
          description = "Cert defines reference for secret with CA content under given key\nmutually exclusive with CertFile\nClientAuthType defines server policy for client authentication\nIf you want to enable client authentication (aka mTLS), you need to use RequireAndVerifyClientCert\nNote, mTLS is supported only at enterprise version of VictoriaMetrics components";
          type = (types.nullOr types.str);
        };
        "client_ca_file" = mkOption {
          description = "ClientCAFile defines path to the pre-mounted file with CA\nmutually exclusive with ClientCASecretRef";
          type = (types.nullOr types.str);
        };
        "client_ca_secret_ref" = mkOption {
          description = "ClientCASecretRef defines reference for secret with CA content under given key\nmutually exclusive with ClientCAFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_configClient_ca_secret_ref"
            )
          );
        };
        "curve_preferences" = mkOption {
          description = "CurvePreferences defines elliptic curves that will be used in an ECDHE handshake, in preference order.\nhttps://golang.org/pkg/crypto/tls/#CurveID";
          type = (types.nullOr (types.listOf types.str));
        };
        "key_file" = mkOption {
          description = "KeyFile defines path to the pre-mounted file with certificate key\nmutually exclusive with KeySecretRef";
          type = (types.nullOr types.str);
        };
        "key_secret_ref" = mkOption {
          description = "Key defines reference for secret with certificate key content under given key\nmutually exclusive with KeyFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_configKey_secret_ref"
            )
          );
        };
        "max_version" = mkOption {
          description = "MaxVersion maximum TLS version that is acceptable.";
          type = (types.nullOr types.str);
        };
        "min_version" = mkOption {
          description = "MinVersion minimum TLS version that is acceptable.";
          type = (types.nullOr types.str);
        };
        "prefer_server_cipher_suites" = mkOption {
          description = "PreferServerCipherSuites controls whether the server selects the\nclient's most preferred ciphersuite";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "cert_file" = mkOverride 1002 null;
        "cert_secret_ref" = mkOverride 1002 null;
        "cipher_suites" = mkOverride 1002 null;
        "client_auth_type" = mkOverride 1002 null;
        "client_ca_file" = mkOverride 1002 null;
        "client_ca_secret_ref" = mkOverride 1002 null;
        "curve_preferences" = mkOverride 1002 null;
        "key_file" = mkOverride 1002 null;
        "key_secret_ref" = mkOverride 1002 null;
        "max_version" = mkOverride 1002 null;
        "min_version" = mkOverride 1002 null;
        "prefer_server_cipher_suites" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_configCert_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_configClient_ca_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecGossipConfigTls_server_configKey_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecPersistentVolumeClaimRetentionPolicy" = {

      options = {
        "whenDeleted" = mkOption {
          description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
          type = (types.nullOr types.str);
        };
        "whenScaled" = mkOption {
          description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "whenDeleted" = mkOverride 1002 null;
        "whenScaled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecServiceSpecMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageEmptyDir")
          );
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplate"
            )
          );
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplate" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "EmbeddedMetadata contains metadata relevant to an EmbeddedResource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "Spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpec"
            )
          );
        };
        "status" = mkOption {
          description = "Status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateStatus"
            )
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector"
            )
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
          "namespace" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateStatusConditions" =
      {

        options = {
          "lastProbeTime" = mkOption {
            description = "lastProbeTime is the time we probed the condition.";
            type = (types.nullOr types.str);
          };
          "lastTransitionTime" = mkOption {
            description = "lastTransitionTime is the time the condition transitioned from one status to another.";
            type = (types.nullOr types.str);
          };
          "message" = mkOption {
            description = "message is the human-readable message indicating details about last transition.";
            type = (types.nullOr types.str);
          };
          "reason" = mkOption {
            description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
            type = (types.nullOr types.str);
          };
          "status" = mkOption {
            description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
            type = types.str;
          };
        };

        config = {
          "lastProbeTime" = mkOverride 1002 null;
          "lastTransitionTime" = mkOverride 1002 null;
          "message" = mkOverride 1002 null;
          "reason" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecStorageVolumeClaimTemplateStatusModifyVolumeStatus" =
      {

        options = {
          "status" = mkOption {
            description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
            type = types.str;
          };
          "targetVolumeAttributesClassName" = mkOption {
            description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "targetVolumeAttributesClassName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecTemplates" = {

      options = {
        "key" = mkOption {
          description = "The ConfigMap key to refer to.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfig" = {

      options = {
        "basic_auth_users" = mkOption {
          description = "BasicAuthUsers Usernames and hashed passwords that have full access to the web server\nPasswords must be hashed with bcrypt";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "http_server_config" = mkOption {
          description = "HTTPServerConfig defines http server configuration for alertmanager web server";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigHttp_server_config"
            )
          );
        };
        "tls_server_config" = mkOption {
          description = "TLSServerConfig defines server TLS configuration for alertmanager";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_config"
            )
          );
        };
      };

      config = {
        "basic_auth_users" = mkOverride 1002 null;
        "http_server_config" = mkOverride 1002 null;
        "tls_server_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigHttp_server_config" = {

      options = {
        "headers" = mkOption {
          description = "Headers defines list of headers that can be added to HTTP responses.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "http2" = mkOption {
          description = "HTTP2 enables HTTP/2 support. Note that HTTP/2 is only supported with TLS.\nThis can not be changed on the fly.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "headers" = mkOverride 1002 null;
        "http2" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_config" = {

      options = {
        "cert_file" = mkOption {
          description = "CertFile defines path to the pre-mounted file with certificate\nmutually exclusive with CertSecretRef";
          type = (types.nullOr types.str);
        };
        "cert_secret_ref" = mkOption {
          description = "CertSecretRef defines reference for secret with certificate content under given key\nmutually exclusive with CertFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_configCert_secret_ref"
            )
          );
        };
        "cipher_suites" = mkOption {
          description = "CipherSuites defines list of supported cipher suites for TLS versions up to TLS 1.2\nhttps://golang.org/pkg/crypto/tls/#pkg-constants";
          type = (types.nullOr (types.listOf types.str));
        };
        "client_auth_type" = mkOption {
          description = "Cert defines reference for secret with CA content under given key\nmutually exclusive with CertFile\nClientAuthType defines server policy for client authentication\nIf you want to enable client authentication (aka mTLS), you need to use RequireAndVerifyClientCert\nNote, mTLS is supported only at enterprise version of VictoriaMetrics components";
          type = (types.nullOr types.str);
        };
        "client_ca_file" = mkOption {
          description = "ClientCAFile defines path to the pre-mounted file with CA\nmutually exclusive with ClientCASecretRef";
          type = (types.nullOr types.str);
        };
        "client_ca_secret_ref" = mkOption {
          description = "ClientCASecretRef defines reference for secret with CA content under given key\nmutually exclusive with ClientCAFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_configClient_ca_secret_ref"
            )
          );
        };
        "curve_preferences" = mkOption {
          description = "CurvePreferences defines elliptic curves that will be used in an ECDHE handshake, in preference order.\nhttps://golang.org/pkg/crypto/tls/#CurveID";
          type = (types.nullOr (types.listOf types.str));
        };
        "key_file" = mkOption {
          description = "KeyFile defines path to the pre-mounted file with certificate key\nmutually exclusive with KeySecretRef";
          type = (types.nullOr types.str);
        };
        "key_secret_ref" = mkOption {
          description = "Key defines reference for secret with certificate key content under given key\nmutually exclusive with KeyFile";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_configKey_secret_ref"
            )
          );
        };
        "max_version" = mkOption {
          description = "MaxVersion maximum TLS version that is acceptable.";
          type = (types.nullOr types.str);
        };
        "min_version" = mkOption {
          description = "MinVersion minimum TLS version that is acceptable.";
          type = (types.nullOr types.str);
        };
        "prefer_server_cipher_suites" = mkOption {
          description = "PreferServerCipherSuites controls whether the server selects the\nclient's most preferred ciphersuite";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "cert_file" = mkOverride 1002 null;
        "cert_secret_ref" = mkOverride 1002 null;
        "cipher_suites" = mkOverride 1002 null;
        "client_auth_type" = mkOverride 1002 null;
        "client_ca_file" = mkOverride 1002 null;
        "client_ca_secret_ref" = mkOverride 1002 null;
        "curve_preferences" = mkOverride 1002 null;
        "key_file" = mkOverride 1002 null;
        "key_secret_ref" = mkOverride 1002 null;
        "max_version" = mkOverride 1002 null;
        "min_version" = mkOverride 1002 null;
        "prefer_server_cipher_suites" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_configCert_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_configClient_ca_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerSpecWebConfigTls_server_configKey_secret_ref" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAlertmanagerStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAlertmanagerStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuth" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMAuthSpec defines the desired state of VMAuth";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpec"));
        };
        "status" = mkOption {
          description = "VMAuthStatus defines the observed state of VMAuth";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpec" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "configReloadAuthKeySecret" = mkOption {
          description = "ConfigReloadAuthKeySecret defines optional secret reference authKey for /-/reload API requests.\nGiven secret reference will be added to the application and vm-config-reloader as volume\navailable since v0.57.0 version";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecConfigReloadAuthKeySecret"
            )
          );
        };
        "configReloaderExtraArgs" = mkOption {
          description = "ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container\nfor example resyncInterval: \"30s\"";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "configReloaderImageTag" = mkOption {
          description = "ConfigReloaderImageTag defines image:tag for config-reloader container";
          type = (types.nullOr types.str);
        };
        "configReloaderResources" = mkOption {
          description = "ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecConfigReloaderResources")
          );
        };
        "configSecret" = mkOption {
          description = "ConfigSecret is the name of a Kubernetes Secret in the same namespace as the\nVMAuth object, which contains auth configuration for vmauth,\nconfiguration must be inside secret key: config.yaml.\nIt must be created and managed manually.\nIf it's defined, configuration for vmauth becomes unmanaged and operator'll not create any related secrets/config-reloaders\nDeprecated: use externalConfig.secretRef instead";
          type = (types.nullOr types.str);
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "externalConfig" = mkOption {
          description = "ExternalConfig defines a source of external VMAuth configuration.\nIf it's defined, configuration for vmauth becomes unmanaged and operator'll not create any related secrets/config-reloaders";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecExternalConfig"));
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvs" "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHost_aliases")
            )
          );
        };
        "hpa" = mkOption {
          description = "Configures horizontal pod autoscaling.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpa"));
        };
        "httpRoute" = mkOption {
          description = "HTTPRoute enables httproute configuration for VMAuth.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHttpRoute"));
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAuthSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "ingress" = mkOption {
          description = "Ingress enables ingress configuration for VMAuth.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngress"));
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "internalListenPort" = mkOption {
          description = "InternalListenPort instructs vmauth to serve internal routes at given port\navailable from v0.56.0 operator\nand v1.111.0 vmauth version\nrelated doc https://docs.victoriametrics.com/victoriametrics/vmauth/#security";
          type = (types.nullOr types.str);
        };
        "license" = mkOption {
          description = "License allows to configure license key to be used for enterprise features.\nUsing license key is supported starting from VictoriaMetrics v1.94.0.\nSee [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecLicense"));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMAuth to be configured with.";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for victoria metrics single to be configured with.";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecManagedMetadata")
          );
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecPodDisruptionBudget")
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VMAuth pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecPodMetadata"));
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecResources"));
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.\nAvailable from operator v0.64.0";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecRollingUpdate"));
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "selectAllByDefault" = mkOption {
          description = "SelectAllByDefault changes default behavior for empty CRD selectors, such userSelector.\nwith selectAllByDefault: true and empty userSelector and userNamespaceSelector\nOperator selects all exist users\nwith selectAllByDefault: false - selects nothing";
          type = (types.nullOr types.bool);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmauth VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vmsingle service spec";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecServiceSpec"));
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "unauthorizedAccessConfig" = mkOption {
          description = "UnauthorizedAccessConfig configures access for un authorized users\n\nDeprecated: use unauthorizedUserAccessSpec instead\nwill be removed at v1.0 release";
          type = (types.nullOr types.attrs);
        };
        "unauthorizedUserAccessSpec" = mkOption {
          description = "UnauthorizedUserAccessSpec defines unauthorized_user config section of vmauth config";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpec"
            )
          );
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useProxyProtocol" = mkOption {
          description = "UseProxyProtocol enables proxy protocol for vmauth\nhttps://www.haproxy.org/download/2.3/doc/proxy-protocol.txt";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "useVMConfigReloader" = mkOption {
          description = "UseVMConfigReloader replaces prometheus-like config-reloader\nwith vm one. It uses secrets watch instead of file watch\nwhich greatly increases speed of config updates";
          type = (types.nullOr types.bool);
        };
        "userNamespaceSelector" = mkOption {
          description = "UserNamespaceSelector Namespaces to be selected for  VMAuth discovery.\nWorks in combination with Selector.\nNamespaceSelector nil - only objects at VMAuth namespace.\nSelector nil - only objects at NamespaceSelector namespaces.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUserNamespaceSelector")
          );
        };
        "userSelector" = mkOption {
          description = "UserSelector defines VMUser to be selected for config file generation.\nWorks in combination with NamespaceSelector.\nNamespaceSelector nil - only objects at VMAuth namespace.\nIf both nil - behaviour controlled by selectAllByDefault";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUserSelector"));
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAuthSpecVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "configReloadAuthKeySecret" = mkOverride 1002 null;
        "configReloaderExtraArgs" = mkOverride 1002 null;
        "configReloaderImageTag" = mkOverride 1002 null;
        "configReloaderResources" = mkOverride 1002 null;
        "configSecret" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "externalConfig" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "hpa" = mkOverride 1002 null;
        "httpRoute" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "ingress" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "internalListenPort" = mkOverride 1002 null;
        "license" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "selectAllByDefault" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "unauthorizedAccessConfig" = mkOverride 1002 null;
        "unauthorizedUserAccessSpec" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useProxyProtocol" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "useVMConfigReloader" = mkOverride 1002 null;
        "userNamespaceSelector" = mkOverride 1002 null;
        "userSelector" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecConfigReloadAuthKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecConfigReloaderResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAuthSpecConfigReloaderResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecConfigReloaderResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAuthSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecExternalConfig" = {

      options = {
        "localPath" = mkOption {
          description = "LocalPath contains static path to a config, which is managed externally for cases\nwhen using secrets is not applicable, e.g.: Vault sidecar.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "SecretRef defines selector for externally managed secret which contains configuration";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecExternalConfigSecretRef")
          );
        };
      };

      config = {
        "localPath" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecExternalConfigSecretRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpa" = {

      options = {
        "behaviour" = mkOption {
          description = "HorizontalPodAutoscalerBehavior configures the scaling behavior of the target\nin both Up and Down directions (scaleUp and scaleDown fields respectively).";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviour"));
        };
        "maxReplicas" = mkOption {
          description = "";
          type = (types.nullOr types.int);
        };
        "metrics" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetrics")
            )
          );
        };
        "minReplicas" = mkOption {
          description = "";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "behaviour" = mkOverride 1002 null;
        "maxReplicas" = mkOverride 1002 null;
        "metrics" = mkOverride 1002 null;
        "minReplicas" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviour" = {

      options = {
        "scaleDown" = mkOption {
          description = "scaleDown is scaling policy for scaling Down.\nIf not set, the default value is to allow to scale down to minReplicas pods, with a\n300 second stabilization window (i.e., the highest recommendation for\nthe last 300sec is used).";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleDown")
          );
        };
        "scaleUp" = mkOption {
          description = "scaleUp is scaling policy for scaling Up.\nIf not set, the default value is the higher of:\n  * increase no more than 4 pods per 60 seconds\n  * double the number of pods per 60 seconds\nNo stabilization is used.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleUp")
          );
        };
      };

      config = {
        "scaleDown" = mkOverride 1002 null;
        "scaleUp" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleDown" = {

      options = {
        "policies" = mkOption {
          description = "policies is a list of potential scaling polices which can be used during scaling.\nIf not set, use the default values:\n- For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.\n- For scale down: allow all pods to be removed in a 15s window.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleDownPolicies"
              )
            )
          );
        };
        "selectPolicy" = mkOption {
          description = "selectPolicy is used to specify which policy should be used.\nIf not set, the default value Max is used.";
          type = (types.nullOr types.str);
        };
        "stabilizationWindowSeconds" = mkOption {
          description = "stabilizationWindowSeconds is the number of seconds for which past recommendations should be\nconsidered while scaling up or scaling down.\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\nIf not set, use the default values:\n- For scale up: 0 (i.e. no stabilization is done).\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).";
          type = (types.nullOr types.int);
        };
        "tolerance" = mkOption {
          description = "tolerance is the tolerance on the ratio between the current and desired\nmetric value under which no updates are made to the desired number of\nreplicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not\nset, the default cluster-wide tolerance is applied (by default 10%).\n\nFor example, if autoscaling is configured with a memory consumption target of 100Mi,\nand scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be\ntriggered when the actual consumption falls below 95Mi or exceeds 101Mi.\n\nThis is an alpha field and requires enabling the HPAConfigurableTolerance\nfeature gate.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "policies" = mkOverride 1002 null;
        "selectPolicy" = mkOverride 1002 null;
        "stabilizationWindowSeconds" = mkOverride 1002 null;
        "tolerance" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleDownPolicies" = {

      options = {
        "periodSeconds" = mkOption {
          description = "periodSeconds specifies the window of time for which the policy should hold true.\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).";
          type = types.int;
        };
        "type" = mkOption {
          description = "type is used to specify the scaling policy.";
          type = types.str;
        };
        "value" = mkOption {
          description = "value contains the amount of change which is permitted by the policy.\nIt must be greater than zero";
          type = types.int;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleUp" = {

      options = {
        "policies" = mkOption {
          description = "policies is a list of potential scaling polices which can be used during scaling.\nIf not set, use the default values:\n- For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.\n- For scale down: allow all pods to be removed in a 15s window.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleUpPolicies"
              )
            )
          );
        };
        "selectPolicy" = mkOption {
          description = "selectPolicy is used to specify which policy should be used.\nIf not set, the default value Max is used.";
          type = (types.nullOr types.str);
        };
        "stabilizationWindowSeconds" = mkOption {
          description = "stabilizationWindowSeconds is the number of seconds for which past recommendations should be\nconsidered while scaling up or scaling down.\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\nIf not set, use the default values:\n- For scale up: 0 (i.e. no stabilization is done).\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).";
          type = (types.nullOr types.int);
        };
        "tolerance" = mkOption {
          description = "tolerance is the tolerance on the ratio between the current and desired\nmetric value under which no updates are made to the desired number of\nreplicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not\nset, the default cluster-wide tolerance is applied (by default 10%).\n\nFor example, if autoscaling is configured with a memory consumption target of 100Mi,\nand scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be\ntriggered when the actual consumption falls below 95Mi or exceeds 101Mi.\n\nThis is an alpha field and requires enabling the HPAConfigurableTolerance\nfeature gate.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "policies" = mkOverride 1002 null;
        "selectPolicy" = mkOverride 1002 null;
        "stabilizationWindowSeconds" = mkOverride 1002 null;
        "tolerance" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaBehaviourScaleUpPolicies" = {

      options = {
        "periodSeconds" = mkOption {
          description = "periodSeconds specifies the window of time for which the policy should hold true.\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).";
          type = types.int;
        };
        "type" = mkOption {
          description = "type is used to specify the scaling policy.";
          type = types.str;
        };
        "value" = mkOption {
          description = "value contains the amount of change which is permitted by the policy.\nIt must be greater than zero";
          type = types.int;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetrics" = {

      options = {
        "containerResource" = mkOption {
          description = "containerResource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing a single container in\neach pod of the current scale target (e.g. CPU or memory). Such metrics are\nbuilt in to Kubernetes, and have special scaling options on top of those\navailable to normal per-pod metrics using the \"pods\" source.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsContainerResource"
            )
          );
        };
        "external" = mkOption {
          description = "external refers to a global metric that is not associated\nwith any Kubernetes object. It allows autoscaling based on information\ncoming from components running outside of cluster\n(for example length of queue in cloud messaging service, or\nQPS from loadbalancer running outside of cluster).";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternal")
          );
        };
        "object" = mkOption {
          description = "object refers to a metric describing a single kubernetes object\n(for example, hits-per-second on an Ingress object).";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObject")
          );
        };
        "pods" = mkOption {
          description = "pods refers to a metric describing each pod in the current scale target\n(for example, transactions-processed-per-second).  The values will be\naveraged together before being compared to the target value.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPods"));
        };
        "resource" = mkOption {
          description = "resource refers to a resource metric (such as those specified in\nrequests and limits) known to Kubernetes describing each pod in the\ncurrent scale target (e.g. CPU or memory). Such metrics are built in to\nKubernetes, and have special scaling options on top of those available\nto normal per-pod metrics using the \"pods\" source.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsResource")
          );
        };
        "type" = mkOption {
          description = "type is the type of metric source.  It should be one of \"ContainerResource\", \"External\",\n\"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object.";
          type = types.str;
        };
      };

      config = {
        "containerResource" = mkOverride 1002 null;
        "external" = mkOverride 1002 null;
        "object" = mkOverride 1002 null;
        "pods" = mkOverride 1002 null;
        "resource" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsContainerResource" = {

      options = {
        "container" = mkOption {
          description = "container is the name of the container in the pods of the scaling target";
          type = types.str;
        };
        "name" = mkOption {
          description = "name is the name of the resource in question.";
          type = types.str;
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsContainerResourceTarget"
          );
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsContainerResourceTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternal" = {

      options = {
        "metric" = mkOption {
          description = "metric identifies the target metric by name and selector";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalMetric");
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalTarget");
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalMetric" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the given metric";
          type = types.str;
        };
        "selector" = mkOption {
          description = "selector is the string-encoded form of a standard kubernetes label selector for the given metric\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\nWhen unset, just the metricName will be used to gather metrics.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalMetricSelector"
            )
          );
        };
      };

      config = {
        "selector" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalMetricSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalMetricSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalMetricSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsExternalTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObject" = {

      options = {
        "describedObject" = mkOption {
          description = "describedObject specifies the descriptions of a object,such as kind,name apiVersion";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectDescribedObject"
          );
        };
        "metric" = mkOption {
          description = "metric identifies the target metric by name and selector";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectMetric");
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectTarget");
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectDescribedObject" = {

      options = {
        "apiVersion" = mkOption {
          description = "apiVersion is the API version of the referent";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = types.str;
        };
        "name" = mkOption {
          description = "name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = types.str;
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectMetric" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the given metric";
          type = types.str;
        };
        "selector" = mkOption {
          description = "selector is the string-encoded form of a standard kubernetes label selector for the given metric\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\nWhen unset, just the metricName will be used to gather metrics.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectMetricSelector"
            )
          );
        };
      };

      config = {
        "selector" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectMetricSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectMetricSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectMetricSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsObjectTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPods" = {

      options = {
        "metric" = mkOption {
          description = "metric identifies the target metric by name and selector";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsMetric");
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsTarget");
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsMetric" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the given metric";
          type = types.str;
        };
        "selector" = mkOption {
          description = "selector is the string-encoded form of a standard kubernetes label selector for the given metric\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\nWhen unset, just the metricName will be used to gather metrics.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsMetricSelector"
            )
          );
        };
      };

      config = {
        "selector" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsMetricSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsMetricSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsMetricSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsPodsTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsResource" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the resource in question.";
          type = types.str;
        };
        "target" = mkOption {
          description = "target specifies the target value for the given metric";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsResourceTarget");
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHpaMetricsResourceTarget" = {

      options = {
        "averageUtilization" = mkOption {
          description = "averageUtilization is the target value of the average of the\nresource metric across all relevant pods, represented as a percentage of\nthe requested value of the resource for the pods.\nCurrently only valid for Resource metric source type";
          type = (types.nullOr types.int);
        };
        "averageValue" = mkOption {
          description = "averageValue is the target value of the average of the\nmetric across all relevant pods (as a quantity)";
          type = (types.nullOr (types.either types.int types.str));
        };
        "type" = mkOption {
          description = "type represents whether the metric type is Utilization, Value, or AverageValue";
          type = types.str;
        };
        "value" = mkOption {
          description = "value is the target value of the metric (as a quantity).";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "averageUtilization" = mkOverride 1002 null;
        "averageValue" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHttpRoute" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraRules" = mkOption {
          description = "ExtraRules defines custom HTTPRouteRule in raw form, bypassing Gateway API CEL validations.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "hostnames" = mkOption {
          description = "Hostnames defines a set of hostnames that should match against the HTTP Host\nheader to select a HTTPRoute used to process the request.";
          type = (types.nullOr (types.listOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
        "parentRefs" = mkOption {
          description = "ParentRefs references the resources (usually Gateways) that a Route wants to be attached to.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMAuthSpecHttpRouteParentRefs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "extraRules" = mkOverride 1002 null;
        "hostnames" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "parentRefs" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecHttpRouteParentRefs" = {

      options = {
        "group" = mkOption {
          description = "Group is the group of the referent.\nWhen unspecified, \"gateway.networking.k8s.io\" is inferred.\nTo set the core API group (such as for a \"Service\" kind referent),\nGroup must be explicitly set to \"\" (empty string).\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is kind of the referent.\n\nThere are two kinds of parent resources with \"Core\" support:\n\n* Gateway (Gateway conformance profile)\n* Service (Mesh conformance profile, ClusterIP Services only)\n\nSupport for other resources is Implementation-Specific.";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "Name is the name of the referent.\n\nSupport: Core";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of the referent. When unspecified, this refers\nto the local namespace of the Route.\n\nNote that there are specific rules for ParentRefs which cross namespace\nboundaries. Cross-namespace references are only valid if they are explicitly\nallowed by something in the namespace they are referring to. For example:\nGateway has the AllowedRoutes field, and ReferenceGrant provides a\ngeneric way to enable any other kind of cross-namespace reference.\n\n<gateway:experimental:description>\nParentRefs from a Route to a Service in the same namespace are \"producer\"\nroutes, which apply default routing rules to inbound connections from\nany namespace to the Service.\n\nParentRefs from a Route to a Service in a different namespace are\n\"consumer\" routes, and these routing rules are only applied to outbound\nconnections originating from the same namespace as the Route, for which\nthe intended destination of the connections are a Service targeted as a\nParentRef of the Route.\n</gateway:experimental:description>\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port is the network port this Route targets. It can be interpreted\ndifferently based on the type of parent resource.\n\nWhen the parent resource is a Gateway, this targets all listeners\nlistening on the specified port that also support this kind of Route(and\nselect this Route). It's not recommended to set `Port` unless the\nnetworking behaviors specified in a Route must apply to a specific port\nas opposed to a listener(s) whose port(s) may be changed. When both Port\nand SectionName are specified, the name and port of the selected listener\nmust match both specified values.\n\n<gateway:experimental:description>\nWhen the parent resource is a Service, this targets a specific port in the\nService spec. When both Port (experimental) and SectionName are specified,\nthe name and port of the selected port must match both specified values.\n</gateway:experimental:description>\n\nImplementations MAY choose to support other parent resources.\nImplementations supporting other types of parent resources MUST clearly\ndocument how/if Port is interpreted.\n\nFor the purpose of status, an attachment is considered successful as\nlong as the parent resource accepts it partially. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment\nfrom the referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route,\nthe Route MUST be considered detached from the Gateway.\n\nSupport: Extended";
          type = (types.nullOr types.int);
        };
        "sectionName" = mkOption {
          description = "SectionName is the name of a section within the target resource. In the\nfollowing resources, SectionName is interpreted as the following:\n\n* Gateway: Listener name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n* Service: Port name. When both Port (experimental) and SectionName\nare specified, the name and port of the selected listener must match\nboth specified values.\n\nImplementations MAY choose to support attaching Routes to other resources.\nIf that is the case, they MUST clearly document how SectionName is\ninterpreted.\n\nWhen unspecified (empty string), this will reference the entire resource.\nFor the purpose of status, an attachment is considered successful if at\nleast one section in the parent resource accepts it. For example, Gateway\nlisteners can restrict which Routes can attach to them by Route kind,\nnamespace, or hostname. If 1 of 2 Gateway listeners accept attachment from\nthe referencing Route, the Route MUST be considered successfully\nattached. If no Gateway listeners accept attachment from this Route, the\nRoute MUST be considered detached from the Gateway.\n\nSupport: Core";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "group" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "sectionName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngress" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "class_name" = mkOption {
          description = "ClassName defines ingress class name for VMAuth";
          type = (types.nullOr types.str);
        };
        "extraRules" = mkOption {
          description = "ExtraRules - additional rules for ingress,\nmust be checked for correctness by user.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRules")
            )
          );
        };
        "extraTls" = mkOption {
          description = "ExtraTLS - additional TLS configuration for ingress\nmust be checked for correctness by user.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraTls")
            )
          );
        };
        "host" = mkOption {
          description = "Host defines ingress host parameter for default rule\nIt will be used, only if TlsHosts is empty";
          type = (types.nullOr types.str);
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
        "paths" = mkOption {
          description = "Paths defines ingress paths parameter for default rule";
          type = (types.nullOr (types.listOf types.str));
        };
        "tlsHosts" = mkOption {
          description = "TlsHosts configures TLS access for ingress, tlsSecretName must be defined for it.";
          type = (types.nullOr (types.listOf types.str));
        };
        "tlsSecretName" = mkOption {
          description = "TlsSecretName defines secretname at the VMAuth namespace with cert and key\nhttps://kubernetes.io/docs/concepts/services-networking/ingress/#tls";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "class_name" = mkOverride 1002 null;
        "extraRules" = mkOverride 1002 null;
        "extraTls" = mkOverride 1002 null;
        "host" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "paths" = mkOverride 1002 null;
        "tlsHosts" = mkOverride 1002 null;
        "tlsSecretName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRules" = {

      options = {
        "host" = mkOption {
          description = "host is the fully qualified domain name of a network host, as defined by RFC 3986.\nNote the following deviations from the \"host\" part of the\nURI as defined in RFC 3986:\n1. IPs are not allowed. Currently an IngressRuleValue can only apply to\n   the IP in the Spec of the parent Ingress.\n2. The `:` delimiter is not respected because ports are not allowed.\n\t  Currently the port of an Ingress is implicitly :80 for http and\n\t  :443 for https.\nBoth these may change in the future.\nIncoming requests are matched against the host before the\nIngressRuleValue. If the host is unspecified, the Ingress routes all\ntraffic based on the specified IngressRuleValue.\n\nhost can be \"precise\" which is a domain name without the terminating dot of\na network host (e.g. \"foo.bar.com\") or \"wildcard\", which is a domain name\nprefixed with a single wildcard label (e.g. \"*.foo.com\").\nThe wildcard character '*' must appear by itself as the first DNS label and\nmatches only a single label. You cannot have a wildcard label by itself (e.g. Host == \"*\").\nRequests will be matched against the Host field in the following way:\n1. If host is precise, the request matches this rule if the http host header is equal to Host.\n2. If host is a wildcard, then the request matches this rule if the http host header\nis to equal to the suffix (removing the first label) of the wildcard rule.";
          type = (types.nullOr types.str);
        };
        "http" = mkOption {
          description = "HTTPIngressRuleValue is a list of http selectors pointing to backends.\nIn the example: http://<host>/<path>?<searchpart> -> backend where\nwhere parts of the url correspond to RFC 3986, this resource will be used\nto match against everything after the last '/' and before the first '?'\nor '#'.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttp")
          );
        };
      };

      config = {
        "host" = mkOverride 1002 null;
        "http" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttp" = {

      options = {
        "paths" = mkOption {
          description = "paths is a collection of paths that map requests to backends.";
          type = (
            types.listOf (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPaths"
            )
          );
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPaths" = {

      options = {
        "backend" = mkOption {
          description = "backend defines the referenced service endpoint to which the traffic\nwill be forwarded to.";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackend"
          );
        };
        "path" = mkOption {
          description = "path is matched against the path of an incoming request. Currently it can\ncontain characters disallowed from the conventional \"path\" part of a URL\nas defined by RFC 3986. Paths must begin with a '/' and must be present\nwhen using PathType with value \"Exact\" or \"Prefix\".";
          type = (types.nullOr types.str);
        };
        "pathType" = mkOption {
          description = "pathType determines the interpretation of the path matching. PathType can\nbe one of the following values:\n* Exact: Matches the URL path exactly.\n* Prefix: Matches based on a URL path prefix split by '/'. Matching is\n  done on a path element by element basis. A path element refers is the\n  list of labels in the path split by the '/' separator. A request is a\n  match for path p if every p is an element-wise prefix of p of the\n  request path. Note that if the last element of the path is a substring\n  of the last element in request path, it is not a match (e.g. /foo/bar\n  matches /foo/bar/baz, but does not match /foo/barbaz).\n* ImplementationSpecific: Interpretation of the Path matching is up to\n  the IngressClass. Implementations can treat this as a separate PathType\n  or treat it identically to Prefix or Exact path types.\nImplementations are required to support all path types.";
          type = types.str;
        };
      };

      config = {
        "path" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackend" = {

      options = {
        "resource" = mkOption {
          description = "resource is an ObjectRef to another Kubernetes resource in the namespace\nof the Ingress object. If resource is specified, a service.Name and\nservice.Port must not be specified.\nThis is a mutually exclusive setting with \"Service\".";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackendResource"
            )
          );
        };
        "service" = mkOption {
          description = "service references a service as a backend.\nThis is a mutually exclusive setting with \"Resource\".";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackendService"
            )
          );
        };
      };

      config = {
        "resource" = mkOverride 1002 null;
        "service" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackendResource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackendService" = {

      options = {
        "name" = mkOption {
          description = "name is the referenced service. The service must exist in\nthe same namespace as the Ingress object.";
          type = types.str;
        };
        "port" = mkOption {
          description = "port of the referenced service. A port name or port number\nis required for a IngressServiceBackend.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackendServicePort"
            )
          );
        };
      };

      config = {
        "port" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraRulesHttpPathsBackendServicePort" = {

      options = {
        "name" = mkOption {
          description = "name is the name of the port on the Service.\nThis is a mutually exclusive setting with \"Number\".";
          type = (types.nullOr types.str);
        };
        "number" = mkOption {
          description = "number is the numerical port number (e.g. 80) on the Service.\nThis is a mutually exclusive setting with \"Name\".";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "number" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecIngressExtraTls" = {

      options = {
        "hosts" = mkOption {
          description = "hosts is a list of hosts included in the TLS certificate. The values in\nthis list must match the name/s used in the tlsSecret. Defaults to the\nwildcard host setting for the loadbalancer controller fulfilling this\nIngress, if left unspecified.";
          type = (types.nullOr (types.listOf types.str));
        };
        "secretName" = mkOption {
          description = "secretName is the name of the secret used to terminate TLS traffic on\nport 443. Field is left optional to allow TLS routing based on SNI\nhostname alone. If the SNI host in a listener conflicts with the \"Host\"\nheader field used by an IngressRule, the SNI host is used for termination\nand value of the \"Host\" header is used for routing.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "hosts" = mkOverride 1002 null;
        "secretName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecLicense" = {

      options = {
        "forceOffline" = mkOption {
          description = "Enforce offline verification of the license key.";
          type = (types.nullOr types.bool);
        };
        "key" = mkOption {
          description = "Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).\nTo request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)";
          type = (types.nullOr types.str);
        };
        "keyRef" = mkOption {
          description = "KeyRef is reference to secret with license key for enterprise features.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecLicenseKeyRef"));
        };
        "reloadInterval" = mkOption {
          description = "Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "forceOffline" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "keyRef" = mkOverride 1002 null;
        "reloadInterval" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecLicenseKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMAuthSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpec" = {

      options = {
        "default_url" = mkOption {
          description = "DefaultURLs backend url for non-matching paths filter\nusually used for default backend with error message";
          type = (types.nullOr (types.listOf types.str));
        };
        "discover_backend_ips" = mkOption {
          description = "DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.";
          type = (types.nullOr types.bool);
        };
        "drop_src_path_prefix_parts" = mkOption {
          description = "DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.";
          type = (types.nullOr types.int);
        };
        "dump_request_on_errors" = mkOption {
          description = "DumpRequestOnErrors instructs vmauth to return detailed request params to the client\nif routing rules don't allow to forward request to the backends.\nUseful for debugging `src_hosts` and `src_headers` based routing rules\n\navailable since v1.107.0 vmauth version";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers represent additional http headers, that vmauth uses\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.68.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip_filters" = mkOption {
          description = "IPFilters defines per target src ip filters\nsupported only with enterprise version of [vmauth](https://docs.victoriametrics.com/victoriametrics/vmauth/#ip-filters)";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecIp_filters"
            )
          );
        };
        "load_balancing_policy" = mkOption {
          description = "LoadBalancingPolicy defines load balancing policy to use for backend urls.\nSupported policies: least_loaded, first_available.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default \"least_loaded\")";
          type = (types.nullOr types.str);
        };
        "max_concurrent_requests" = mkOption {
          description = "MaxConcurrentRequests defines max concurrent requests per user\n300 is default value for vmauth";
          type = (types.nullOr types.int);
        };
        "metric_labels" = mkOption {
          description = "MetricLabels - additional labels for metrics exported by vmauth for given user.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "response_headers" = mkOption {
          description = "ResponseHeaders represent additional http headers, that vmauth adds for request response\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.93.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "retry_status_codes" = mkOption {
          description = "RetryStatusCodes defines http status codes in numeric format for request retries\ne.g. [429,503]";
          type = (types.nullOr (types.listOf types.int));
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig defines tls configuration for the backend connection";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfig"
            )
          );
        };
        "url_map" = mkOption {
          description = "";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecUrl_map"
              )
            )
          );
        };
        "url_prefix" = mkOption {
          description = "URLPrefix defines prefix prefix for destination";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "default_url" = mkOverride 1002 null;
        "discover_backend_ips" = mkOverride 1002 null;
        "drop_src_path_prefix_parts" = mkOverride 1002 null;
        "dump_request_on_errors" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "ip_filters" = mkOverride 1002 null;
        "load_balancing_policy" = mkOverride 1002 null;
        "max_concurrent_requests" = mkOverride 1002 null;
        "metric_labels" = mkOverride 1002 null;
        "response_headers" = mkOverride 1002 null;
        "retry_status_codes" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "url_map" = mkOverride 1002 null;
        "url_prefix" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecIp_filters" = {

      options = {
        "allow_list" = mkOption {
          description = "";
          type = (types.nullOr (types.listOf types.str));
        };
        "deny_list" = mkOption {
          description = "";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "allow_list" = mkOverride 1002 null;
        "deny_list" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUnauthorizedUserAccessSpecUrl_map" = {

      options = {
        "discover_backend_ips" = mkOption {
          description = "DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.";
          type = (types.nullOr types.bool);
        };
        "drop_src_path_prefix_parts" = mkOption {
          description = "DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.";
          type = (types.nullOr types.int);
        };
        "headers" = mkOption {
          description = "RequestHeaders represent additional http headers, that vmauth uses\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.68.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "load_balancing_policy" = mkOption {
          description = "LoadBalancingPolicy defines load balancing policy to use for backend urls.\nSupported policies: least_loaded, first_available.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default \"least_loaded\")";
          type = (types.nullOr types.str);
        };
        "response_headers" = mkOption {
          description = "ResponseHeaders represent additional http headers, that vmauth adds for request response\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.93.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "retry_status_codes" = mkOption {
          description = "RetryStatusCodes defines http status codes in numeric format for request retries\nCan be defined per target or at VMUser.spec level\ne.g. [429,503]";
          type = (types.nullOr (types.listOf types.int));
        };
        "src_headers" = mkOption {
          description = "SrcHeaders is an optional list of headers, which must match request headers.";
          type = (types.nullOr (types.listOf types.str));
        };
        "src_hosts" = mkOption {
          description = "SrcHosts is an optional list of regular expressions, which must match the request hostname.";
          type = (types.nullOr (types.listOf types.str));
        };
        "src_paths" = mkOption {
          description = "SrcPaths is an optional list of regular expressions, which must match the request path.";
          type = (types.nullOr (types.listOf types.str));
        };
        "src_query_args" = mkOption {
          description = "SrcQueryArgs is an optional list of query args, which must match request URL query args.";
          type = (types.nullOr (types.listOf types.str));
        };
        "url_prefix" = mkOption {
          description = "UrlPrefix contains backend url prefixes for the proxied request url.\nURLPrefix defines prefix prefix for destination";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "discover_backend_ips" = mkOverride 1002 null;
        "drop_src_path_prefix_parts" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "load_balancing_policy" = mkOverride 1002 null;
        "response_headers" = mkOverride 1002 null;
        "retry_status_codes" = mkOverride 1002 null;
        "src_headers" = mkOverride 1002 null;
        "src_hosts" = mkOverride 1002 null;
        "src_paths" = mkOverride 1002 null;
        "src_query_args" = mkOverride 1002 null;
        "url_prefix" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUserNamespaceSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUserNamespaceSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUserNamespaceSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUserSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthSpecUserSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecUserSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMAuthStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMAuthStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMCluster" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMClusterSpec defines the desired state of VMCluster";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpec");
        };
        "status" = mkOption {
          description = "VMClusterStatus defines the observed state of VMCluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpec" = {

      options = {
        "clusterDomainName" = mkOption {
          description = "ClusterDomainName defines domain name suffix for in-cluster dns addresses\naka .cluster.local\nused by vminsert and vmselect to build vmstorage address";
          type = (types.nullOr types.str);
        };
        "clusterVersion" = mkOption {
          description = "ClusterVersion defines default images tag for all components.\nit can be overwritten with component specific image.tag value.";
          type = (types.nullOr types.str);
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "license" = mkOption {
          description = "License allows to configure license key to be used for enterprise features.\nUsing license key is supported starting from VictoriaMetrics v1.94.0.\nSee [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecLicense"));
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecManagedMetadata")
          );
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "replicationFactor" = mkOption {
          description = "ReplicationFactor defines how many copies of data make among\ndistinct storage nodes";
          type = (types.nullOr types.int);
        };
        "requestsLoadBalancer" = mkOption {
          description = "RequestsLoadBalancer configures load-balancing for vminsert and vmselect requests.\nIt helps to evenly spread load across pods.\nUsually it's not possible with Kubernetes TCP-based services.\nSee more [here](https://docs.victoriametrics.com/operator/resources/vmcluster/#requests-load-balancing)";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecRequestsLoadBalancer")
          );
        };
        "retentionPeriod" = mkOption {
          description = "RetentionPeriod defines how long to retain stored metrics, specified as a duration (e.g., \"1d\", \"1w\", \"1m\").\nData with timestamps outside the RetentionPeriod is automatically deleted. The minimum allowed value is 1d, or 24h.\nThe default value is 1 (one month).\nSee [retention](https://docs.victoriametrics.com/victoriametrics/single-server-victoriametrics/#retention) docs for details.";
          type = (types.nullOr types.str);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the\nVMSelect, VMStorage and VMInsert Pods.";
          type = (types.nullOr types.str);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "vminsert" = mkOption {
          description = "";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsert"));
        };
        "vmselect" = mkOption {
          description = "VMSelect defines configuration section for vmselect components of the victoria-metrics cluster";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselect"));
        };
        "vmstorage" = mkOption {
          description = "";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorage"));
        };
      };

      config = {
        "clusterDomainName" = mkOverride 1002 null;
        "clusterVersion" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "license" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "replicationFactor" = mkOverride 1002 null;
        "requestsLoadBalancer" = mkOverride 1002 null;
        "retentionPeriod" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "vminsert" = mkOverride 1002 null;
        "vmselect" = mkOverride 1002 null;
        "vmstorage" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecLicense" = {

      options = {
        "forceOffline" = mkOption {
          description = "Enforce offline verification of the license key.";
          type = (types.nullOr types.bool);
        };
        "key" = mkOption {
          description = "Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).\nTo request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)";
          type = (types.nullOr types.str);
        };
        "keyRef" = mkOption {
          description = "KeyRef is reference to secret with license key for enterprise features.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecLicenseKeyRef")
          );
        };
        "reloadInterval" = mkOption {
          description = "Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "forceOffline" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "keyRef" = mkOverride 1002 null;
        "reloadInterval" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecLicenseKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecRequestsLoadBalancer" = {

      options = {
        "disableInsertBalancing" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "disableSelectBalancing" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "enabled" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "spec" = mkOption {
          description = "VMAuthLoadBalancerSpec defines configuration spec for VMAuth used as load-balancer\nfor VMCluster component";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "disableInsertBalancing" = mkOverride 1002 null;
        "disableSelectBalancing" = mkOverride 1002 null;
        "enabled" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsert" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "clusterNativeListenPort" = mkOption {
          description = "ClusterNativePort for multi-level cluster setup.\nMore [details](https://docs.victoriametrics.com/victoriametrics/cluster-victoriametrics/#multi-level-cluster-setup)";
          type = (types.nullOr types.str);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertDnsConfig")
          );
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertHost_aliases")
            )
          );
        };
        "hpa" = mkOption {
          description = "HPA defines kubernetes PodAutoScaling configuration version 2.";
          type = (types.nullOr types.attrs);
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertImage")
          );
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "insertPorts" = mkOption {
          description = "InsertPorts - additional listen ports for data ingestion.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertInsertPorts")
          );
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMInsert to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMInsert to be configured with.";
          type = (types.nullOr types.str);
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertPodDisruptionBudget"
            )
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VMInsert pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertPodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertReadinessGates"
              )
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertResources")
          );
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdate" = mkOption {
          description = "RollingUpdate - overrides deployment update params.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertRollingUpdate")
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vminsert VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vminsert service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "updateStrategy" = mkOption {
          description = "UpdateStrategy - overrides default update strategy.";
          type = (types.nullOr types.str);
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "clusterNativeListenPort" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "hpa" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "insertPorts" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdate" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "updateStrategy" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertInsertPorts" = {

      options = {
        "graphitePort" = mkOption {
          description = "GraphitePort listen port";
          type = (types.nullOr types.str);
        };
        "influxPort" = mkOption {
          description = "InfluxPort listen port";
          type = (types.nullOr types.str);
        };
        "openTSDBHTTPPort" = mkOption {
          description = "OpenTSDBHTTPPort for http connections.";
          type = (types.nullOr types.str);
        };
        "openTSDBPort" = mkOption {
          description = "OpenTSDBPort for tcp and udp listen";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "graphitePort" = mkOverride 1002 null;
        "influxPort" = mkOverride 1002 null;
        "openTSDBHTTPPort" = mkOverride 1002 null;
        "openTSDBPort" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertRollingUpdate" = {

      options = {
        "maxSurge" = mkOption {
          description = "The maximum number of pods that can be scheduled above the desired number of\npods.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet can be scaled up immediately when\nthe rolling update starts, such that the total number of old and new pods do not exceed\n130% of desired pods. Once old pods have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total number of pods running\nat any time during the update is at most 130% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "maxUnavailable" = mkOption {
          description = "The maximum number of pods that can be unavailable during the update.\nValue can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods\nimmediately when the rolling update starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available at all times during the update is at\nleast 70% of desired pods.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxSurge" = mkOverride 1002 null;
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertServiceSpecMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVminsertVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselect" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "cacheMountPath" = mkOption {
          description = "CacheMountPath allows to add cache persistent for VMSelect,\nwill use \"/cache\" as default if not specified.";
          type = (types.nullOr types.str);
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "clusterNativeListenPort" = mkOption {
          description = "ClusterNativePort for multi-level cluster setup.\nMore [details](https://docs.victoriametrics.com/victoriametrics/cluster-victoriametrics/#multi-level-cluster-setup)";
          type = (types.nullOr types.str);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectDnsConfig")
          );
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectHost_aliases")
            )
          );
        };
        "hpa" = mkOption {
          description = "Configures horizontal pod autoscaling.\nNote, enabling this option disables vmselect to vmselect communication. In most cases it's not an issue.";
          type = (types.nullOr types.attrs);
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectImage")
          );
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMSelect to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMSelect to be configured with.";
          type = (types.nullOr types.str);
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolume" = mkOption {
          description = "PersistentVolume - add persistent volume for cacheMountPath\nits useful for persistent cache\nuse storage instead of persistentVolume.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPersistentVolume"
            )
          );
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPodDisruptionBudget"
            )
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VMSelect pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectReadinessGates"
              )
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectResources")
          );
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdateStrategy" = mkOption {
          description = "RollingUpdateStrategy defines strategy for application updates\nDefault is OnDelete, in this case operator handles update process\nCan be changed for RollingUpdate";
          type = (types.nullOr types.str);
        };
        "rollingUpdateStrategyBehavior" = mkOption {
          description = "RollingUpdateStrategyBehavior defines customized behavior for rolling updates.\nIt applies if the RollingUpdateStrategy is set to OnDelete, which is the default.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectRollingUpdateStrategyBehavior"
            )
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmselect VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vmselect service spec";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "StorageSpec - add persistent volume claim for cacheMountPath\nits needed for persistent cache";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorage")
          );
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "cacheMountPath" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "clusterNativeListenPort" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "hpa" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolume" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdateStrategy" = mkOverride 1002 null;
        "rollingUpdateStrategyBehavior" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPersistentVolume" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPersistentVolumeEmptyDir"
            )
          );
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPersistentVolumeClaimRetentionPolicy" = {

      options = {
        "whenDeleted" = mkOption {
          description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
          type = (types.nullOr types.str);
        };
        "whenScaled" = mkOption {
          description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "whenDeleted" = mkOverride 1002 null;
        "whenScaled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPersistentVolumeEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectRollingUpdateStrategyBehavior" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "MaxUnavailable defines the maximum number of pods that can be unavailable during the update.\nIt can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. \"50%\").\nFor example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectServiceSpecMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageEmptyDir"
            )
          );
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplate"
            )
          );
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplate" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "EmbeddedMetadata contains metadata relevant to an EmbeddedResource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "Spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpec"
            )
          );
        };
        "status" = mkOption {
          description = "Status represents the current information/status of a persistent volume claim.\nRead-only.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateStatus"
            )
          );
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpec" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource"
            )
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef"
            )
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecResources"
            )
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector"
            )
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSource" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecDataSourceRef" =
      {

        options = {
          "apiGroup" = mkOption {
            description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
            type = (types.nullOr types.str);
          };
          "kind" = mkOption {
            description = "Kind is the type of resource being referenced";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name is the name of resource being referenced";
            type = types.str;
          };
          "namespace" = mkOption {
            description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "apiGroup" = mkOverride 1002 null;
          "namespace" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecResources" =
      {

        options = {
          "limits" = mkOption {
            description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
          "requests" = mkOption {
            description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
            type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
          };
        };

        config = {
          "limits" = mkOverride 1002 null;
          "requests" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecSelector" =
      {

        options = {
          "matchExpressions" = mkOption {
            description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
            type = (
              types.nullOr (
                types.listOf (
                  submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions"
                )
              )
            );
          };
          "matchLabels" = mkOption {
            description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
            type = (types.nullOr (types.attrsOf types.str));
          };
        };

        config = {
          "matchExpressions" = mkOverride 1002 null;
          "matchLabels" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateSpecSelectorMatchExpressions" =
      {

        options = {
          "key" = mkOption {
            description = "key is the label key that the selector applies to.";
            type = types.str;
          };
          "operator" = mkOption {
            description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
            type = types.str;
          };
          "values" = mkOption {
            description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
            type = (types.nullOr (types.listOf types.str));
          };
        };

        config = {
          "values" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateStatus" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the actual access modes the volume backing the PVC has.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "allocatedResourceStatuses" = mkOption {
          description = "allocatedResourceStatuses stores status of resource being resized for the given PVC.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nClaimResourceStatus can be in any of following states:\n\t- ControllerResizeInProgress:\n\t\tState set when resize controller starts resizing the volume in control-plane.\n\t- ControllerResizeFailed:\n\t\tState set when resize has failed in resize controller with a terminal error.\n\t- NodeResizePending:\n\t\tState set when resize controller has finished resizing the volume but further resizing of\n\t\tvolume is needed on the node.\n\t- NodeResizeInProgress:\n\t\tState set when kubelet starts resizing the volume.\n\t- NodeResizeFailed:\n\t\tState set when resizing has failed in kubelet with a terminal error. Transient errors don't set\n\t\tNodeResizeFailed.\nFor example: if expanding a PVC for more capacity - this field can be one of the following states:\n\t- pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"ControllerResizeFailed\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizePending\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeInProgress\"\n     - pvc.status.allocatedResourceStatus['storage'] = \"NodeResizeFailed\"\nWhen this field is not set, it means that no resize operation is in progress for the given PVC.\n\nA controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "allocatedResources" = mkOption {
          description = "allocatedResources tracks the resources allocated to a PVC including its capacity.\nKey names follow standard Kubernetes label syntax. Valid values are either:\n\t* Un-prefixed keys:\n\t\t- storage - the capacity of the volume.\n\t* Custom resources must use implementation-defined prefixed names such as \"example.com/my-custom-resource\"\nApart from above values - keys that are unprefixed or have kubernetes.io prefix are considered\nreserved and hence may not be used.\n\nCapacity reported here may be larger than the actual capacity when a volume expansion operation\nis requested.\nFor storage quota, the larger value from allocatedResources and PVC.spec.resources is used.\nIf allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.\nIf a volume expansion capacity request is lowered, allocatedResources is only\nlowered if there are no expansion operations in progress and if the actual volume capacity\nis equal or lower than the requested capacity.\n\nA controller that receives PVC update with previously unknown resourceName\nshould ignore the update for the purpose it was designed. For example - a controller that\nonly is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid\nresources associated with PVC.\n\nThis is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "capacity" = mkOption {
          description = "capacity represents the actual resources of the underlying volume.";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "conditions" = mkOption {
          description = "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being\nresized then the Condition will be set to 'Resizing'.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions"
              )
            )
          );
        };
        "currentVolumeAttributesClassName" = mkOption {
          description = "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.\nWhen unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim";
          type = (types.nullOr types.str);
        };
        "modifyVolumeStatus" = mkOption {
          description = "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.\nWhen this is unset, there is no ModifyVolume operation being attempted.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus"
            )
          );
        };
        "phase" = mkOption {
          description = "phase represents the current phase of PersistentVolumeClaim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "allocatedResourceStatuses" = mkOverride 1002 null;
        "allocatedResources" = mkOverride 1002 null;
        "capacity" = mkOverride 1002 null;
        "conditions" = mkOverride 1002 null;
        "currentVolumeAttributesClassName" = mkOverride 1002 null;
        "modifyVolumeStatus" = mkOverride 1002 null;
        "phase" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateStatusConditions" =
      {

        options = {
          "lastProbeTime" = mkOption {
            description = "lastProbeTime is the time we probed the condition.";
            type = (types.nullOr types.str);
          };
          "lastTransitionTime" = mkOption {
            description = "lastTransitionTime is the time the condition transitioned from one status to another.";
            type = (types.nullOr types.str);
          };
          "message" = mkOption {
            description = "message is the human-readable message indicating details about last transition.";
            type = (types.nullOr types.str);
          };
          "reason" = mkOption {
            description = "reason is a unique, this should be a short, machine understandable string that gives the reason\nfor condition's last transition. If it reports \"Resizing\" that means the underlying\npersistent volume is being resized.";
            type = (types.nullOr types.str);
          };
          "status" = mkOption {
            description = "Status is the status of the condition.\nCan be True, False, Unknown.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required";
            type = types.str;
          };
          "type" = mkOption {
            description = "Type is the type of the condition.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about";
            type = types.str;
          };
        };

        config = {
          "lastProbeTime" = mkOverride 1002 null;
          "lastTransitionTime" = mkOverride 1002 null;
          "message" = mkOverride 1002 null;
          "reason" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectStorageVolumeClaimTemplateStatusModifyVolumeStatus" =
      {

        options = {
          "status" = mkOption {
            description = "status is the status of the ControllerModifyVolume operation. It can be in any of following states:\n - Pending\n   Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as\n   the specified VolumeAttributesClass not existing.\n - InProgress\n   InProgress indicates that the volume is being modified.\n - Infeasible\n  Infeasible indicates that the request has been rejected as invalid by the CSI driver. To\n\t  resolve the error, a valid VolumeAttributesClass needs to be specified.\nNote: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.";
            type = types.str;
          };
          "targetVolumeAttributesClassName" = mkOption {
            description = "targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "targetVolumeAttributesClassName" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmselectVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorage" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "claimTemplates" = mkOption {
          description = "ClaimTemplates allows adding additional VolumeClaimTemplates for StatefulSet";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageDnsConfig")
          );
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvsFrom"
              )
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageHost_aliases")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageImage")
          );
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMStorage to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMStorage to be configured with.";
          type = (types.nullOr types.str);
        };
        "maintenanceInsertNodeIDs" = mkOption {
          description = "MaintenanceInsertNodeIDs - excludes given node ids from insert requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.\nlets say, you have pod-0, pod-1, pod-2, pod-3. to exclude pod-0 and pod-3 from insert routing, define nodeIDs: [0,3].\nUseful at storage expanding, when you want to rebalance some data at cluster.";
          type = (types.nullOr (types.listOf types.int));
        };
        "maintenanceSelectNodeIDs" = mkOption {
          description = "MaintenanceInsertNodeIDs - excludes given node ids from select requests routing, must contain pod suffixes - for pod-0, id will be 0 and etc.";
          type = (types.nullOr (types.listOf types.int));
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "persistentVolumeClaimRetentionPolicy" = mkOption {
          description = "PersistentVolumeClaimRetentionPolicy allows configuration of PVC retention policy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy"
            )
          );
        };
        "podDisruptionBudget" = mkOption {
          description = "PodDisruptionBudget created by operator";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstoragePodDisruptionBudget"
            )
          );
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VMStorage pods.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstoragePodMetadata")
          );
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageReadinessGates"
              )
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageResources")
          );
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "rollingUpdateStrategy" = mkOption {
          description = "RollingUpdateStrategy defines strategy for application updates\nDefault is OnDelete, in this case operator handles update process\nCan be changed for RollingUpdate";
          type = (types.nullOr types.str);
        };
        "rollingUpdateStrategyBehavior" = mkOption {
          description = "RollingUpdateStrategyBehavior defines customized behavior for rolling updates.\nIt applies if the RollingUpdateStrategy is set to OnDelete, which is the default.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageRollingUpdateStrategyBehavior"
            )
          );
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmstorage VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be create additional service for vmstorage";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageServiceSpec")
          );
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage - add persistent volume for StorageDataPath\nits useful for persistent cache";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageStorage")
          );
        };
        "storageDataPath" = mkOption {
          description = "StorageDataPath - path to storage data";
          type = (types.nullOr types.str);
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "vmBackup" = mkOption {
          description = "VMBackup configuration for backup";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackup")
          );
        };
        "vmInsertPort" = mkOption {
          description = "VMInsertPort for VMInsert connections";
          type = (types.nullOr types.str);
        };
        "vmSelectPort" = mkOption {
          description = "VMSelectPort for VMSelect connections";
          type = (types.nullOr types.str);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "claimTemplates" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "maintenanceInsertNodeIDs" = mkOverride 1002 null;
        "maintenanceSelectNodeIDs" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "persistentVolumeClaimRetentionPolicy" = mkOverride 1002 null;
        "podDisruptionBudget" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "rollingUpdateStrategy" = mkOverride 1002 null;
        "rollingUpdateStrategyBehavior" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "storageDataPath" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "vmBackup" = mkOverride 1002 null;
        "vmInsertPort" = mkOverride 1002 null;
        "vmSelectPort" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstoragePersistentVolumeClaimRetentionPolicy" =
      {

        options = {
          "whenDeleted" = mkOption {
            description = "WhenDeleted specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is deleted. The default policy\nof `Retain` causes PVCs to not be affected by StatefulSet deletion. The\n`Delete` policy causes those PVCs to be deleted.";
            type = (types.nullOr types.str);
          };
          "whenScaled" = mkOption {
            description = "WhenScaled specifies what happens to PVCs created from StatefulSet\nVolumeClaimTemplates when the StatefulSet is scaled down. The default\npolicy of `Retain` causes PVCs to not be affected by a scaledown. The\n`Delete` policy causes the associated PVCs for any excess pods above\nthe replica count to be deleted.";
            type = (types.nullOr types.str);
          };
        };

        config = {
          "whenDeleted" = mkOverride 1002 null;
          "whenScaled" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstoragePodDisruptionBudget" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "An eviction is allowed if at most \"maxUnavailable\" pods selected by\n\"selector\" are unavailable after the eviction, i.e. even in absence of\nthe evicted pod. For example, one can prevent all voluntary evictions\nby specifying 0. This is a mutually exclusive setting with \"minAvailable\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "minAvailable" = mkOption {
          description = "An eviction is allowed if at least \"minAvailable\" pods selected by\n\"selector\" will still be available after the eviction, i.e. even in the\nabsence of the evicted pod.  So for example you can prevent all voluntary\nevictions by specifying \"100%\".";
          type = (types.nullOr (types.either types.int types.str));
        };
        "selectorLabels" = mkOption {
          description = "replaces default labels selector generated by operator\nit's useful when you need to create custom budget";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "unhealthyPodEvictionPolicy" = mkOption {
          description = "UnhealthyPodEvictionPolicy defines the criteria for when unhealthy pods\n\nValid policies are IfHealthyBudget and AlwaysAllow.\nIf no policy is specified, the default behavior will be used,\nwhich corresponds to the IfHealthyBudget policy.\nAvailable from operator v0.64.0";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
        "minAvailable" = mkOverride 1002 null;
        "selectorLabels" = mkOverride 1002 null;
        "unhealthyPodEvictionPolicy" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstoragePodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageRollingUpdateStrategyBehavior" = {

      options = {
        "maxUnavailable" = mkOption {
          description = "MaxUnavailable defines the maximum number of pods that can be unavailable during the update.\nIt can be specified as an absolute number (e.g. 2) or a percentage of the total pods (e.g. \"50%\").\nFor example, if set to 100%, all pods will be upgraded at once, minimizing downtime when needed.";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "maxUnavailable" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageServiceSpecMetadata"
            )
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageStorage" = {

      options = {
        "disableMountSubPath" = mkOption {
          description = "Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.\nDisableMountSubPath allows to remove any subPath usage in volume mounts.";
          type = (types.nullOr types.bool);
        };
        "emptyDir" = mkOption {
          description = "EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More\ninfo: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageStorageEmptyDir"
            )
          );
        };
        "volumeClaimTemplate" = mkOption {
          description = "A PVC spec to be used by the StatefulSets/Deployments.";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "disableMountSubPath" = mkOverride 1002 null;
        "emptyDir" = mkOverride 1002 null;
        "volumeClaimTemplate" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageStorageEmptyDir" = {

      options = {
        "medium" = mkOption {
          description = "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr types.str);
        };
        "sizeLimit" = mkOption {
          description = "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir";
          type = (types.nullOr (types.either types.int types.str));
        };
      };

      config = {
        "medium" = mkOverride 1002 null;
        "sizeLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackup" = {

      options = {
        "acceptEULA" = mkOption {
          description = "AcceptEULA accepts enterprise feature usage, must be set to true.\notherwise backupmanager cannot be added to single/cluster version.\nhttps://victoriametrics.com/legal/esa/\nDeprecated: use license.key or license.keyRef instead";
          type = (types.nullOr types.bool);
        };
        "concurrency" = mkOption {
          description = "Defines number of concurrent workers. Higher concurrency may reduce backup duration (default 10)";
          type = (types.nullOr types.int);
        };
        "credentialsSecret" = mkOption {
          description = "CredentialsSecret is secret in the same namespace for access to remote storage\nThe secret is mounted into /etc/vm/creds.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupCredentialsSecret"
            )
          );
        };
        "customS3Endpoint" = mkOption {
          description = "Custom S3 endpoint for use with S3-compatible storages (e.g. MinIO). S3 is used if not set";
          type = (types.nullOr types.str);
        };
        "destination" = mkOption {
          description = "Defines destination for backup";
          type = (types.nullOr types.str);
        };
        "destinationDisableSuffixAdd" = mkOption {
          description = "DestinationDisableSuffixAdd - disables suffix adding for cluster version backups\neach vmstorage backup must have unique backup folder\nso operator adds POD_NAME as suffix for backup destination folder.";
          type = (types.nullOr types.bool);
        };
        "disableDaily" = mkOption {
          description = "Defines if daily backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "disableHourly" = mkOption {
          description = "Defines if hourly backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "disableMonthly" = mkOption {
          description = "Defines if monthly backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "disableWeekly" = mkOption {
          description = "Defines if weekly backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "extraArgs" = mkOption {
          description = "extra args like maxBytesPerSecond default 0";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsFrom"
              )
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings for VMBackuper";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupImage"
            )
          );
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMBackup to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMBackup to be configured with.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port for health check connections";
          type = (types.nullOr types.str);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupResources"
            )
          );
        };
        "restore" = mkOption {
          description = "Restore Allows to enable restore options for pod\nRead [more](https://docs.victoriametrics.com/victoriametrics/vmbackupmanager/#restore-commands)";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupRestore"
            )
          );
        };
        "snapshotCreateURL" = mkOption {
          description = "SnapshotCreateURL overwrites url for snapshot create";
          type = (types.nullOr types.str);
        };
        "snapshotDeleteURL" = mkOption {
          description = "SnapShotDeleteURL overwrites url for snapshot delete";
          type = (types.nullOr types.str);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment definition.\nVolumeMounts specified will be appended to other VolumeMounts in the vmbackupmanager container,\nthat are generated as a result of StorageSpec objects.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "acceptEULA" = mkOverride 1002 null;
        "concurrency" = mkOverride 1002 null;
        "credentialsSecret" = mkOverride 1002 null;
        "customS3Endpoint" = mkOverride 1002 null;
        "destination" = mkOverride 1002 null;
        "destinationDisableSuffixAdd" = mkOverride 1002 null;
        "disableDaily" = mkOverride 1002 null;
        "disableHourly" = mkOverride 1002 null;
        "disableMonthly" = mkOverride 1002 null;
        "disableWeekly" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "restore" = mkOverride 1002 null;
        "snapshotCreateURL" = mkOverride 1002 null;
        "snapshotDeleteURL" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupCredentialsSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
        "valueFrom" = mkOption {
          description = "Source for the environment variable's value. Cannot be used if value is not empty.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFrom"
            )
          );
        };
      };

      config = {
        "value" = mkOverride 1002 null;
        "valueFrom" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFrom" = {

      options = {
        "configMapKeyRef" = mkOption {
          description = "Selects a key of a ConfigMap.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef"
            )
          );
        };
        "fieldRef" = mkOption {
          description = "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,\nspec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef"
            )
          );
        };
        "fileKeyRef" = mkOption {
          description = "FileKeyRef selects a key of the env file.\nRequires the EnvFiles feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromFileKeyRef"
            )
          );
        };
        "resourceFieldRef" = mkOption {
          description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef"
            )
          );
        };
        "secretKeyRef" = mkOption {
          description = "Selects a key of a secret in the pod's namespace";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef"
            )
          );
        };
      };

      config = {
        "configMapKeyRef" = mkOverride 1002 null;
        "fieldRef" = mkOverride 1002 null;
        "fileKeyRef" = mkOverride 1002 null;
        "resourceFieldRef" = mkOverride 1002 null;
        "secretKeyRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromConfigMapKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromFieldRef" = {

      options = {
        "apiVersion" = mkOption {
          description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
          type = (types.nullOr types.str);
        };
        "fieldPath" = mkOption {
          description = "Path of the field to select in the specified API version.";
          type = types.str;
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromFileKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key within the env file. An invalid key will prevent the pod from starting.\nThe keys defined within a source may consist of any printable ASCII characters except '='.\nDuring Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.";
            type = types.str;
          };
          "optional" = mkOption {
            description = "Specify whether the file or its key must be defined. If the file or key\ndoes not exist, then the env var is not published.\nIf optional is set to true and the specified key does not exist,\nthe environment variable will not be set in the Pod's containers.\n\nIf optional is set to false and the specified key does not exist,\nan error will be returned during Pod creation.";
            type = (types.nullOr types.bool);
          };
          "path" = mkOption {
            description = "The path within the volume from which to select the file.\nMust be relative and may not contain the '..' path or start with '..'.";
            type = types.str;
          };
          "volumeName" = mkOption {
            description = "The name of the volume mount containing the env file.";
            type = types.str;
          };
        };

        config = {
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromResourceFieldRef" =
      {

        options = {
          "containerName" = mkOption {
            description = "Container name: required for volumes, optional for env vars";
            type = (types.nullOr types.str);
          };
          "divisor" = mkOption {
            description = "Specifies the output format of the exposed resources, defaults to \"1\"";
            type = (types.nullOr (types.either types.int types.str));
          };
          "resource" = mkOption {
            description = "Required: resource to select";
            type = types.str;
          };
        };

        config = {
          "containerName" = mkOverride 1002 null;
          "divisor" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupExtraEnvsValueFromSecretKeyRef" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupRestore" = {

      options = {
        "onStart" = mkOption {
          description = "OnStart defines configuration for restore on pod start";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupRestoreOnStart"
            )
          );
        };
      };

      config = {
        "onStart" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupRestoreOnStart" = {

      options = {
        "enabled" = mkOption {
          description = "Enabled defines if restore on start enabled";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "enabled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVmBackupVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterSpecVmstorageVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMClusterStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMClusterStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrape" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMNodeScrapeSpec defines specification for VMNodeScrape.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpec"));
        };
        "status" = mkOption {
          description = "ScrapeObjectStatus defines the observed state of ScrapeObjects";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpec" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization with http header Authorization";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecAuthorization")
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for scraping targets.";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Secret to mount to read bearer token for scraping targets. The secret\nneeds to be in the same namespace as the scrape object and accessible by\nthe victoria-metrics operator.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBearerTokenSecret")
          );
        };
        "follow_redirects" = mkOption {
          description = "FollowRedirects controls redirects for scraping.";
          type = (types.nullOr types.bool);
        };
        "honorLabels" = mkOption {
          description = "HonorLabels chooses the metric's labels on collisions with target labels.";
          type = (types.nullOr types.bool);
        };
        "honorTimestamps" = mkOption {
          description = "HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.";
          type = (types.nullOr types.bool);
        };
        "interval" = mkOption {
          description = "Interval at which metrics should be scraped";
          type = (types.nullOr types.str);
        };
        "jobLabel" = mkOption {
          description = "The label to use to retrieve the job name from.";
          type = (types.nullOr types.str);
        };
        "max_scrape_size" = mkOption {
          description = "MaxScrapeSize defines a maximum size of scraped data for a job";
          type = (types.nullOr types.str);
        };
        "metricRelabelConfigs" = mkOption {
          description = "MetricRelabelConfigs to apply to samples after scrapping.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecMetricRelabelConfigs"
              )
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2"));
        };
        "params" = mkOption {
          description = "Optional HTTP URL parameters";
          type = (types.nullOr (types.loaOf types.str));
        };
        "path" = mkOption {
          description = "HTTP path to scrape for metrics.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Name of the port exposed at Node.";
          type = (types.nullOr types.str);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "relabelConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecRelabelConfigs")
            )
          );
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scheme" = mkOption {
          description = "HTTP scheme to use for scraping.";
          type = (types.nullOr types.str);
        };
        "scrapeClass" = mkOption {
          description = "ScrapeClass defined scrape class to apply";
          type = (types.nullOr types.str);
        };
        "scrapeTimeout" = mkOption {
          description = "Timeout after which the scrape is ended";
          type = (types.nullOr types.str);
        };
        "scrape_interval" = mkOption {
          description = "ScrapeInterval is the same as Interval and has priority over it.\none of scrape_interval or interval can be used";
          type = (types.nullOr types.str);
        };
        "selector" = mkOption {
          description = "Selector to select kubernetes Nodes.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecSelector"));
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "targetLabels" = mkOption {
          description = "TargetLabels transfers labels on the Kubernetes Node onto the target.";
          type = (types.nullOr (types.listOf types.str));
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig configuration to use when scraping the endpoint";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfig")
          );
        };
        "vm_scrape_params" = mkOption {
          description = "VMScrapeParams defines VictoriaMetrics specific scrape parameters";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_params")
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "follow_redirects" = mkOverride 1002 null;
        "honorLabels" = mkOverride 1002 null;
        "honorTimestamps" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "jobLabel" = mkOverride 1002 null;
        "max_scrape_size" = mkOverride 1002 null;
        "metricRelabelConfigs" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "relabelConfigs" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "scrapeClass" = mkOverride 1002 null;
        "scrapeTimeout" = mkOverride 1002 null;
        "scrape_interval" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
        "targetLabels" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "vm_scrape_params" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBasicAuthPassword")
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBasicAuthUsername")
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_id");
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCa")
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCert")
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigKeySecret")
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCaSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_params" = {

      options = {
        "disable_compression" = mkOption {
          description = "DisableCompression";
          type = (types.nullOr types.bool);
        };
        "disable_keep_alive" = mkOption {
          description = "disable_keepalive allows disabling HTTP keep-alive when scraping targets.\nBy default, HTTP keep-alive is enabled, so TCP connections to scrape targets\ncould be reused.\nSee https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers allows sending custom headers to scrape targets\nmust be in of semicolon separated header with it's value\neg:\nheaderName: headerValue\nvmagent supports since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "no_stale_markers" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_config"
            )
          );
        };
        "scrape_align_interval" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "scrape_offset" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "stream_parse" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disable_compression" = mkOverride 1002 null;
        "disable_keep_alive" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "no_stale_markers" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "scrape_align_interval" = mkOverride 1002 null;
        "scrape_offset" = mkOverride 1002 null;
        "stream_parse" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_config" = {

      options = {
        "basic_auth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBasic_auth"
            )
          );
        };
        "bearer_token" = mkOption {
          description = "SecretKeySelector selects a key of a Secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBearer_token"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "basic_auth" = mkOverride 1002 null;
        "bearer_token" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeSpecVm_scrape_paramsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMNodeScrapeStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMNodeScrapeStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrape" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMPodScrapeSpec defines the desired state of VMPodScrape";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpec"));
        };
        "status" = mkOption {
          description = "ScrapeObjectStatus defines the observed state of ScrapeObjects";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpec" = {

      options = {
        "attach_metadata" = mkOption {
          description = "AttachMetadata configures metadata attaching from service discovery";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecAttach_metadata")
          );
        };
        "jobLabel" = mkOption {
          description = "The label to use to retrieve the job name from.";
          type = (types.nullOr types.str);
        };
        "namespaceSelector" = mkOption {
          description = "Selector to select which namespaces the Endpoints objects are discovered from.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecNamespaceSelector")
          );
        };
        "podMetricsEndpoints" = mkOption {
          description = "A list of endpoints allowed as part of this PodMonitor.";
          type = (
            types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpoints")
          );
        };
        "podTargetLabels" = mkOption {
          description = "PodTargetLabels transfers labels on the Kubernetes Pod onto the target.";
          type = (types.nullOr (types.listOf types.str));
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scrapeClass" = mkOption {
          description = "ScrapeClass defined scrape class to apply";
          type = (types.nullOr types.str);
        };
        "selector" = mkOption {
          description = "Selector to select Pod objects.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecSelector"));
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "attach_metadata" = mkOverride 1002 null;
        "jobLabel" = mkOverride 1002 null;
        "namespaceSelector" = mkOverride 1002 null;
        "podTargetLabels" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scrapeClass" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecAttach_metadata" = {

      options = {
        "node" = mkOption {
          description = "Node instructs vmagent to add node specific metadata from service discovery\nValid for roles: pod, endpoints, endpointslice.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "node" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecNamespaceSelector" = {

      options = {
        "any" = mkOption {
          description = "Boolean describing whether all namespaces are selected in contrast to a\nlist restricting them.";
          type = (types.nullOr types.bool);
        };
        "matchNames" = mkOption {
          description = "List of namespace names.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "any" = mkOverride 1002 null;
        "matchNames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpoints" = {

      options = {
        "attach_metadata" = mkOption {
          description = "AttachMetadata configures metadata attaching from service discovery";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsAttach_metadata"
            )
          );
        };
        "authorization" = mkOption {
          description = "Authorization with http header Authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBasicAuth"
            )
          );
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for scraping targets.";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Secret to mount to read bearer token for scraping targets. The secret\nneeds to be in the same namespace as the scrape object and accessible by\nthe victoria-metrics operator.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBearerTokenSecret"
            )
          );
        };
        "filterRunning" = mkOption {
          description = "FilterRunning applies filter with pod status == running\nit prevents from scrapping metrics at failed or succeed state pods.\nenabled by default";
          type = (types.nullOr types.bool);
        };
        "follow_redirects" = mkOption {
          description = "FollowRedirects controls redirects for scraping.";
          type = (types.nullOr types.bool);
        };
        "honorLabels" = mkOption {
          description = "HonorLabels chooses the metric's labels on collisions with target labels.";
          type = (types.nullOr types.bool);
        };
        "honorTimestamps" = mkOption {
          description = "HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.";
          type = (types.nullOr types.bool);
        };
        "interval" = mkOption {
          description = "Interval at which metrics should be scraped";
          type = (types.nullOr types.str);
        };
        "max_scrape_size" = mkOption {
          description = "MaxScrapeSize defines a maximum size of scraped data for a job";
          type = (types.nullOr types.str);
        };
        "metricRelabelConfigs" = mkOption {
          description = "MetricRelabelConfigs to apply to samples after scrapping.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs"
              )
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2"
            )
          );
        };
        "params" = mkOption {
          description = "Optional HTTP URL parameters";
          type = (types.nullOr (types.loaOf types.str));
        };
        "path" = mkOption {
          description = "HTTP path to scrape for metrics.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Name of the port exposed at Pod.";
          type = (types.nullOr types.str);
        };
        "portNumber" = mkOption {
          description = "PortNumber defines the `Pod` port number which exposes the endpoint.";
          type = (types.nullOr types.int);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "relabelConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsRelabelConfigs"
              )
            )
          );
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scheme" = mkOption {
          description = "HTTP scheme to use for scraping.";
          type = (types.nullOr types.str);
        };
        "scrapeTimeout" = mkOption {
          description = "Timeout after which the scrape is ended";
          type = (types.nullOr types.str);
        };
        "scrape_interval" = mkOption {
          description = "ScrapeInterval is the same as Interval and has priority over it.\none of scrape_interval or interval can be used";
          type = (types.nullOr types.str);
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "targetPort" = mkOption {
          description = "TargetPort defines name or number of the pod port this endpoint refers to.\nMutually exclusive with Port and PortNumber.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig configuration to use when scraping the endpoint";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfig"
            )
          );
        };
        "vm_scrape_params" = mkOption {
          description = "VMScrapeParams defines VictoriaMetrics specific scrape parameters";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_params"
            )
          );
        };
      };

      config = {
        "attach_metadata" = mkOverride 1002 null;
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "filterRunning" = mkOverride 1002 null;
        "follow_redirects" = mkOverride 1002 null;
        "honorLabels" = mkOverride 1002 null;
        "honorTimestamps" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "max_scrape_size" = mkOverride 1002 null;
        "metricRelabelConfigs" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "portNumber" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "relabelConfigs" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "scrapeTimeout" = mkOverride 1002 null;
        "scrape_interval" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
        "targetPort" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "vm_scrape_params" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsAttach_metadata" = {

      options = {
        "node" = mkOption {
          description = "Node instructs vmagent to add node specific metadata from service discovery\nValid for roles: pod, endpoints, endpointslice.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "node" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_id"
          );
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_params" = {

      options = {
        "disable_compression" = mkOption {
          description = "DisableCompression";
          type = (types.nullOr types.bool);
        };
        "disable_keep_alive" = mkOption {
          description = "disable_keepalive allows disabling HTTP keep-alive when scraping targets.\nBy default, HTTP keep-alive is enabled, so TCP connections to scrape targets\ncould be reused.\nSee https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers allows sending custom headers to scrape targets\nmust be in of semicolon separated header with it's value\neg:\nheaderName: headerValue\nvmagent supports since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "no_stale_markers" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_config"
            )
          );
        };
        "scrape_align_interval" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "scrape_offset" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "stream_parse" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disable_compression" = mkOverride 1002 null;
        "disable_keep_alive" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "no_stale_markers" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "scrape_align_interval" = mkOverride 1002 null;
        "scrape_offset" = mkOverride 1002 null;
        "stream_parse" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_config" =
      {

        options = {
          "basic_auth" = mkOption {
            description = "BasicAuth allow an endpoint to authenticate over basic authentication";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBasic_auth"
              )
            );
          };
          "bearer_token" = mkOption {
            description = "SecretKeySelector selects a key of a Secret.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBearer_token"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "";
            type = (types.nullOr types.attrs);
          };
        };

        config = {
          "basic_auth" = mkOverride 1002 null;
          "bearer_token" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecPodMetricsEndpointsVm_scrape_paramsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeSpecSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMPodScrapeStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMPodScrapeStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbe" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMProbeSpec contains specification parameters for a Probe.";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpec");
        };
        "status" = mkOption {
          description = "ScrapeObjectStatus defines the observed state of ScrapeObjects";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpec" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization with http header Authorization";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecAuthorization"));
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecBasicAuth"));
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for scraping targets.";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Secret to mount to read bearer token for scraping targets. The secret\nneeds to be in the same namespace as the scrape object and accessible by\nthe victoria-metrics operator.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecBearerTokenSecret")
          );
        };
        "follow_redirects" = mkOption {
          description = "FollowRedirects controls redirects for scraping.";
          type = (types.nullOr types.bool);
        };
        "honorLabels" = mkOption {
          description = "HonorLabels chooses the metric's labels on collisions with target labels.";
          type = (types.nullOr types.bool);
        };
        "honorTimestamps" = mkOption {
          description = "HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.";
          type = (types.nullOr types.bool);
        };
        "interval" = mkOption {
          description = "Interval at which metrics should be scraped";
          type = (types.nullOr types.str);
        };
        "jobName" = mkOption {
          description = "The job name assigned to scraped metrics by default.";
          type = (types.nullOr types.str);
        };
        "max_scrape_size" = mkOption {
          description = "MaxScrapeSize defines a maximum size of scraped data for a job";
          type = (types.nullOr types.str);
        };
        "metricRelabelConfigs" = mkOption {
          description = "MetricRelabelConfigs to apply to samples after scrapping.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecMetricRelabelConfigs")
            )
          );
        };
        "module" = mkOption {
          description = "The module to use for probing specifying how to probe the target.\nExample module configuring in the blackbox exporter:\nhttps://github.com/prometheus/blackbox_exporter/blob/master/example.yml";
          type = (types.nullOr types.str);
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2"));
        };
        "params" = mkOption {
          description = "Optional HTTP URL parameters";
          type = (types.nullOr (types.loaOf types.str));
        };
        "path" = mkOption {
          description = "HTTP path to scrape for metrics.";
          type = (types.nullOr types.str);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scheme" = mkOption {
          description = "HTTP scheme to use for scraping.";
          type = (types.nullOr types.str);
        };
        "scrapeClass" = mkOption {
          description = "ScrapeClass defined scrape class to apply";
          type = (types.nullOr types.str);
        };
        "scrapeTimeout" = mkOption {
          description = "Timeout after which the scrape is ended";
          type = (types.nullOr types.str);
        };
        "scrape_interval" = mkOption {
          description = "ScrapeInterval is the same as Interval and has priority over it.\none of scrape_interval or interval can be used";
          type = (types.nullOr types.str);
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "targets" = mkOption {
          description = "Targets defines a set of static and/or dynamically discovered targets to be probed using the prober.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargets"));
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig configuration to use when scraping the endpoint";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfig"));
        };
        "vmProberSpec" = mkOption {
          description = "Specification for the prober to use for probing targets.\nThe prober.URL parameter is required. Targets cannot be probed if left empty.";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecVmProberSpec");
        };
        "vm_scrape_params" = mkOption {
          description = "VMScrapeParams defines VictoriaMetrics specific scrape parameters";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_params")
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "follow_redirects" = mkOverride 1002 null;
        "honorLabels" = mkOverride 1002 null;
        "honorTimestamps" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "jobName" = mkOverride 1002 null;
        "max_scrape_size" = mkOverride 1002 null;
        "metricRelabelConfigs" = mkOverride 1002 null;
        "module" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "scrapeClass" = mkOverride 1002 null;
        "scrapeTimeout" = mkOverride 1002 null;
        "scrape_interval" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
        "targets" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "vm_scrape_params" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecBasicAuthPassword")
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecBasicAuthUsername")
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_id");
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_secret")
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_idSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargets" = {

      options = {
        "ingress" = mkOption {
          description = "Ingress defines the set of dynamically discovered ingress objects which hosts are considered for probing.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngress")
          );
        };
        "staticConfig" = mkOption {
          description = "StaticConfig defines static targets which are considers for probing.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsStaticConfig")
          );
        };
      };

      config = {
        "ingress" = mkOverride 1002 null;
        "staticConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngress" = {

      options = {
        "namespaceSelector" = mkOption {
          description = "Select Ingress objects by namespace.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressNamespaceSelector"
            )
          );
        };
        "relabelingConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressRelabelingConfigs"
              )
            )
          );
        };
        "selector" = mkOption {
          description = "Select Ingress objects by labels.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressSelector")
          );
        };
      };

      config = {
        "namespaceSelector" = mkOverride 1002 null;
        "relabelingConfigs" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressNamespaceSelector" = {

      options = {
        "any" = mkOption {
          description = "Boolean describing whether all namespaces are selected in contrast to a\nlist restricting them.";
          type = (types.nullOr types.bool);
        };
        "matchNames" = mkOption {
          description = "List of namespace names.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "any" = mkOverride 1002 null;
        "matchNames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressRelabelingConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsIngressSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsStaticConfig" = {

      options = {
        "labels" = mkOption {
          description = "Labels assigned to all metrics scraped from the targets.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "relabelingConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsStaticConfigRelabelingConfigs"
              )
            )
          );
        };
        "targets" = mkOption {
          description = "Targets is a list of URLs to probe using the configured prober.";
          type = (types.listOf types.str);
        };
      };

      config = {
        "labels" = mkOverride 1002 null;
        "relabelingConfigs" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTargetsStaticConfigRelabelingConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCa"));
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCert"));
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigKeySecret")
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCaConfigMap")
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCaSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCertConfigMap")
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCertSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecVmProberSpec" = {

      options = {
        "path" = mkOption {
          description = "Path to collect metrics from.\nDefaults to `/probe`.";
          type = (types.nullOr types.str);
        };
        "scheme" = mkOption {
          description = "HTTP scheme to use for scraping.\nDefaults to `http`.";
          type = (types.nullOr types.str);
        };
        "url" = mkOption {
          description = "Mandatory URL of the prober.";
          type = types.str;
        };
      };

      config = {
        "path" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_params" = {

      options = {
        "disable_compression" = mkOption {
          description = "DisableCompression";
          type = (types.nullOr types.bool);
        };
        "disable_keep_alive" = mkOption {
          description = "disable_keepalive allows disabling HTTP keep-alive when scraping targets.\nBy default, HTTP keep-alive is enabled, so TCP connections to scrape targets\ncould be reused.\nSee https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers allows sending custom headers to scrape targets\nmust be in of semicolon separated header with it's value\neg:\nheaderName: headerValue\nvmagent supports since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "no_stale_markers" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_config"
            )
          );
        };
        "scrape_align_interval" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "scrape_offset" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "stream_parse" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disable_compression" = mkOverride 1002 null;
        "disable_keep_alive" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "no_stale_markers" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "scrape_align_interval" = mkOverride 1002 null;
        "scrape_offset" = mkOverride 1002 null;
        "stream_parse" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_config" = {

      options = {
        "basic_auth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBasic_auth"
            )
          );
        };
        "bearer_token" = mkOption {
          description = "SecretKeySelector selects a key of a Secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBearer_token"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "basic_auth" = mkOverride 1002 null;
        "bearer_token" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBasic_auth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBasic_authPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBasic_authUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMProbeSpecVm_scrape_paramsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMProbeStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMProbeStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMProbeStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMRule" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMRuleSpec defines the desired state of VMRule";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMRuleSpec");
        };
        "status" = mkOption {
          description = "VMRuleStatus defines the observed state of VMRule";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMRuleStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMRuleSpec" = {

      options = {
        "groups" = mkOption {
          description = "Groups list of group rules";
          type = (
            coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMRuleSpecGroups" "name"
              [ ]
          );
          apply = attrsToList;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMRuleSpecGroups" = {

      options = {
        "concurrency" = mkOption {
          description = "Concurrency defines how many rules execute at once.";
          type = (types.nullOr types.int);
        };
        "eval_alignment" = mkOption {
          description = "Optional\nThe evaluation timestamp will be aligned with group's interval,\ninstead of using the actual timestamp that evaluation happens at.\nIt is enabled by default to get more predictable results\nand to visually align with graphs plotted via Grafana or vmui.";
          type = (types.nullOr types.bool);
        };
        "eval_delay" = mkOption {
          description = "Optional\nAdjust the `time` parameter of group evaluation requests to compensate intentional query delay from the datasource.";
          type = (types.nullOr types.str);
        };
        "eval_offset" = mkOption {
          description = "Optional\nGroup will be evaluated at the exact offset in the range of [0...interval].";
          type = (types.nullOr types.str);
        };
        "extra_filter_labels" = mkOption {
          description = "ExtraFilterLabels optional list of label filters applied to every rule's\nrequest within a group. Is compatible only with VM datasource.\nSee more details [here](https://docs.victoriametrics.com/victoriametrics/#prometheus-querying-api-enhancements)\nDeprecated: use params instead";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "headers" = mkOption {
          description = "Headers contains optional HTTP headers added to each rule request\nMust be in form `header-name: value`\nFor example:\n headers:\n   - \"CustomHeader: foo\"\n   - \"CustomHeader2: bar\"";
          type = (types.nullOr (types.listOf types.str));
        };
        "interval" = mkOption {
          description = "evaluation interval for group";
          type = (types.nullOr types.str);
        };
        "labels" = mkOption {
          description = "Labels optional list of labels added to every rule within a group.\nIt has priority over the external labels.\nLabels are commonly used for adding environment\nor tenant-specific tag.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "limit" = mkOption {
          description = "Limit the number of alerts an alerting rule and series a recording\nrule can produce";
          type = (types.nullOr types.int);
        };
        "name" = mkOption {
          description = "Name of group";
          type = types.str;
        };
        "notifier_headers" = mkOption {
          description = "NotifierHeaders contains optional HTTP headers added to each alert request which will send to notifier\nMust be in form `header-name: value`\nFor example:\n headers:\n   - \"CustomHeader: foo\"\n   - \"CustomHeader2: bar\"";
          type = (types.nullOr (types.listOf types.str));
        };
        "params" = mkOption {
          description = "Params optional HTTP URL parameters added to each rule request";
          type = (types.nullOr (types.loaOf types.str));
        };
        "rules" = mkOption {
          description = "Rules list of alert rules";
          type = (types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMRuleSpecGroupsRules"));
        };
        "tenant" = mkOption {
          description = "Tenant id for group, can be used only with enterprise version of vmalert.\nSee more details [here](https://docs.victoriametrics.com/victoriametrics/vmalert/#multitenancy).";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type defines datasource type for enterprise version of vmalert\npossible values - prometheus,graphite,vlogs";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "concurrency" = mkOverride 1002 null;
        "eval_alignment" = mkOverride 1002 null;
        "eval_delay" = mkOverride 1002 null;
        "eval_offset" = mkOverride 1002 null;
        "extra_filter_labels" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "limit" = mkOverride 1002 null;
        "notifier_headers" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
        "tenant" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMRuleSpecGroupsRules" = {

      options = {
        "alert" = mkOption {
          description = "Alert is a name for alert";
          type = (types.nullOr types.str);
        };
        "annotations" = mkOption {
          description = "Annotations will be added to rule configuration";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "debug" = mkOption {
          description = "Debug enables logging for rule\nit useful for tracking";
          type = (types.nullOr types.bool);
        };
        "expr" = mkOption {
          description = "Expr is query, that will be evaluated at dataSource";
          type = (types.nullOr types.str);
        };
        "for" = mkOption {
          description = "For evaluation interval in time.Duration format\n30s, 1m, 1h  or nanoseconds";
          type = (types.nullOr types.str);
        };
        "keep_firing_for" = mkOption {
          description = "KeepFiringFor will make alert continue firing for this long\neven when the alerting expression no longer has results.\nUse time.Duration format, 30s, 1m, 1h  or nanoseconds";
          type = (types.nullOr types.str);
        };
        "labels" = mkOption {
          description = "Labels will be added to rule configuration";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "record" = mkOption {
          description = "Record represents a query, that will be recorded to dataSource";
          type = (types.nullOr types.str);
        };
        "update_entries_limit" = mkOption {
          description = "UpdateEntriesLimit defines max number of rule's state updates stored in memory.\nOverrides `-rule.updateEntriesLimit` in vmalert.";
          type = (types.nullOr types.int);
        };
      };

      config = {
        "alert" = mkOverride 1002 null;
        "annotations" = mkOverride 1002 null;
        "debug" = mkOverride 1002 null;
        "expr" = mkOverride 1002 null;
        "for" = mkOverride 1002 null;
        "keep_firing_for" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "record" = mkOverride 1002 null;
        "update_entries_limit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMRuleStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMRuleStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMRuleStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfig" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMScrapeConfigSpec defines the desired state of VMScrapeConfig";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpec"));
        };
        "status" = mkOption {
          description = "ScrapeObjectStatus defines the observed state of ScrapeObjects";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpec" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization with http header Authorization";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAuthorization")
          );
        };
        "azureSDConfigs" = mkOption {
          description = "AzureSDConfigs defines a list of Azure service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAzureSDConfigs")
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBasicAuth")
          );
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for scraping targets.";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Secret to mount to read bearer token for scraping targets. The secret\nneeds to be in the same namespace as the scrape object and accessible by\nthe victoria-metrics operator.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBearerTokenSecret"
            )
          );
        };
        "consulSDConfigs" = mkOption {
          description = "ConsulSDConfigs defines a list of Consul service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigs")
            )
          );
        };
        "digitalOceanSDConfigs" = mkOption {
          description = "DigitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigs"
              )
            )
          );
        };
        "dnsSDConfigs" = mkOption {
          description = "DNSSDConfigs defines a list of DNS service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDnsSDConfigs")
            )
          );
        };
        "ec2SDConfigs" = mkOption {
          description = "EC2SDConfigs defines a list of EC2 service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigs")
            )
          );
        };
        "fileSDConfigs" = mkOption {
          description = "FileSDConfigs defines a list of file service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecFileSDConfigs")
            )
          );
        };
        "follow_redirects" = mkOption {
          description = "FollowRedirects controls redirects for scraping.";
          type = (types.nullOr types.bool);
        };
        "gceSDConfigs" = mkOption {
          description = "GCESDConfigs defines a list of GCE service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecGceSDConfigs")
            )
          );
        };
        "honorLabels" = mkOption {
          description = "HonorLabels chooses the metric's labels on collisions with target labels.";
          type = (types.nullOr types.bool);
        };
        "honorTimestamps" = mkOption {
          description = "HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.";
          type = (types.nullOr types.bool);
        };
        "httpSDConfigs" = mkOption {
          description = "HTTPSDConfigs defines a list of HTTP service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigs")
            )
          );
        };
        "interval" = mkOption {
          description = "Interval at which metrics should be scraped";
          type = (types.nullOr types.str);
        };
        "kubernetesSDConfigs" = mkOption {
          description = "KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigs"
              )
            )
          );
        };
        "max_scrape_size" = mkOption {
          description = "MaxScrapeSize defines a maximum size of scraped data for a job";
          type = (types.nullOr types.str);
        };
        "metricRelabelConfigs" = mkOption {
          description = "MetricRelabelConfigs to apply to samples after scrapping.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecMetricRelabelConfigs"
              )
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2"));
        };
        "openstackSDConfigs" = mkOption {
          description = "OpenStackSDConfigs defines a list of OpenStack service discovery configurations.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigs"
              )
            )
          );
        };
        "params" = mkOption {
          description = "Optional HTTP URL parameters";
          type = (types.nullOr (types.loaOf types.str));
        };
        "path" = mkOption {
          description = "HTTP path to scrape for metrics.";
          type = (types.nullOr types.str);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "relabelConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecRelabelConfigs")
            )
          );
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scheme" = mkOption {
          description = "HTTP scheme to use for scraping.";
          type = (types.nullOr types.str);
        };
        "scrapeClass" = mkOption {
          description = "ScrapeClass defined scrape class to apply";
          type = (types.nullOr types.str);
        };
        "scrapeTimeout" = mkOption {
          description = "Timeout after which the scrape is ended";
          type = (types.nullOr types.str);
        };
        "scrape_interval" = mkOption {
          description = "ScrapeInterval is the same as Interval and has priority over it.\none of scrape_interval or interval can be used";
          type = (types.nullOr types.str);
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "staticConfigs" = mkOption {
          description = "StaticConfigs defines a list of static targets with a common label set.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecStaticConfigs")
            )
          );
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig configuration to use when scraping the endpoint";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfig")
          );
        };
        "vm_scrape_params" = mkOption {
          description = "VMScrapeParams defines VictoriaMetrics specific scrape parameters";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_params")
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "azureSDConfigs" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "consulSDConfigs" = mkOverride 1002 null;
        "digitalOceanSDConfigs" = mkOverride 1002 null;
        "dnsSDConfigs" = mkOverride 1002 null;
        "ec2SDConfigs" = mkOverride 1002 null;
        "fileSDConfigs" = mkOverride 1002 null;
        "follow_redirects" = mkOverride 1002 null;
        "gceSDConfigs" = mkOverride 1002 null;
        "honorLabels" = mkOverride 1002 null;
        "honorTimestamps" = mkOverride 1002 null;
        "httpSDConfigs" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "kubernetesSDConfigs" = mkOverride 1002 null;
        "max_scrape_size" = mkOverride 1002 null;
        "metricRelabelConfigs" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "openstackSDConfigs" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "relabelConfigs" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "scrapeClass" = mkOverride 1002 null;
        "scrapeTimeout" = mkOverride 1002 null;
        "scrape_interval" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
        "staticConfigs" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "vm_scrape_params" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAzureSDConfigs" = {

      options = {
        "authenticationMethod" = mkOption {
          description = "# The authentication method, either OAuth or ManagedIdentity.\nSee https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview";
          type = (types.nullOr types.str);
        };
        "clientID" = mkOption {
          description = "Optional client ID. Only required with the OAuth authentication method.";
          type = (types.nullOr types.str);
        };
        "clientSecret" = mkOption {
          description = "Optional client secret. Only required with the OAuth authentication method.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAzureSDConfigsClientSecret"
            )
          );
        };
        "environment" = mkOption {
          description = "The Azure environment.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "The port to scrape metrics from. If using the public IP address, this must\ninstead be specified in the relabeling rule.";
          type = (types.nullOr types.int);
        };
        "resourceGroup" = mkOption {
          description = "Optional resource group name. Limits discovery to this resource group.";
          type = (types.nullOr types.str);
        };
        "subscriptionID" = mkOption {
          description = "The subscription ID. Always required.";
          type = types.str;
        };
        "tenantID" = mkOption {
          description = "Optional tenant ID. Only required with the OAuth authentication method.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "authenticationMethod" = mkOverride 1002 null;
        "clientID" = mkOverride 1002 null;
        "clientSecret" = mkOverride 1002 null;
        "environment" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "resourceGroup" = mkOverride 1002 null;
        "tenantID" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecAzureSDConfigsClientSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigs" = {

      options = {
        "allowStale" = mkOption {
          description = "Allow stale Consul results (see https://developer.hashicorp.com/consul/api-docs/features/consistency ). Will reduce load on Consul.\nIf unset, use its default value.";
          type = (types.nullOr types.bool);
        };
        "authorization" = mkOption {
          description = "Authorization header to use on every scrape request.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth information to use on every scrape request.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsBasicAuth"
            )
          );
        };
        "datacenter" = mkOption {
          description = "Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.";
          type = (types.nullOr types.str);
        };
        "filter" = mkOption {
          description = "Filter defines filter for /v1/catalog/services requests\nSee https://developer.hashicorp.com/consul/api-docs/features/filtering";
          type = (types.nullOr types.str);
        };
        "followRedirects" = mkOption {
          description = "Configure whether HTTP requests follow HTTP 3xx redirects.\nIf unset, use its default value.";
          type = (types.nullOr types.bool);
        };
        "namespace" = mkOption {
          description = "Namespaces are only supported in Consul Enterprise.";
          type = (types.nullOr types.str);
        };
        "nodeMeta" = mkOption {
          description = "Node metadata key/value pairs to filter nodes for a given service.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2"
            )
          );
        };
        "partition" = mkOption {
          description = "Admin Partitions are only supported in Consul Enterprise.";
          type = (types.nullOr types.str);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_config"
            )
          );
        };
        "scheme" = mkOption {
          description = "HTTP Scheme default \"http\"";
          type = (types.nullOr types.str);
        };
        "server" = mkOption {
          description = "A valid string consisting of a hostname or IP followed by an optional port number.";
          type = types.str;
        };
        "services" = mkOption {
          description = "A list of services for which targets are retrieved. If omitted, all services are scraped.";
          type = (types.nullOr (types.listOf types.str));
        };
        "tagSeparator" = mkOption {
          description = "The string by which Consul tags are joined into the tag label.\nIf unset, use its default value.";
          type = (types.nullOr types.str);
        };
        "tags" = mkOption {
          description = "An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.";
          type = (types.nullOr (types.listOf types.str));
        };
        "tlsConfig" = mkOption {
          description = "TLS configuration to use on every scrape request";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfig"
            )
          );
        };
        "tokenRef" = mkOption {
          description = "Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTokenRef"
            )
          );
        };
      };

      config = {
        "allowStale" = mkOverride 1002 null;
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "datacenter" = mkOverride 1002 null;
        "filter" = mkOverride 1002 null;
        "followRedirects" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
        "nodeMeta" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "partition" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "services" = mkOverride 1002 null;
        "tagSeparator" = mkOverride 1002 null;
        "tags" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "tokenRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_id"
          );
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_config" = {

      options = {
        "basic_auth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBasic_auth"
            )
          );
        };
        "bearer_token" = mkOption {
          description = "SecretKeySelector selects a key of a Secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBearer_token"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "basic_auth" = mkOverride 1002 null;
        "bearer_token" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecConsulSDConfigsTokenRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigs" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization header to use on every scrape request.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsAuthorization"
            )
          );
        };
        "followRedirects" = mkOption {
          description = "Configure whether HTTP requests follow HTTP 3xx redirects.";
          type = (types.nullOr types.bool);
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2"
            )
          );
        };
        "port" = mkOption {
          description = "The port to scrape metrics from.";
          type = (types.nullOr types.int);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_config"
            )
          );
        };
        "tlsConfig" = mkOption {
          description = "TLS configuration to use on every scrape request";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfig"
            )
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "followRedirects" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_id"
          );
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsOauth2Client_secret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_config" =
      {

        options = {
          "basic_auth" = mkOption {
            description = "BasicAuth allow an endpoint to authenticate over basic authentication";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBasic_auth"
              )
            );
          };
          "bearer_token" = mkOption {
            description = "SecretKeySelector selects a key of a Secret.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBearer_token"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "";
            type = (types.nullOr types.attrs);
          };
        };

        config = {
          "basic_auth" = mkOverride 1002 null;
          "bearer_token" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCaConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigCertSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDigitalOceanSDConfigsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecDnsSDConfigs" = {

      options = {
        "names" = mkOption {
          description = "A list of DNS domain names to be queried.";
          type = (types.listOf types.str);
        };
        "port" = mkOption {
          description = "The port number used if the query type is not SRV\nIgnored for SRV records";
          type = (types.nullOr types.int);
        };
        "type" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "port" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigs" = {

      options = {
        "accessKey" = mkOption {
          description = "AccessKey is the AWS API key.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigsAccessKey"
            )
          );
        };
        "filters" = mkOption {
          description = "Filters can be used optionally to filter the instance list by other criteria.\nAvailable filter criteria can be found here:\nhttps://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html\nFilter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigsFilters"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "port" = mkOption {
          description = "The port to scrape metrics from. If using the public IP address, this must\ninstead be specified in the relabeling rule.";
          type = (types.nullOr types.int);
        };
        "region" = mkOption {
          description = "The AWS region";
          type = (types.nullOr types.str);
        };
        "roleARN" = mkOption {
          description = "AWS Role ARN, an alternative to using AWS API keys.";
          type = (types.nullOr types.str);
        };
        "secretKey" = mkOption {
          description = "SecretKey is the AWS API secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigsSecretKey"
            )
          );
        };
      };

      config = {
        "accessKey" = mkOverride 1002 null;
        "filters" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "region" = mkOverride 1002 null;
        "roleARN" = mkOverride 1002 null;
        "secretKey" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigsAccessKey" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigsFilters" = {

      options = {
        "name" = mkOption {
          description = "";
          type = types.str;
        };
        "values" = mkOption {
          description = "";
          type = (types.listOf types.str);
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecEc2SDConfigsSecretKey" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecFileSDConfigs" = {

      options = {
        "files" = mkOption {
          description = "List of files to be used for file discovery.";
          type = (types.listOf types.str);
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecGceSDConfigs" = {

      options = {
        "filter" = mkOption {
          description = "Filter can be used optionally to filter the instance list by other criteria\nSyntax of this filter is described in the filter query parameter section:\nhttps://cloud.google.com/compute/docs/reference/latest/instances/list";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "The port to scrape metrics from. If using the public IP address, this must\ninstead be specified in the relabeling rule.";
          type = (types.nullOr types.int);
        };
        "project" = mkOption {
          description = "The Google Cloud Project ID";
          type = types.str;
        };
        "tagSeparator" = mkOption {
          description = "The tag separator is used to separate the tags on concatenation";
          type = (types.nullOr types.str);
        };
        "zone" = mkOption {
          description = "The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.";
          type = types.attrs;
        };
      };

      config = {
        "filter" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "tagSeparator" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigs" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization header to use on every scrape request.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth information to use on every scrape request.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsBasicAuth"
            )
          );
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_config"
            )
          );
        };
        "tlsConfig" = mkOption {
          description = "TLS configuration to use on every scrape request";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfig"
            )
          );
        };
        "url" = mkOption {
          description = "URL from which the targets are fetched.";
          type = types.str;
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_config" = {

      options = {
        "basic_auth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBasic_auth"
            )
          );
        };
        "bearer_token" = mkOption {
          description = "SecretKeySelector selects a key of a Secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBearer_token"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "basic_auth" = mkOverride 1002 null;
        "bearer_token" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecHttpSDConfigsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigs" = {

      options = {
        "apiServer" = mkOption {
          description = "The API server address consisting of a hostname or IP address followed\nby an optional port number.\nIf left empty, assuming process is running inside\nof the cluster. It will discover API servers automatically and use the pod's\nCA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.";
          type = (types.nullOr types.str);
        };
        "attach_metadata" = mkOption {
          description = "AttachMetadata configures metadata attaching from service discovery";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsAttach_metadata"
            )
          );
        };
        "authorization" = mkOption {
          description = "Authorization header to use on every scrape request.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth information to use on every scrape request.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsBasicAuth"
            )
          );
        };
        "followRedirects" = mkOption {
          description = "Configure whether HTTP requests follow HTTP 3xx redirects.";
          type = (types.nullOr types.bool);
        };
        "namespaces" = mkOption {
          description = "Optional namespace discovery. If omitted, discover targets across all namespaces.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsNamespaces"
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2"
            )
          );
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee [feature description](https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy)";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_config"
            )
          );
        };
        "role" = mkOption {
          description = "Role of the Kubernetes entities that should be discovered.";
          type = types.str;
        };
        "selectors" = mkOption {
          description = "Selector to select objects.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsSelectors"
              )
            )
          );
        };
        "tlsConfig" = mkOption {
          description = "TLS configuration to use on every scrape request";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfig"
            )
          );
        };
      };

      config = {
        "apiServer" = mkOverride 1002 null;
        "attach_metadata" = mkOverride 1002 null;
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "followRedirects" = mkOverride 1002 null;
        "namespaces" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "selectors" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsAttach_metadata" = {

      options = {
        "node" = mkOption {
          description = "Node instructs vmagent to add node specific metadata from service discovery\nValid for roles: pod, endpoints, endpointslice.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "node" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsAuthorizationCredentials" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsNamespaces" = {

      options = {
        "names" = mkOption {
          description = "List of namespaces where to watch for resources.\nIf empty and `ownNamespace` isn't true, watch for resources in all namespaces.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ownNamespace" = mkOption {
          description = "Includes the namespace in which the pod exists to the list of watched namespaces.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "names" = mkOverride 1002 null;
        "ownNamespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_id"
          );
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_idConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_idSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_config" = {

      options = {
        "basic_auth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBasic_auth"
            )
          );
        };
        "bearer_token" = mkOption {
          description = "SecretKeySelector selects a key of a Secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBearer_token"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "basic_auth" = mkOverride 1002 null;
        "bearer_token" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsSelectors" = {

      options = {
        "field" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "label" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "role" = mkOption {
          description = "";
          type = types.str;
        };
      };

      config = {
        "field" = mkOverride 1002 null;
        "label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecKubernetesSDConfigsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_id");
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigs" = {

      options = {
        "allTenants" = mkOption {
          description = "Whether the service discovery should list all instances for all projects.\nIt is only relevant for the 'instance' role and usually requires admin permissions.";
          type = (types.nullOr types.bool);
        };
        "applicationCredentialId" = mkOption {
          description = "ApplicationCredentialID";
          type = (types.nullOr types.str);
        };
        "applicationCredentialName" = mkOption {
          description = "The ApplicationCredentialID or ApplicationCredentialName fields are\nrequired if using an application credential to authenticate. Some providers\nallow you to create an application credential to authenticate rather than a\npassword.";
          type = (types.nullOr types.str);
        };
        "applicationCredentialSecret" = mkOption {
          description = "The applicationCredentialSecret field is required if using an application\ncredential to authenticate.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsApplicationCredentialSecret"
            )
          );
        };
        "availability" = mkOption {
          description = "Availability of the endpoint to connect to.";
          type = (types.nullOr types.str);
        };
        "domainID" = mkOption {
          description = "DomainID";
          type = (types.nullOr types.str);
        };
        "domainName" = mkOption {
          description = "At most one of domainId and domainName must be provided if using username\nwith Identity V3. Otherwise, either are optional.";
          type = (types.nullOr types.str);
        };
        "identityEndpoint" = mkOption {
          description = "IdentityEndpoint specifies the HTTP endpoint that is required to work with\nthe Identity API of the appropriate version.";
          type = (types.nullOr types.str);
        };
        "password" = mkOption {
          description = "Password for the Identity V2 and V3 APIs. Consult with your provider's\ncontrol panel to discover your account's preferred method of authentication.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsPassword"
            )
          );
        };
        "port" = mkOption {
          description = "The port to scrape metrics from. If using the public IP address, this must\ninstead be specified in the relabeling rule.";
          type = (types.nullOr types.int);
        };
        "projectID" = mkOption {
          description = " ProjectID";
          type = (types.nullOr types.str);
        };
        "projectName" = mkOption {
          description = "The ProjectId and ProjectName fields are optional for the Identity V2 API.\nSome providers allow you to specify a ProjectName instead of the ProjectId.\nSome require both. Your provider's authentication policies will determine\nhow these fields influence authentication.";
          type = (types.nullOr types.str);
        };
        "region" = mkOption {
          description = "The OpenStack Region.";
          type = types.str;
        };
        "role" = mkOption {
          description = "The OpenStack role of entities that should be discovered.";
          type = types.str;
        };
        "tlsConfig" = mkOption {
          description = "TLS configuration to use on every scrape request";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfig"
            )
          );
        };
        "userid" = mkOption {
          description = "UserID";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username is required if using Identity V2 API. Consult with your provider's\ncontrol panel to discover your account's username.\nIn Identity V3, either userid or a combination of username\nand domainId or domainName are needed";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "allTenants" = mkOverride 1002 null;
        "applicationCredentialId" = mkOverride 1002 null;
        "applicationCredentialName" = mkOverride 1002 null;
        "applicationCredentialSecret" = mkOverride 1002 null;
        "availability" = mkOverride 1002 null;
        "domainID" = mkOverride 1002 null;
        "domainName" = mkOverride 1002 null;
        "identityEndpoint" = mkOverride 1002 null;
        "password" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "projectID" = mkOverride 1002 null;
        "projectName" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "userid" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsApplicationCredentialSecret" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCertConfigMap" =
      {

        options = {
          "key" = mkOption {
            description = "The key to select.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the ConfigMap or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecOpenstackSDConfigsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecStaticConfigs" = {

      options = {
        "labels" = mkOption {
          description = "Labels assigned to all metrics scraped from the targets.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "targets" = mkOption {
          description = "List of targets for this static configuration.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "labels" = mkOverride 1002 null;
        "targets" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCa")
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCert")
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_params" = {

      options = {
        "disable_compression" = mkOption {
          description = "DisableCompression";
          type = (types.nullOr types.bool);
        };
        "disable_keep_alive" = mkOption {
          description = "disable_keepalive allows disabling HTTP keep-alive when scraping targets.\nBy default, HTTP keep-alive is enabled, so TCP connections to scrape targets\ncould be reused.\nSee https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers allows sending custom headers to scrape targets\nmust be in of semicolon separated header with it's value\neg:\nheaderName: headerValue\nvmagent supports since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "no_stale_markers" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_config"
            )
          );
        };
        "scrape_align_interval" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "scrape_offset" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "stream_parse" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disable_compression" = mkOverride 1002 null;
        "disable_keep_alive" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "no_stale_markers" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "scrape_align_interval" = mkOverride 1002 null;
        "scrape_offset" = mkOverride 1002 null;
        "stream_parse" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_config" = {

      options = {
        "basic_auth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBasic_auth"
            )
          );
        };
        "bearer_token" = mkOption {
          description = "SecretKeySelector selects a key of a Secret.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBearer_token"
            )
          );
        };
        "bearer_token_file" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "tls_config" = mkOption {
          description = "";
          type = (types.nullOr types.attrs);
        };
      };

      config = {
        "basic_auth" = mkOverride 1002 null;
        "bearer_token" = mkOverride 1002 null;
        "bearer_token_file" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigSpecVm_scrape_paramsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMScrapeConfigStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMScrapeConfigStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrape" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMServiceScrapeSpec defines the desired state of VMServiceScrape";
          type = (submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpec");
        };
        "status" = mkOption {
          description = "ScrapeObjectStatus defines the observed state of ScrapeObjects";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpec" = {

      options = {
        "attach_metadata" = mkOption {
          description = "AttachMetadata configures metadata attaching from service discovery";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecAttach_metadata")
          );
        };
        "discoveryRole" = mkOption {
          description = "DiscoveryRole - defines kubernetes_sd role for objects discovery.\nby default, its endpoints.\ncan be changed to service or endpointslices.\nnote, that with service setting, you have to use port: \"name\"\nand cannot use targetPort for endpoints.";
          type = (types.nullOr types.str);
        };
        "endpoints" = mkOption {
          description = "A list of endpoints allowed as part of this ServiceScrape.";
          type = (
            types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpoints")
          );
        };
        "jobLabel" = mkOption {
          description = "The label to use to retrieve the job name from.";
          type = (types.nullOr types.str);
        };
        "namespaceSelector" = mkOption {
          description = "Selector to select which namespaces the Endpoints objects are discovered from.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecNamespaceSelector"
            )
          );
        };
        "podTargetLabels" = mkOption {
          description = "PodTargetLabels transfers labels on the Kubernetes Pod onto the target.";
          type = (types.nullOr (types.listOf types.str));
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scrapeClass" = mkOption {
          description = "ScrapeClass defined scrape class to apply";
          type = (types.nullOr types.str);
        };
        "selector" = mkOption {
          description = "Selector to select Endpoints objects by corresponding Service labels.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecSelector")
          );
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "targetLabels" = mkOption {
          description = "TargetLabels transfers labels on the Kubernetes Service onto the target.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "attach_metadata" = mkOverride 1002 null;
        "discoveryRole" = mkOverride 1002 null;
        "jobLabel" = mkOverride 1002 null;
        "namespaceSelector" = mkOverride 1002 null;
        "podTargetLabels" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scrapeClass" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
        "targetLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecAttach_metadata" = {

      options = {
        "node" = mkOption {
          description = "Node instructs vmagent to add node specific metadata from service discovery\nValid for roles: pod, endpoints, endpointslice.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "node" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpoints" = {

      options = {
        "attach_metadata" = mkOption {
          description = "AttachMetadata configures metadata attaching from service discovery";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsAttach_metadata"
            )
          );
        };
        "authorization" = mkOption {
          description = "Authorization with http header Authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBasicAuth"
            )
          );
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for scraping targets.";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Secret to mount to read bearer token for scraping targets. The secret\nneeds to be in the same namespace as the scrape object and accessible by\nthe victoria-metrics operator.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBearerTokenSecret"
            )
          );
        };
        "follow_redirects" = mkOption {
          description = "FollowRedirects controls redirects for scraping.";
          type = (types.nullOr types.bool);
        };
        "honorLabels" = mkOption {
          description = "HonorLabels chooses the metric's labels on collisions with target labels.";
          type = (types.nullOr types.bool);
        };
        "honorTimestamps" = mkOption {
          description = "HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.";
          type = (types.nullOr types.bool);
        };
        "interval" = mkOption {
          description = "Interval at which metrics should be scraped";
          type = (types.nullOr types.str);
        };
        "max_scrape_size" = mkOption {
          description = "MaxScrapeSize defines a maximum size of scraped data for a job";
          type = (types.nullOr types.str);
        };
        "metricRelabelConfigs" = mkOption {
          description = "MetricRelabelConfigs to apply to samples after scrapping.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsMetricRelabelConfigs"
              )
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2")
          );
        };
        "params" = mkOption {
          description = "Optional HTTP URL parameters";
          type = (types.nullOr (types.loaOf types.str));
        };
        "path" = mkOption {
          description = "HTTP path to scrape for metrics.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Name of the port exposed at Service.";
          type = (types.nullOr types.str);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "relabelConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsRelabelConfigs"
              )
            )
          );
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scheme" = mkOption {
          description = "HTTP scheme to use for scraping.";
          type = (types.nullOr types.str);
        };
        "scrapeTimeout" = mkOption {
          description = "Timeout after which the scrape is ended";
          type = (types.nullOr types.str);
        };
        "scrape_interval" = mkOption {
          description = "ScrapeInterval is the same as Interval and has priority over it.\none of scrape_interval or interval can be used";
          type = (types.nullOr types.str);
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "targetPort" = mkOption {
          description = "TargetPort\nName or number of the pod port this endpoint refers to. Mutually exclusive with port.";
          type = (types.nullOr (types.either types.int types.str));
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig configuration to use when scraping the endpoint";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfig"
            )
          );
        };
        "vm_scrape_params" = mkOption {
          description = "VMScrapeParams defines VictoriaMetrics specific scrape parameters";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_params"
            )
          );
        };
      };

      config = {
        "attach_metadata" = mkOverride 1002 null;
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "follow_redirects" = mkOverride 1002 null;
        "honorLabels" = mkOverride 1002 null;
        "honorTimestamps" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "max_scrape_size" = mkOverride 1002 null;
        "metricRelabelConfigs" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "relabelConfigs" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "scrapeTimeout" = mkOverride 1002 null;
        "scrape_interval" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
        "targetPort" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "vm_scrape_params" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsAttach_metadata" = {

      options = {
        "node" = mkOption {
          description = "Node instructs vmagent to add node specific metadata from service discovery\nValid for roles: pod, endpoints, endpointslice.";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "node" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_id"
          );
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_params" = {

      options = {
        "disable_compression" = mkOption {
          description = "DisableCompression";
          type = (types.nullOr types.bool);
        };
        "disable_keep_alive" = mkOption {
          description = "disable_keepalive allows disabling HTTP keep-alive when scraping targets.\nBy default, HTTP keep-alive is enabled, so TCP connections to scrape targets\ncould be reused.\nSee https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers allows sending custom headers to scrape targets\nmust be in of semicolon separated header with it's value\neg:\nheaderName: headerValue\nvmagent supports since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "no_stale_markers" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_config"
            )
          );
        };
        "scrape_align_interval" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "scrape_offset" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "stream_parse" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disable_compression" = mkOverride 1002 null;
        "disable_keep_alive" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "no_stale_markers" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "scrape_align_interval" = mkOverride 1002 null;
        "scrape_offset" = mkOverride 1002 null;
        "stream_parse" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_config" =
      {

        options = {
          "basic_auth" = mkOption {
            description = "BasicAuth allow an endpoint to authenticate over basic authentication";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBasic_auth"
              )
            );
          };
          "bearer_token" = mkOption {
            description = "SecretKeySelector selects a key of a Secret.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBearer_token"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "";
            type = (types.nullOr types.attrs);
          };
        };

        config = {
          "basic_auth" = mkOverride 1002 null;
          "bearer_token" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecEndpointsVm_scrape_paramsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecNamespaceSelector" = {

      options = {
        "any" = mkOption {
          description = "Boolean describing whether all namespaces are selected in contrast to a\nlist restricting them.";
          type = (types.nullOr types.bool);
        };
        "matchNames" = mkOption {
          description = "List of namespace names.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "any" = mkOverride 1002 null;
        "matchNames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeSpecSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMServiceScrapeStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMServiceScrapeStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingle" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMSingleSpec defines the desired state of VMSingle";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpec"));
        };
        "status" = mkOption {
          description = "VMSingleStatus defines the observed state of VMSingle";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpec" = {

      options = {
        "affinity" = mkOption {
          description = "Affinity If specified, the pod's scheduling constraints.";
          type = (types.nullOr types.attrs);
        };
        "configMaps" = mkOption {
          description = "ConfigMaps is a list of ConfigMaps in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/configs/CONFIGMAP_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "containers" = mkOption {
          description = "Containers property allows to inject additions sidecars or to patch existing containers.\nIt can be useful for proxies, backup, etc.";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "disableAutomountServiceAccountToken" = mkOption {
          description = "DisableAutomountServiceAccountToken whether to disable serviceAccount auto mount by Kubernetes (available from v0.54.0).\nOperator will conditionally create volumes and volumeMounts for containers if it requires k8s API access.\nFor example, vmagent and vm-config-reloader requires k8s API access.\nOperator creates volumes with name: \"kube-api-access\", which can be used as volumeMount for extraContainers if needed.\nAnd also adds VolumeMounts at /var/run/secrets/kubernetes.io/serviceaccount.";
          type = (types.nullOr types.bool);
        };
        "disableSelfServiceScrape" = mkOption {
          description = "DisableSelfServiceScrape controls creation of VMServiceScrape by operator\nfor the application.\nHas priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable";
          type = (types.nullOr types.bool);
        };
        "dnsConfig" = mkOption {
          description = "Specifies the DNS parameters of a pod.\nParameters specified here will be merged to the generated DNS\nconfiguration based on DNSPolicy.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecDnsConfig"));
        };
        "dnsPolicy" = mkOption {
          description = "DNSPolicy sets DNS policy for the pod";
          type = (types.nullOr types.str);
        };
        "extraArgs" = mkOption {
          description = "ExtraArgs that will be passed to the application container\nfor example remoteWrite.tmpDataPath: /tmp";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "ExtraEnvs that will be passed to the application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvsFrom")
            )
          );
        };
        "hostAliases" = mkOption {
          description = "HostAliases provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecHostAliases")
            )
          );
        };
        "hostNetwork" = mkOption {
          description = "HostNetwork controls whether the pod may use the node network namespace";
          type = (types.nullOr types.bool);
        };
        "host_aliases" = mkOption {
          description = "HostAliasesUnderScore provides mapping for ip and hostname,\nthat would be propagated to pod,\ncannot be used with HostNetwork.\nHas Priority over hostAliases field";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecHost_aliases")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings\nif no specified operator uses default version from operator config";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecImage"));
        };
        "imagePullSecrets" = mkOption {
          description = "ImagePullSecrets An optional list of references to secrets in the same namespace\nto use for pulling images from registries\nsee https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMSingleSpecImagePullSecrets"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "initContainers" = mkOption {
          description = "InitContainers allows adding initContainers to the pod definition.\nAny errors during the execution of an initContainer will lead to a restart of the Pod.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "insertPorts" = mkOption {
          description = "InsertPorts - additional listen ports for data ingestion.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecInsertPorts"));
        };
        "license" = mkOption {
          description = "License allows to configure license key to be used for enterprise features.\nUsing license key is supported starting from VictoriaMetrics v1.94.0.\nSee [here](https://docs.victoriametrics.com/victoriametrics/enterprise/)";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecLicense"));
        };
        "livenessProbe" = mkOption {
          description = "LivenessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMSingle to be configured with.";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for victoria metrics single to be configured with.";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecManagedMetadata")
          );
        };
        "minReadySeconds" = mkOption {
          description = "MinReadySeconds defines a minimum number of seconds to wait before starting update next pod\nif previous in healthy state\nHas no effect for VLogs and VMSingle";
          type = (types.nullOr types.int);
        };
        "nodeSelector" = mkOption {
          description = "NodeSelector Define which Nodes the Pods are scheduled on.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "paused" = mkOption {
          description = "Paused If set to true all actions on the underlying managed objects are not\ngoing to be performed, except for delete actions.";
          type = (types.nullOr types.bool);
        };
        "podMetadata" = mkOption {
          description = "PodMetadata configures Labels and Annotations which are propagated to the VMSingle pods.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecPodMetadata"));
        };
        "port" = mkOption {
          description = "Port listen address";
          type = (types.nullOr types.str);
        };
        "priorityClassName" = mkOption {
          description = "PriorityClassName class assigned to the Pods";
          type = (types.nullOr types.str);
        };
        "readinessGates" = mkOption {
          description = "ReadinessGates defines pod readiness gates";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecReadinessGates")
            )
          );
        };
        "readinessProbe" = mkOption {
          description = "ReadinessProbe that will be added CRD pod";
          type = (types.nullOr types.attrs);
        };
        "removePvcAfterDelete" = mkOption {
          description = "RemovePvcAfterDelete - if true, controller adds ownership to pvc\nand after VMSingle object deletion - pvc will be garbage collected\nby controller manager";
          type = (types.nullOr types.bool);
        };
        "replicaCount" = mkOption {
          description = "ReplicaCount is the expected size of the Application.";
          type = (types.nullOr types.int);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecResources"));
        };
        "retentionPeriod" = mkOption {
          description = "RetentionPeriod defines how long to retain stored metrics, specified as a duration (e.g., \"1d\", \"1w\", \"1m\").\nData with timestamps outside the RetentionPeriod is automatically deleted. The minimum allowed value is 1d, or 24h.\nThe default value is 1 (one month).\nSee [retention](https://docs.victoriametrics.com/victoriametrics/single-server-victoriametrics/#retention) docs for details.";
          type = (types.nullOr types.str);
        };
        "revisionHistoryLimitCount" = mkOption {
          description = "The number of old ReplicaSets to retain to allow rollback in deployment or\nmaximum number of revisions that will be maintained in the Deployment revision history.\nHas no effect at StatefulSets\nDefaults to 10.";
          type = (types.nullOr types.int);
        };
        "runtimeClassName" = mkOption {
          description = "RuntimeClassName - defines runtime class for kubernetes pod.\nhttps://kubernetes.io/docs/concepts/containers/runtime-class/";
          type = (types.nullOr types.str);
        };
        "schedulerName" = mkOption {
          description = "SchedulerName - defines kubernetes scheduler name";
          type = (types.nullOr types.str);
        };
        "secrets" = mkOption {
          description = "Secrets is a list of Secrets in the same namespace as the Application\nobject, which shall be mounted into the Application container\nat /etc/vm/secrets/SECRET_NAME folder";
          type = (types.nullOr (types.listOf types.str));
        };
        "securityContext" = mkOption {
          description = "SecurityContext holds pod-level security attributes and common container settings.\nThis defaults to the default PodSecurityContext.";
          type = (types.nullOr types.attrs);
        };
        "serviceAccountName" = mkOption {
          description = "ServiceAccountName is the name of the ServiceAccount to use to run the pods";
          type = (types.nullOr types.str);
        };
        "serviceScrapeSpec" = mkOption {
          description = "ServiceScrapeSpec that will be added to vmsingle VMServiceScrape spec";
          type = (types.nullOr types.attrs);
        };
        "serviceSpec" = mkOption {
          description = "ServiceSpec that will be added to vmsingle service spec";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecServiceSpec"));
        };
        "startupProbe" = mkOption {
          description = "StartupProbe that will be added to CRD pod";
          type = (types.nullOr types.attrs);
        };
        "storage" = mkOption {
          description = "Storage is the definition of how storage will be used by the VMSingle\nby default it`s empty dir\nthis option is ignored if storageDataPath is set";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStorage"));
        };
        "storageDataPath" = mkOption {
          description = "StorageDataPath disables spec.storage option and overrides arg for victoria-metrics binary --storageDataPath,\nits users responsibility to mount proper device into given path.\nIt requires to provide spec.volumes and spec.volumeMounts with at least 1 value";
          type = (types.nullOr types.str);
        };
        "storageMetadata" = mkOption {
          description = "StorageMeta defines annotations and labels attached to PVC for given vmsingle CR";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageMetadata")
          );
        };
        "streamAggrConfig" = mkOption {
          description = "StreamAggrConfig defines stream aggregation configuration for VMSingle";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfig")
          );
        };
        "terminationGracePeriodSeconds" = mkOption {
          description = "TerminationGracePeriodSeconds period for container graceful termination";
          type = (types.nullOr types.int);
        };
        "tolerations" = mkOption {
          description = "Tolerations If specified, the pod's tolerations.";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecTolerations")
            )
          );
        };
        "topologySpreadConstraints" = mkOption {
          description = "TopologySpreadConstraints embedded kubernetes pod configuration option,\ncontrols how pods are spread across your cluster among failure-domains\nsuch as regions, zones, nodes, and other user-defined topology domains\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/";
          type = (types.nullOr (types.listOf types.attrs));
        };
        "useDefaultResources" = mkOption {
          description = "UseDefaultResources controls resource settings\nBy default, operator sets built-in resource requirements";
          type = (types.nullOr types.bool);
        };
        "useStrictSecurity" = mkOption {
          description = "UseStrictSecurity enables strict security mode for component\nit restricts disk writes access\nuses non-root user out of the box\ndrops not needed security permissions";
          type = (types.nullOr types.bool);
        };
        "vmBackup" = mkOption {
          description = "VMBackup configuration for backup";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackup"));
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.\nVolumeMounts specified will be appended to other VolumeMounts in the Application container";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey "operator.victoriametrics.com.v1beta1.VMSingleSpecVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "volumes" = mkOption {
          description = "Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.\nVolumes specified will be appended to other volumes that are generated.\n/ +optional";
          type = (types.nullOr (types.listOf types.attrs));
        };
      };

      config = {
        "affinity" = mkOverride 1002 null;
        "configMaps" = mkOverride 1002 null;
        "containers" = mkOverride 1002 null;
        "disableAutomountServiceAccountToken" = mkOverride 1002 null;
        "disableSelfServiceScrape" = mkOverride 1002 null;
        "dnsConfig" = mkOverride 1002 null;
        "dnsPolicy" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "hostAliases" = mkOverride 1002 null;
        "hostNetwork" = mkOverride 1002 null;
        "host_aliases" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "imagePullSecrets" = mkOverride 1002 null;
        "initContainers" = mkOverride 1002 null;
        "insertPorts" = mkOverride 1002 null;
        "license" = mkOverride 1002 null;
        "livenessProbe" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "minReadySeconds" = mkOverride 1002 null;
        "nodeSelector" = mkOverride 1002 null;
        "paused" = mkOverride 1002 null;
        "podMetadata" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "priorityClassName" = mkOverride 1002 null;
        "readinessGates" = mkOverride 1002 null;
        "readinessProbe" = mkOverride 1002 null;
        "removePvcAfterDelete" = mkOverride 1002 null;
        "replicaCount" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "retentionPeriod" = mkOverride 1002 null;
        "revisionHistoryLimitCount" = mkOverride 1002 null;
        "runtimeClassName" = mkOverride 1002 null;
        "schedulerName" = mkOverride 1002 null;
        "secrets" = mkOverride 1002 null;
        "securityContext" = mkOverride 1002 null;
        "serviceAccountName" = mkOverride 1002 null;
        "serviceScrapeSpec" = mkOverride 1002 null;
        "serviceSpec" = mkOverride 1002 null;
        "startupProbe" = mkOverride 1002 null;
        "storage" = mkOverride 1002 null;
        "storageDataPath" = mkOverride 1002 null;
        "storageMetadata" = mkOverride 1002 null;
        "streamAggrConfig" = mkOverride 1002 null;
        "terminationGracePeriodSeconds" = mkOverride 1002 null;
        "tolerations" = mkOverride 1002 null;
        "topologySpreadConstraints" = mkOverride 1002 null;
        "useDefaultResources" = mkOverride 1002 null;
        "useStrictSecurity" = mkOverride 1002 null;
        "vmBackup" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
        "volumes" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecDnsConfig" = {

      options = {
        "nameservers" = mkOption {
          description = "A list of DNS name server IP addresses.\nThis will be appended to the base nameservers generated from DNSPolicy.\nDuplicated nameservers will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
        "options" = mkOption {
          description = "A list of DNS resolver options.\nThis will be merged with the base options generated from DNSPolicy.\nDuplicated entries will be removed. Resolution options given in Options\nwill override those that appear in the base DNSPolicy.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMSingleSpecDnsConfigOptions"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "searches" = mkOption {
          description = "A list of DNS search domains for host-name lookup.\nThis will be appended to the base search paths generated from DNSPolicy.\nDuplicated search paths will be removed.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "nameservers" = mkOverride 1002 null;
        "options" = mkOverride 1002 null;
        "searches" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecDnsConfigOptions" = {

      options = {
        "name" = mkOption {
          description = "Name is this DNS resolver option's name.\nRequired.";
          type = (types.nullOr types.str);
        };
        "value" = mkOption {
          description = "Value is this DNS resolver option's value.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvsFromSecretRef")
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecHostAliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecHost_aliases" = {

      options = {
        "hostnames" = mkOption {
          description = "Hostnames for the above IP address.";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip" = mkOption {
          description = "IP address of the host file entry.";
          type = types.str;
        };
      };

      config = {
        "hostnames" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecImagePullSecrets" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecInsertPorts" = {

      options = {
        "graphitePort" = mkOption {
          description = "GraphitePort listen port";
          type = (types.nullOr types.str);
        };
        "influxPort" = mkOption {
          description = "InfluxPort listen port";
          type = (types.nullOr types.str);
        };
        "openTSDBHTTPPort" = mkOption {
          description = "OpenTSDBHTTPPort for http connections.";
          type = (types.nullOr types.str);
        };
        "openTSDBPort" = mkOption {
          description = "OpenTSDBPort for tcp and udp listen";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "graphitePort" = mkOverride 1002 null;
        "influxPort" = mkOverride 1002 null;
        "openTSDBHTTPPort" = mkOverride 1002 null;
        "openTSDBPort" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecLicense" = {

      options = {
        "forceOffline" = mkOption {
          description = "Enforce offline verification of the license key.";
          type = (types.nullOr types.bool);
        };
        "key" = mkOption {
          description = "Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/victoriametrics/enterprise/).\nTo request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)";
          type = (types.nullOr types.str);
        };
        "keyRef" = mkOption {
          description = "KeyRef is reference to secret with license key for enterprise features.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecLicenseKeyRef")
          );
        };
        "reloadInterval" = mkOption {
          description = "Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "forceOffline" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "keyRef" = mkOverride 1002 null;
        "reloadInterval" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecLicenseKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecPodMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecReadinessGates" = {

      options = {
        "conditionType" = mkOption {
          description = "ConditionType refers to a condition in the pod's condition list with matching type.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMSingleSpecResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecServiceSpec" = {

      options = {
        "metadata" = mkOption {
          description = "EmbeddedObjectMetadata defines objectMeta for additional service.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecServiceSpecMetadata")
          );
        };
        "spec" = mkOption {
          description = "ServiceSpec describes the attributes that a user creates on a service.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/";
          type = types.attrs;
        };
        "useAsDefault" = mkOption {
          description = "UseAsDefault applies changes from given service definition to the main object Service\nChanging from headless service to clusterIP or loadbalancer may break cross-component communication";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "metadata" = mkOverride 1002 null;
        "useAsDefault" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecServiceSpecMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStorage" = {

      options = {
        "accessModes" = mkOption {
          description = "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1";
          type = (types.nullOr (types.listOf types.str));
        };
        "dataSource" = mkOption {
          description = "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageDataSource")
          );
        };
        "dataSourceRef" = mkOption {
          description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageDataSourceRef")
          );
        };
        "resources" = mkOption {
          description = "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageResources")
          );
        };
        "selector" = mkOption {
          description = "selector is a label query over volumes to consider for binding.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageSelector")
          );
        };
        "storageClassName" = mkOption {
          description = "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1";
          type = (types.nullOr types.str);
        };
        "volumeAttributesClassName" = mkOption {
          description = "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string or nil value indicates that no\nVolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state,\nthis field can be reset to its previous value (including nil) to cancel the modification.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/";
          type = (types.nullOr types.str);
        };
        "volumeMode" = mkOption {
          description = "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.";
          type = (types.nullOr types.str);
        };
        "volumeName" = mkOption {
          description = "volumeName is the binding reference to the PersistentVolume backing this claim.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "accessModes" = mkOverride 1002 null;
        "dataSource" = mkOverride 1002 null;
        "dataSourceRef" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "selector" = mkOverride 1002 null;
        "storageClassName" = mkOverride 1002 null;
        "volumeAttributesClassName" = mkOverride 1002 null;
        "volumeMode" = mkOverride 1002 null;
        "volumeName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageDataSource" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageDataSourceRef" = {

      options = {
        "apiGroup" = mkOption {
          description = "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is the type of resource being referenced";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name is the name of resource being referenced";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "apiGroup" = mkOverride 1002 null;
        "namespace" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageResources" = {

      options = {
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageSelector" = {

      options = {
        "matchExpressions" = mkOption {
          description = "matchExpressions is a list of label selector requirements. The requirements are ANDed.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageSelectorMatchExpressions"
              )
            )
          );
        };
        "matchLabels" = mkOption {
          description = "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "matchExpressions" = mkOverride 1002 null;
        "matchLabels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStorageSelectorMatchExpressions" = {

      options = {
        "key" = mkOption {
          description = "key is the label key that the selector applies to.";
          type = types.str;
        };
        "operator" = mkOption {
          description = "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.";
          type = types.str;
        };
        "values" = mkOption {
          description = "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "values" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfig" = {

      options = {
        "configmap" = mkOption {
          description = "ConfigMap with stream aggregation rules";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigConfigmap"
            )
          );
        };
        "dedupInterval" = mkOption {
          description = "Allows setting different de-duplication intervals per each configured remote storage";
          type = (types.nullOr types.str);
        };
        "dropInput" = mkOption {
          description = "Allow drop all the input samples after the aggregation";
          type = (types.nullOr types.bool);
        };
        "dropInputLabels" = mkOption {
          description = "labels to drop from samples for aggregator before stream de-duplication and aggregation";
          type = (types.nullOr (types.listOf types.str));
        };
        "enableWindows" = mkOption {
          description = "EnableWindows enables aggregating data in separate windows ( available from v0.54.0).";
          type = (types.nullOr types.bool);
        };
        "ignoreFirstIntervals" = mkOption {
          description = "IgnoreFirstIntervals instructs to ignore first interval";
          type = (types.nullOr types.int);
        };
        "ignoreFirstSampleInterval" = mkOption {
          description = "IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored";
          type = (types.nullOr types.str);
        };
        "ignoreOldSamples" = mkOption {
          description = "IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.";
          type = (types.nullOr types.bool);
        };
        "keepInput" = mkOption {
          description = "Allows writing both raw and aggregate data";
          type = (types.nullOr types.bool);
        };
        "rules" = mkOption {
          description = "Stream aggregation rules";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigRules")
            )
          );
        };
      };

      config = {
        "configmap" = mkOverride 1002 null;
        "dedupInterval" = mkOverride 1002 null;
        "dropInput" = mkOverride 1002 null;
        "dropInputLabels" = mkOverride 1002 null;
        "enableWindows" = mkOverride 1002 null;
        "ignoreFirstIntervals" = mkOverride 1002 null;
        "ignoreFirstSampleInterval" = mkOverride 1002 null;
        "ignoreOldSamples" = mkOverride 1002 null;
        "keepInput" = mkOverride 1002 null;
        "rules" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigConfigmap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigRules" = {

      options = {
        "by" = mkOption {
          description = "By is an optional list of labels for grouping input series.\n\nSee also Without.\n\nIf neither By nor Without are set, then the Outputs are calculated\nindividually per each input time series.";
          type = (types.nullOr (types.listOf types.str));
        };
        "dedup_interval" = mkOption {
          description = "DedupInterval is an optional interval for deduplication.";
          type = (types.nullOr types.str);
        };
        "drop_input_labels" = mkOption {
          description = "DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.\n\nLabels are dropped before de-duplication and aggregation.";
          type = (types.nullOr (types.listOf types.str));
        };
        "enable_windows" = mkOption {
          description = "EnableWindows enables aggregating data in separate windows";
          type = (types.nullOr types.bool);
        };
        "flush_on_shutdown" = mkOption {
          description = "FlushOnShutdown defines whether to flush the aggregation state on process termination\nor config reload. Is `false` by default.\nIt is not recommended changing this setting, unless unfinished aggregations states\nare preferred to missing data points.";
          type = (types.nullOr types.bool);
        };
        "ignoreFirstSampleInterval" = mkOption {
          description = "IgnoreFirstSampleInterval sets interval for total and prometheus_total during which first samples will be ignored";
          type = (types.nullOr types.str);
        };
        "ignore_first_intervals" = mkOption {
          description = "";
          type = (types.nullOr types.int);
        };
        "ignore_old_samples" = mkOption {
          description = "IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.";
          type = (types.nullOr types.bool);
        };
        "input_relabel_configs" = mkOption {
          description = "InputRelabelConfigs is an optional relabeling rules, which are applied on the input\nbefore aggregation.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigRulesInput_relabel_configs"
              )
            )
          );
        };
        "interval" = mkOption {
          description = "Interval is the interval between aggregations.";
          type = types.str;
        };
        "keep_metric_names" = mkOption {
          description = "KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.";
          type = (types.nullOr types.bool);
        };
        "match" = mkOption {
          description = "Match is a label selector (or list of label selectors) for filtering time series for the given selector.\n\nIf the match isn't set, then all the input time series are processed.";
          type = (types.nullOr types.attrs);
        };
        "no_align_flush_to_interval" = mkOption {
          description = "NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.\nBy default flushes are aligned to Interval.";
          type = (types.nullOr types.bool);
        };
        "output_relabel_configs" = mkOption {
          description = "OutputRelabelConfigs is an optional relabeling rules, which are applied\non the aggregated output before being sent to remote storage.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigRulesOutput_relabel_configs"
              )
            )
          );
        };
        "outputs" = mkOption {
          description = "Outputs is a list of output aggregate functions to produce.\n\nThe following names are allowed:\n\n- total - aggregates input counters\n- increase - counts the increase over input counters\n- count_series - counts the input series\n- count_samples - counts the input samples\n- sum_samples - sums the input samples\n- last - the last biggest sample value\n- min - the minimum sample value\n- max - the maximum sample value\n- avg - the average value across all the samples\n- stddev - standard deviation across all the samples\n- stdvar - standard variance across all the samples\n- histogram_bucket - creates VictoriaMetrics histogram for input samples\n- quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]\n\nThe output time series will have the following names:\n\n  input_name:aggr_<interval>_<output>";
          type = (types.listOf types.str);
        };
        "staleness_interval" = mkOption {
          description = "Staleness interval is interval after which the series state will be reset if no samples have been sent during it.\nThe parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.";
          type = (types.nullOr types.str);
        };
        "without" = mkOption {
          description = "Without is an optional list of labels, which must be excluded when grouping input series.\n\nSee also By.\n\nIf neither By nor Without are set, then the Outputs are calculated\nindividually per each input time series.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "by" = mkOverride 1002 null;
        "dedup_interval" = mkOverride 1002 null;
        "drop_input_labels" = mkOverride 1002 null;
        "enable_windows" = mkOverride 1002 null;
        "flush_on_shutdown" = mkOverride 1002 null;
        "ignoreFirstSampleInterval" = mkOverride 1002 null;
        "ignore_first_intervals" = mkOverride 1002 null;
        "ignore_old_samples" = mkOverride 1002 null;
        "input_relabel_configs" = mkOverride 1002 null;
        "keep_metric_names" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "no_align_flush_to_interval" = mkOverride 1002 null;
        "output_relabel_configs" = mkOverride 1002 null;
        "staleness_interval" = mkOverride 1002 null;
        "without" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigRulesInput_relabel_configs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecStreamAggrConfigRulesOutput_relabel_configs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecTolerations" = {

      options = {
        "effect" = mkOption {
          description = "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.";
          type = (types.nullOr types.str);
        };
        "key" = mkOption {
          description = "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.";
          type = (types.nullOr types.str);
        };
        "operator" = mkOption {
          description = "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.";
          type = (types.nullOr types.str);
        };
        "tolerationSeconds" = mkOption {
          description = "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.";
          type = (types.nullOr types.int);
        };
        "value" = mkOption {
          description = "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "effect" = mkOverride 1002 null;
        "key" = mkOverride 1002 null;
        "operator" = mkOverride 1002 null;
        "tolerationSeconds" = mkOverride 1002 null;
        "value" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackup" = {

      options = {
        "acceptEULA" = mkOption {
          description = "AcceptEULA accepts enterprise feature usage, must be set to true.\notherwise backupmanager cannot be added to single/cluster version.\nhttps://victoriametrics.com/legal/esa/\nDeprecated: use license.key or license.keyRef instead";
          type = (types.nullOr types.bool);
        };
        "concurrency" = mkOption {
          description = "Defines number of concurrent workers. Higher concurrency may reduce backup duration (default 10)";
          type = (types.nullOr types.int);
        };
        "credentialsSecret" = mkOption {
          description = "CredentialsSecret is secret in the same namespace for access to remote storage\nThe secret is mounted into /etc/vm/creds.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupCredentialsSecret"
            )
          );
        };
        "customS3Endpoint" = mkOption {
          description = "Custom S3 endpoint for use with S3-compatible storages (e.g. MinIO). S3 is used if not set";
          type = (types.nullOr types.str);
        };
        "destination" = mkOption {
          description = "Defines destination for backup";
          type = (types.nullOr types.str);
        };
        "destinationDisableSuffixAdd" = mkOption {
          description = "DestinationDisableSuffixAdd - disables suffix adding for cluster version backups\neach vmstorage backup must have unique backup folder\nso operator adds POD_NAME as suffix for backup destination folder.";
          type = (types.nullOr types.bool);
        };
        "disableDaily" = mkOption {
          description = "Defines if daily backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "disableHourly" = mkOption {
          description = "Defines if hourly backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "disableMonthly" = mkOption {
          description = "Defines if monthly backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "disableWeekly" = mkOption {
          description = "Defines if weekly backups disabled (default false)";
          type = (types.nullOr types.bool);
        };
        "extraArgs" = mkOption {
          description = "extra args like maxBytesPerSecond default 0";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "extraEnvs" = mkOption {
          description = "";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvs"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "extraEnvsFrom" = mkOption {
          description = "ExtraEnvsFrom defines source of env variables for the application container\ncould either be secret or configmap";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsFrom")
            )
          );
        };
        "image" = mkOption {
          description = "Image - docker image settings for VMBackuper";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupImage")
          );
        };
        "logFormat" = mkOption {
          description = "LogFormat for VMBackup to be configured with.\ndefault or json";
          type = (types.nullOr types.str);
        };
        "logLevel" = mkOption {
          description = "LogLevel for VMBackup to be configured with.";
          type = (types.nullOr types.str);
        };
        "port" = mkOption {
          description = "Port for health check connections";
          type = (types.nullOr types.str);
        };
        "resources" = mkOption {
          description = "Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\nif not defined default resources from operator config will be used";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupResources")
          );
        };
        "restore" = mkOption {
          description = "Restore Allows to enable restore options for pod\nRead [more](https://docs.victoriametrics.com/victoriametrics/vmbackupmanager/#restore-commands)";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupRestore")
          );
        };
        "snapshotCreateURL" = mkOption {
          description = "SnapshotCreateURL overwrites url for snapshot create";
          type = (types.nullOr types.str);
        };
        "snapshotDeleteURL" = mkOption {
          description = "SnapShotDeleteURL overwrites url for snapshot delete";
          type = (types.nullOr types.str);
        };
        "volumeMounts" = mkOption {
          description = "VolumeMounts allows configuration of additional VolumeMounts on the output Deployment definition.\nVolumeMounts specified will be appended to other VolumeMounts in the vmbackupmanager container,\nthat are generated as a result of StorageSpec objects.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupVolumeMounts"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
      };

      config = {
        "acceptEULA" = mkOverride 1002 null;
        "concurrency" = mkOverride 1002 null;
        "credentialsSecret" = mkOverride 1002 null;
        "customS3Endpoint" = mkOverride 1002 null;
        "destination" = mkOverride 1002 null;
        "destinationDisableSuffixAdd" = mkOverride 1002 null;
        "disableDaily" = mkOverride 1002 null;
        "disableHourly" = mkOverride 1002 null;
        "disableMonthly" = mkOverride 1002 null;
        "disableWeekly" = mkOverride 1002 null;
        "extraArgs" = mkOverride 1002 null;
        "extraEnvs" = mkOverride 1002 null;
        "extraEnvsFrom" = mkOverride 1002 null;
        "image" = mkOverride 1002 null;
        "logFormat" = mkOverride 1002 null;
        "logLevel" = mkOverride 1002 null;
        "port" = mkOverride 1002 null;
        "resources" = mkOverride 1002 null;
        "restore" = mkOverride 1002 null;
        "snapshotCreateURL" = mkOverride 1002 null;
        "snapshotDeleteURL" = mkOverride 1002 null;
        "volumeMounts" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupCredentialsSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvs" = {

      options = {
        "name" = mkOption {
          description = "Name of the environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = types.str;
        };
        "value" = mkOption {
          description = "Variable references $(VAR_NAME) are expanded\nusing the previously defined environment variables in the container and\nany service environment variables. If a variable cannot be resolved,\nthe reference in the input string will be unchanged. Double $$ are reduced\nto a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\n\"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\".\nEscaped references will never be expanded, regardless of whether the variable\nexists or not.\nDefaults to \"\".";
          type = (types.nullOr types.str);
        };
        "valueFrom" = mkOption {
          description = "Source for the environment variable's value. Cannot be used if value is not empty.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFrom"
            )
          );
        };
      };

      config = {
        "value" = mkOverride 1002 null;
        "valueFrom" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsFrom" = {

      options = {
        "configMapRef" = mkOption {
          description = "The ConfigMap to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsFromConfigMapRef"
            )
          );
        };
        "prefix" = mkOption {
          description = "Optional text to prepend to the name of each environment variable.\nMay consist of any printable ASCII characters except '='.";
          type = (types.nullOr types.str);
        };
        "secretRef" = mkOption {
          description = "The Secret to select from";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsFromSecretRef"
            )
          );
        };
      };

      config = {
        "configMapRef" = mkOverride 1002 null;
        "prefix" = mkOverride 1002 null;
        "secretRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsFromConfigMapRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsFromSecretRef" = {

      options = {
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFrom" = {

      options = {
        "configMapKeyRef" = mkOption {
          description = "Selects a key of a ConfigMap.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef"
            )
          );
        };
        "fieldRef" = mkOption {
          description = "Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,\nspec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromFieldRef"
            )
          );
        };
        "fileKeyRef" = mkOption {
          description = "FileKeyRef selects a key of the env file.\nRequires the EnvFiles feature gate to be enabled.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromFileKeyRef"
            )
          );
        };
        "resourceFieldRef" = mkOption {
          description = "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef"
            )
          );
        };
        "secretKeyRef" = mkOption {
          description = "Selects a key of a secret in the pod's namespace";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef"
            )
          );
        };
      };

      config = {
        "configMapKeyRef" = mkOverride 1002 null;
        "fieldRef" = mkOverride 1002 null;
        "fileKeyRef" = mkOverride 1002 null;
        "resourceFieldRef" = mkOverride 1002 null;
        "secretKeyRef" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromConfigMapKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromFieldRef" = {

      options = {
        "apiVersion" = mkOption {
          description = "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".";
          type = (types.nullOr types.str);
        };
        "fieldPath" = mkOption {
          description = "Path of the field to select in the specified API version.";
          type = types.str;
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromFileKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key within the env file. An invalid key will prevent the pod from starting.\nThe keys defined within a source may consist of any printable ASCII characters except '='.\nDuring Alpha stage of the EnvFiles feature gate, the key size is limited to 128 characters.";
          type = types.str;
        };
        "optional" = mkOption {
          description = "Specify whether the file or its key must be defined. If the file or key\ndoes not exist, then the env var is not published.\nIf optional is set to true and the specified key does not exist,\nthe environment variable will not be set in the Pod's containers.\n\nIf optional is set to false and the specified key does not exist,\nan error will be returned during Pod creation.";
          type = (types.nullOr types.bool);
        };
        "path" = mkOption {
          description = "The path within the volume from which to select the file.\nMust be relative and may not contain the '..' path or start with '..'.";
          type = types.str;
        };
        "volumeName" = mkOption {
          description = "The name of the volume mount containing the env file.";
          type = types.str;
        };
      };

      config = {
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromResourceFieldRef" = {

      options = {
        "containerName" = mkOption {
          description = "Container name: required for volumes, optional for env vars";
          type = (types.nullOr types.str);
        };
        "divisor" = mkOption {
          description = "Specifies the output format of the exposed resources, defaults to \"1\"";
          type = (types.nullOr (types.either types.int types.str));
        };
        "resource" = mkOption {
          description = "Required: resource to select";
          type = types.str;
        };
      };

      config = {
        "containerName" = mkOverride 1002 null;
        "divisor" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupExtraEnvsValueFromSecretKeyRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupImage" = {

      options = {
        "pullPolicy" = mkOption {
          description = "PullPolicy describes how to pull docker image";
          type = (types.nullOr types.str);
        };
        "repository" = mkOption {
          description = "Repository contains name of docker image + it's repository if needed";
          type = (types.nullOr types.str);
        };
        "tag" = mkOption {
          description = "Tag contains desired docker image version";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "pullPolicy" = mkOverride 1002 null;
        "repository" = mkOverride 1002 null;
        "tag" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupResources" = {

      options = {
        "claims" = mkOption {
          description = "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis field depends on the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupResourcesClaims"
                "name"
                [ "name" ]
            )
          );
          apply = attrsToList;
        };
        "limits" = mkOption {
          description = "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
        "requests" = mkOption {
          description = "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/";
          type = (types.nullOr (types.attrsOf (types.either types.int types.str)));
        };
      };

      config = {
        "claims" = mkOverride 1002 null;
        "limits" = mkOverride 1002 null;
        "requests" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupResourcesClaims" = {

      options = {
        "name" = mkOption {
          description = "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.";
          type = types.str;
        };
        "request" = mkOption {
          description = "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "request" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupRestore" = {

      options = {
        "onStart" = mkOption {
          description = "OnStart defines configuration for restore on pod start";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupRestoreOnStart")
          );
        };
      };

      config = {
        "onStart" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupRestoreOnStart" = {

      options = {
        "enabled" = mkOption {
          description = "Enabled defines if restore on start enabled";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "enabled" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVmBackupVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleSpecVolumeMounts" = {

      options = {
        "mountPath" = mkOption {
          description = "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.";
          type = types.str;
        };
        "mountPropagation" = mkOption {
          description = "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).";
          type = (types.nullOr types.str);
        };
        "name" = mkOption {
          description = "This must match the Name of a Volume.";
          type = types.str;
        };
        "readOnly" = mkOption {
          description = "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.";
          type = (types.nullOr types.bool);
        };
        "recursiveReadOnly" = mkOption {
          description = "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.";
          type = (types.nullOr types.str);
        };
        "subPath" = mkOption {
          description = "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).";
          type = (types.nullOr types.str);
        };
        "subPathExpr" = mkOption {
          description = "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "mountPropagation" = mkOverride 1002 null;
        "readOnly" = mkOverride 1002 null;
        "recursiveReadOnly" = mkOverride 1002 null;
        "subPath" = mkOverride 1002 null;
        "subPathExpr" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMSingleStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMSingleStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrape" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMStaticScrapeSpec defines the desired state of VMStaticScrape.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpec"));
        };
        "status" = mkOption {
          description = "ScrapeObjectStatus defines the observed state of ScrapeObjects";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpec" = {

      options = {
        "jobName" = mkOption {
          description = "JobName name of job.";
          type = (types.nullOr types.str);
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scrapeClass" = mkOption {
          description = "ScrapeClass defined scrape class to apply";
          type = (types.nullOr types.str);
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "targetEndpoints" = mkOption {
          description = "A list of target endpoints to scrape metrics from.";
          type = (
            types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpoints")
          );
        };
      };

      config = {
        "jobName" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scrapeClass" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpoints" = {

      options = {
        "authorization" = mkOption {
          description = "Authorization with http header Authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsAuthorization"
            )
          );
        };
        "basicAuth" = mkOption {
          description = "BasicAuth allow an endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBasicAuth"
            )
          );
        };
        "bearerTokenFile" = mkOption {
          description = "File to read bearer token for scraping targets.";
          type = (types.nullOr types.str);
        };
        "bearerTokenSecret" = mkOption {
          description = "Secret to mount to read bearer token for scraping targets. The secret\nneeds to be in the same namespace as the scrape object and accessible by\nthe victoria-metrics operator.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBearerTokenSecret"
            )
          );
        };
        "follow_redirects" = mkOption {
          description = "FollowRedirects controls redirects for scraping.";
          type = (types.nullOr types.bool);
        };
        "honorLabels" = mkOption {
          description = "HonorLabels chooses the metric's labels on collisions with target labels.";
          type = (types.nullOr types.bool);
        };
        "honorTimestamps" = mkOption {
          description = "HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.";
          type = (types.nullOr types.bool);
        };
        "interval" = mkOption {
          description = "Interval at which metrics should be scraped";
          type = (types.nullOr types.str);
        };
        "labels" = mkOption {
          description = "Labels static labels for targets.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "max_scrape_size" = mkOption {
          description = "MaxScrapeSize defines a maximum size of scraped data for a job";
          type = (types.nullOr types.str);
        };
        "metricRelabelConfigs" = mkOption {
          description = "MetricRelabelConfigs to apply to samples after scrapping.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsMetricRelabelConfigs"
              )
            )
          );
        };
        "oauth2" = mkOption {
          description = "OAuth2 defines auth configuration";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2"
            )
          );
        };
        "params" = mkOption {
          description = "Optional HTTP URL parameters";
          type = (types.nullOr (types.loaOf types.str));
        };
        "path" = mkOption {
          description = "HTTP path to scrape for metrics.";
          type = (types.nullOr types.str);
        };
        "proxyURL" = mkOption {
          description = "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.";
          type = (types.nullOr types.str);
        };
        "relabelConfigs" = mkOption {
          description = "RelabelConfigs to apply to samples during service discovery.";
          type = (
            types.nullOr (
              types.listOf (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsRelabelConfigs"
              )
            )
          );
        };
        "sampleLimit" = mkOption {
          description = "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.";
          type = (types.nullOr types.int);
        };
        "scheme" = mkOption {
          description = "HTTP scheme to use for scraping.";
          type = (types.nullOr types.str);
        };
        "scrapeTimeout" = mkOption {
          description = "Timeout after which the scrape is ended";
          type = (types.nullOr types.str);
        };
        "scrape_interval" = mkOption {
          description = "ScrapeInterval is the same as Interval and has priority over it.\none of scrape_interval or interval can be used";
          type = (types.nullOr types.str);
        };
        "seriesLimit" = mkOption {
          description = "SeriesLimit defines per-scrape limit on number of unique time series\na single target can expose during all the scrapes on the time window of 24h.";
          type = (types.nullOr types.int);
        };
        "targets" = mkOption {
          description = "Targets static targets addresses in form of [\"192.122.55.55:9100\",\"some-name:9100\"].";
          type = (types.listOf types.str);
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig configuration to use when scraping the endpoint";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfig"
            )
          );
        };
        "vm_scrape_params" = mkOption {
          description = "VMScrapeParams defines VictoriaMetrics specific scrape parameters";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_params"
            )
          );
        };
      };

      config = {
        "authorization" = mkOverride 1002 null;
        "basicAuth" = mkOverride 1002 null;
        "bearerTokenFile" = mkOverride 1002 null;
        "bearerTokenSecret" = mkOverride 1002 null;
        "follow_redirects" = mkOverride 1002 null;
        "honorLabels" = mkOverride 1002 null;
        "honorTimestamps" = mkOverride 1002 null;
        "interval" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "max_scrape_size" = mkOverride 1002 null;
        "metricRelabelConfigs" = mkOverride 1002 null;
        "oauth2" = mkOverride 1002 null;
        "params" = mkOverride 1002 null;
        "path" = mkOverride 1002 null;
        "proxyURL" = mkOverride 1002 null;
        "relabelConfigs" = mkOverride 1002 null;
        "sampleLimit" = mkOverride 1002 null;
        "scheme" = mkOverride 1002 null;
        "scrapeTimeout" = mkOverride 1002 null;
        "scrape_interval" = mkOverride 1002 null;
        "seriesLimit" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "vm_scrape_params" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsAuthorization" = {

      options = {
        "credentials" = mkOption {
          description = "Reference to the secret with value for authorization";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsAuthorizationCredentials"
            )
          );
        };
        "credentialsFile" = mkOption {
          description = "File with value for authorization";
          type = (types.nullOr types.str);
        };
        "type" = mkOption {
          description = "Type of authorization, default to bearer";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "credentials" = mkOverride 1002 null;
        "credentialsFile" = mkOverride 1002 null;
        "type" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsAuthorizationCredentials" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBasicAuthPassword"
            )
          );
        };
        "password_file" = mkOption {
          description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
          type = (types.nullOr types.str);
        };
        "username" = mkOption {
          description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBasicAuthUsername"
            )
          );
        };
      };

      config = {
        "password" = mkOverride 1002 null;
        "password_file" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsBearerTokenSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsMetricRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2" = {

      options = {
        "client_id" = mkOption {
          description = "The secret or configmap containing the OAuth2 client id";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_id"
          );
        };
        "client_secret" = mkOption {
          description = "The secret containing the OAuth2 client secret";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_secret"
            )
          );
        };
        "client_secret_file" = mkOption {
          description = "ClientSecretFile defines path for client secret file.";
          type = (types.nullOr types.str);
        };
        "endpoint_params" = mkOption {
          description = "Parameters to append to the token URL";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "proxy_url" = mkOption {
          description = "The proxy URL for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.str);
        };
        "scopes" = mkOption {
          description = "OAuth2 scopes used for the token request";
          type = (types.nullOr (types.listOf types.str));
        };
        "tls_config" = mkOption {
          description = "TLSConfig for token_url connection\n( available from v0.55.0).\nIs only supported by Scrape objects family";
          type = (types.nullOr types.attrs);
        };
        "token_url" = mkOption {
          description = "The URL to fetch the token from";
          type = types.str;
        };
      };

      config = {
        "client_secret" = mkOverride 1002 null;
        "client_secret_file" = mkOverride 1002 null;
        "endpoint_params" = mkOverride 1002 null;
        "proxy_url" = mkOverride 1002 null;
        "scopes" = mkOverride 1002 null;
        "tls_config" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_id" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_idConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_idSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_idConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_idSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsOauth2Client_secret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsRelabelConfigs" = {

      options = {
        "action" = mkOption {
          description = "Action to perform based on regex matching. Default is 'replace'";
          type = (types.nullOr types.str);
        };
        "if" = mkOption {
          description = "If represents metricsQL match expression (or list of expressions): '{__name__=~\"foo_.*\"}'";
          type = (types.nullOr types.attrs);
        };
        "labels" = mkOption {
          description = "Labels is used together with Match for `action: graphite`";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "match" = mkOption {
          description = "Match is used together with Labels for `action: graphite`";
          type = (types.nullOr types.str);
        };
        "modulus" = mkOption {
          description = "Modulus to take of the hash of the source label values.";
          type = (types.nullOr types.int);
        };
        "regex" = mkOption {
          type = (types.nullOr types.str);
        };
        "replacement" = mkOption {
          description = "Replacement value against which a regex replace is performed if the\nregular expression matches. Regex capture groups are available. Default is '$1'";
          type = (types.nullOr types.str);
        };
        "separator" = mkOption {
          description = "Separator placed between concatenated source label values. default is ';'.";
          type = (types.nullOr types.str);
        };
        "sourceLabels" = mkOption {
          description = "The source labels select values from existing labels. Their content is concatenated\nusing the configured separator and matched against the configured regular expression\nfor the replace, keep, and drop actions.";
          type = (types.nullOr (types.listOf types.str));
        };
        "source_labels" = mkOption {
          description = "UnderScoreSourceLabels - additional form of source labels source_labels\nfor compatibility with original relabel config.\nif set  both sourceLabels and source_labels, sourceLabels has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr (types.listOf types.str));
        };
        "targetLabel" = mkOption {
          description = "Label to which the resulting value is written in a replace action.\nIt is mandatory for replace actions. Regex capture groups are available.";
          type = (types.nullOr types.str);
        };
        "target_label" = mkOption {
          description = "UnderScoreTargetLabel - additional form of target label - target_label\nfor compatibility with original relabel config.\nif set  both targetLabel and target_label, targetLabel has priority.\nfor details https://github.com/VictoriaMetrics/operator/issues/131";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "action" = mkOverride 1002 null;
        "if" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
        "match" = mkOverride 1002 null;
        "modulus" = mkOverride 1002 null;
        "regex" = mkOverride 1002 null;
        "replacement" = mkOverride 1002 null;
        "separator" = mkOverride 1002 null;
        "sourceLabels" = mkOverride 1002 null;
        "source_labels" = mkOverride 1002 null;
        "targetLabel" = mkOverride 1002 null;
        "target_label" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCa"
            )
          );
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCert"
            )
          );
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigKeySecret"
            )
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCaSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap"
            )
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCertSecret"
            )
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_params" = {

      options = {
        "disable_compression" = mkOption {
          description = "DisableCompression";
          type = (types.nullOr types.bool);
        };
        "disable_keep_alive" = mkOption {
          description = "disable_keepalive allows disabling HTTP keep-alive when scraping targets.\nBy default, HTTP keep-alive is enabled, so TCP connections to scrape targets\ncould be reused.\nSee https://docs.victoriametrics.com/victoriametrics/vmagent/#scrape_config-enhancements";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers allows sending custom headers to scrape targets\nmust be in of semicolon separated header with it's value\neg:\nheaderName: headerValue\nvmagent supports since 1.79.0 version";
          type = (types.nullOr (types.listOf types.str));
        };
        "no_stale_markers" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
        "proxy_client_config" = mkOption {
          description = "ProxyClientConfig configures proxy auth settings for scraping\nSee feature description https://docs.victoriametrics.com/victoriametrics/vmagent/#scraping-targets-via-a-proxy";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_config"
            )
          );
        };
        "scrape_align_interval" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "scrape_offset" = mkOption {
          description = "";
          type = (types.nullOr types.str);
        };
        "stream_parse" = mkOption {
          description = "";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "disable_compression" = mkOverride 1002 null;
        "disable_keep_alive" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "no_stale_markers" = mkOverride 1002 null;
        "proxy_client_config" = mkOverride 1002 null;
        "scrape_align_interval" = mkOverride 1002 null;
        "scrape_offset" = mkOverride 1002 null;
        "stream_parse" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_config" =
      {

        options = {
          "basic_auth" = mkOption {
            description = "BasicAuth allow an endpoint to authenticate over basic authentication";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBasic_auth"
              )
            );
          };
          "bearer_token" = mkOption {
            description = "SecretKeySelector selects a key of a Secret.";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBearer_token"
              )
            );
          };
          "bearer_token_file" = mkOption {
            description = "";
            type = (types.nullOr types.str);
          };
          "tls_config" = mkOption {
            description = "";
            type = (types.nullOr types.attrs);
          };
        };

        config = {
          "basic_auth" = mkOverride 1002 null;
          "bearer_token" = mkOverride 1002 null;
          "bearer_token_file" = mkOverride 1002 null;
          "tls_config" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBasic_auth" =
      {

        options = {
          "password" = mkOption {
            description = "Password defines reference for secret with password value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBasic_authPassword"
              )
            );
          };
          "password_file" = mkOption {
            description = "PasswordFile defines path to password file at disk\nmust be pre-mounted";
            type = (types.nullOr types.str);
          };
          "username" = mkOption {
            description = "Username defines reference for secret with username value\nThe secret needs to be in the same namespace as scrape object";
            type = (
              types.nullOr (
                submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBasic_authUsername"
              )
            );
          };
        };

        config = {
          "password" = mkOverride 1002 null;
          "password_file" = mkOverride 1002 null;
          "username" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBasic_authPassword" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBasic_authUsername" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeSpecTargetEndpointsVm_scrape_paramsProxy_client_configBearer_token" =
      {

        options = {
          "key" = mkOption {
            description = "The key of the secret to select from.  Must be a valid secret key.";
            type = types.str;
          };
          "name" = mkOption {
            description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
            type = (types.nullOr types.str);
          };
          "optional" = mkOption {
            description = "Specify whether the Secret or its key must be defined";
            type = (types.nullOr types.bool);
          };
        };

        config = {
          "name" = mkOverride 1002 null;
          "optional" = mkOverride 1002 null;
        };

      };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMStaticScrapeStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMStaticScrapeStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUser" = {

      options = {
        "apiVersion" = mkOption {
          description = "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources";
          type = (types.nullOr types.str);
        };
        "kind" = mkOption {
          description = "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds";
          type = (types.nullOr types.str);
        };
        "metadata" = mkOption {
          description = "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata";
          type = (types.nullOr (globalSubmoduleOf "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"));
        };
        "spec" = mkOption {
          description = "VMUserSpec defines the desired state of VMUser";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpec"));
        };
        "status" = mkOption {
          description = "VMUserStatus defines the observed state of VMUser";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserStatus"));
        };
      };

      config = {
        "apiVersion" = mkOverride 1002 null;
        "kind" = mkOverride 1002 null;
        "metadata" = mkOverride 1002 null;
        "spec" = mkOverride 1002 null;
        "status" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpec" = {

      options = {
        "bearerToken" = mkOption {
          description = "BearerToken Authorization header value for accessing protected endpoint.";
          type = (types.nullOr types.str);
        };
        "default_url" = mkOption {
          description = "DefaultURLs backend url for non-matching paths filter\nusually used for default backend with error message";
          type = (types.nullOr (types.listOf types.str));
        };
        "disable_secret_creation" = mkOption {
          description = "DisableSecretCreation skips related secret creation for vmuser";
          type = (types.nullOr types.bool);
        };
        "discover_backend_ips" = mkOption {
          description = "DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.";
          type = (types.nullOr types.bool);
        };
        "drop_src_path_prefix_parts" = mkOption {
          description = "DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.";
          type = (types.nullOr types.int);
        };
        "dump_request_on_errors" = mkOption {
          description = "DumpRequestOnErrors instructs vmauth to return detailed request params to the client\nif routing rules don't allow to forward request to the backends.\nUseful for debugging `src_hosts` and `src_headers` based routing rules\n\navailable since v1.107.0 vmauth version";
          type = (types.nullOr types.bool);
        };
        "generatePassword" = mkOption {
          description = "GeneratePassword instructs operator to generate password for user\nif spec.password if empty.";
          type = (types.nullOr types.bool);
        };
        "headers" = mkOption {
          description = "Headers represent additional http headers, that vmauth uses\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.68.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "ip_filters" = mkOption {
          description = "IPFilters defines per target src ip filters\nsupported only with enterprise version of [vmauth](https://docs.victoriametrics.com/victoriametrics/vmauth/#ip-filters)";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecIp_filters"));
        };
        "load_balancing_policy" = mkOption {
          description = "LoadBalancingPolicy defines load balancing policy to use for backend urls.\nSupported policies: least_loaded, first_available.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default \"least_loaded\")";
          type = (types.nullOr types.str);
        };
        "managedMetadata" = mkOption {
          description = "ManagedMetadata defines metadata that will be added to the all objects\ncreated by operator for the given CustomResource";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecManagedMetadata")
          );
        };
        "max_concurrent_requests" = mkOption {
          description = "MaxConcurrentRequests defines max concurrent requests per user\n300 is default value for vmauth";
          type = (types.nullOr types.int);
        };
        "metric_labels" = mkOption {
          description = "MetricLabels - additional labels for metrics exported by vmauth for given user.";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "name" = mkOption {
          description = "Name of the VMUser object.";
          type = (types.nullOr types.str);
        };
        "password" = mkOption {
          description = "Password basic auth password for accessing protected endpoint.";
          type = (types.nullOr types.str);
        };
        "passwordRef" = mkOption {
          description = "PasswordRef allows fetching password from user-create secret by its name and key.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecPasswordRef"));
        };
        "response_headers" = mkOption {
          description = "ResponseHeaders represent additional http headers, that vmauth adds for request response\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.93.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "retry_status_codes" = mkOption {
          description = "RetryStatusCodes defines http status codes in numeric format for request retries\ne.g. [429,503]";
          type = (types.nullOr (types.listOf types.int));
        };
        "targetRefs" = mkOption {
          description = "TargetRefs - reference to endpoints, which user may access.";
          type = (types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefs"));
        };
        "tlsConfig" = mkOption {
          description = "TLSConfig defines tls configuration for the backend connection";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfig"));
        };
        "tokenRef" = mkOption {
          description = "TokenRef allows fetching token from user-created secrets by its name and key.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTokenRef"));
        };
        "username" = mkOption {
          description = "UserName basic auth user name for accessing protected endpoint,\nwill be replaced with metadata.name of VMUser if omitted.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "bearerToken" = mkOverride 1002 null;
        "default_url" = mkOverride 1002 null;
        "disable_secret_creation" = mkOverride 1002 null;
        "discover_backend_ips" = mkOverride 1002 null;
        "drop_src_path_prefix_parts" = mkOverride 1002 null;
        "dump_request_on_errors" = mkOverride 1002 null;
        "generatePassword" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "ip_filters" = mkOverride 1002 null;
        "load_balancing_policy" = mkOverride 1002 null;
        "managedMetadata" = mkOverride 1002 null;
        "max_concurrent_requests" = mkOverride 1002 null;
        "metric_labels" = mkOverride 1002 null;
        "name" = mkOverride 1002 null;
        "password" = mkOverride 1002 null;
        "passwordRef" = mkOverride 1002 null;
        "response_headers" = mkOverride 1002 null;
        "retry_status_codes" = mkOverride 1002 null;
        "tlsConfig" = mkOverride 1002 null;
        "tokenRef" = mkOverride 1002 null;
        "username" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecIp_filters" = {

      options = {
        "allow_list" = mkOption {
          description = "";
          type = (types.nullOr (types.listOf types.str));
        };
        "deny_list" = mkOption {
          description = "";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "allow_list" = mkOverride 1002 null;
        "deny_list" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecManagedMetadata" = {

      options = {
        "annotations" = mkOption {
          description = "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations";
          type = (types.nullOr (types.attrsOf types.str));
        };
        "labels" = mkOption {
          description = "Labels Map of string keys and values that can be used to organize and categorize\n(scope and select) objects.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels";
          type = (types.nullOr (types.attrsOf types.str));
        };
      };

      config = {
        "annotations" = mkOverride 1002 null;
        "labels" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecPasswordRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefs" = {

      options = {
        "crd" = mkOption {
          description = "CRD describes exist operator's CRD object,\noperator generates access url based on CRD params.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsCrd"));
        };
        "discover_backend_ips" = mkOption {
          description = "DiscoverBackendIPs instructs discovering URLPrefix backend IPs via DNS.";
          type = (types.nullOr types.bool);
        };
        "drop_src_path_prefix_parts" = mkOption {
          description = "DropSrcPathPrefixParts is the number of `/`-delimited request path prefix parts to drop before proxying the request to backend.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#dropping-request-path-prefix) for more details.";
          type = (types.nullOr types.int);
        };
        "headers" = mkOption {
          description = "RequestHeaders represent additional http headers, that vmauth uses\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.68.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "hosts" = mkOption {
          description = "";
          type = (types.nullOr (types.listOf types.str));
        };
        "load_balancing_policy" = mkOption {
          description = "LoadBalancingPolicy defines load balancing policy to use for backend urls.\nSupported policies: least_loaded, first_available.\nSee [here](https://docs.victoriametrics.com/victoriametrics/vmauth/#load-balancing) for more details (default \"least_loaded\")";
          type = (types.nullOr types.str);
        };
        "paths" = mkOption {
          description = "Paths - matched path to route.";
          type = (types.nullOr (types.listOf types.str));
        };
        "query_args" = mkOption {
          description = "QueryArgs appends list of query arguments to generated URL";
          type = (
            types.nullOr (
              coerceAttrsOfSubmodulesToListByKey
                "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsQuery_args"
                "name"
                [ ]
            )
          );
          apply = attrsToList;
        };
        "response_headers" = mkOption {
          description = "ResponseHeaders represent additional http headers, that vmauth adds for request response\nin form of [\"header_key: header_value\"]\nmultiple values for header key:\n[\"header_key: value1,value2\"]\nit's available since 1.93.0 version of vmauth";
          type = (types.nullOr (types.listOf types.str));
        };
        "retry_status_codes" = mkOption {
          description = "RetryStatusCodes defines http status codes in numeric format for request retries\nCan be defined per target or at VMUser.spec level\ne.g. [429,503]";
          type = (types.nullOr (types.listOf types.int));
        };
        "src_headers" = mkOption {
          description = "SrcHeaders is an optional list of headers, which must match request headers.";
          type = (types.nullOr (types.listOf types.str));
        };
        "src_query_args" = mkOption {
          description = "SrcQueryArgs is an optional list of query args, which must match request URL query args.";
          type = (types.nullOr (types.listOf types.str));
        };
        "static" = mkOption {
          description = "Static - user defined url for traffic forward,\nfor instance http://vmsingle:8428";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsStatic")
          );
        };
        "targetRefBasicAuth" = mkOption {
          description = "TargetRefBasicAuth allow an target endpoint to authenticate over basic authentication";
          type = (
            types.nullOr (
              submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsTargetRefBasicAuth"
            )
          );
        };
        "target_path_suffix" = mkOption {
          description = "TargetPathSuffix allows to add some suffix to the target path\nIt allows to hide tenant configuration from user with crd as ref.\nit also may contain any url encoded params.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "crd" = mkOverride 1002 null;
        "discover_backend_ips" = mkOverride 1002 null;
        "drop_src_path_prefix_parts" = mkOverride 1002 null;
        "headers" = mkOverride 1002 null;
        "hosts" = mkOverride 1002 null;
        "load_balancing_policy" = mkOverride 1002 null;
        "paths" = mkOverride 1002 null;
        "query_args" = mkOverride 1002 null;
        "response_headers" = mkOverride 1002 null;
        "retry_status_codes" = mkOverride 1002 null;
        "src_headers" = mkOverride 1002 null;
        "src_query_args" = mkOverride 1002 null;
        "static" = mkOverride 1002 null;
        "targetRefBasicAuth" = mkOverride 1002 null;
        "target_path_suffix" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsCrd" = {

      options = {
        "kind" = mkOption {
          description = "Kind one of:\nVMAgent,VMAlert, VMSingle, VMCluster/vmselect, VMCluster/vmstorage,VMCluster/vminsert,VMAlertManager, VLSingle, VLCluster/vlinsert, VLCluster/vlselect, VLCluster/vlstorage, VTSingle, VTCluster/vtinsert, VTCluster/vtselect, VTCluster/vtstorage and VLAgent";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name target CRD object name";
          type = types.str;
        };
        "namespace" = mkOption {
          description = "Namespace target CRD object namespace.";
          type = types.str;
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsQuery_args" = {

      options = {
        "name" = mkOption {
          description = "Name of query argument";
          type = types.str;
        };
        "values" = mkOption {
          description = "Values of query argument";
          type = (types.listOf types.str);
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsStatic" = {

      options = {
        "url" = mkOption {
          description = "URL http url for given staticRef.";
          type = (types.nullOr types.str);
        };
        "urls" = mkOption {
          description = "URLs allows setting multiple urls for load-balancing at vmauth-side.";
          type = (types.nullOr (types.listOf types.str));
        };
      };

      config = {
        "url" = mkOverride 1002 null;
        "urls" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsTargetRefBasicAuth" = {

      options = {
        "password" = mkOption {
          description = "The secret in the service scrape namespace that contains the password\nfor authentication.\nIt must be at them same namespace as CRD";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsTargetRefBasicAuthPassword"
          );
        };
        "username" = mkOption {
          description = "The secret in the service scrape namespace that contains the username\nfor authentication.\nIt must be at them same namespace as CRD";
          type = (
            submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsTargetRefBasicAuthUsername"
          );
        };
      };

      config = { };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsTargetRefBasicAuthPassword" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTargetRefsTargetRefBasicAuthUsername" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfig" = {

      options = {
        "ca" = mkOption {
          description = "Struct containing the CA cert to use for the targets.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCa"));
        };
        "caFile" = mkOption {
          description = "Path to the CA cert in the container to use for the targets.";
          type = (types.nullOr types.str);
        };
        "cert" = mkOption {
          description = "Struct containing the client cert file for the targets.";
          type = (types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCert"));
        };
        "certFile" = mkOption {
          description = "Path to the client cert file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "insecureSkipVerify" = mkOption {
          description = "Disable target certificate validation.";
          type = (types.nullOr types.bool);
        };
        "keyFile" = mkOption {
          description = "Path to the client key file in the container for the targets.";
          type = (types.nullOr types.str);
        };
        "keySecret" = mkOption {
          description = "Secret containing the client key file for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigKeySecret")
          );
        };
        "serverName" = mkOption {
          description = "Used to verify the hostname for the targets.";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "ca" = mkOverride 1002 null;
        "caFile" = mkOverride 1002 null;
        "cert" = mkOverride 1002 null;
        "certFile" = mkOverride 1002 null;
        "insecureSkipVerify" = mkOverride 1002 null;
        "keyFile" = mkOverride 1002 null;
        "keySecret" = mkOverride 1002 null;
        "serverName" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCa" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCaConfigMap")
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCaSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCaConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCaSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCert" = {

      options = {
        "configMap" = mkOption {
          description = "ConfigMap containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCertConfigMap")
          );
        };
        "secret" = mkOption {
          description = "Secret containing data to use for the targets.";
          type = (
            types.nullOr (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCertSecret")
          );
        };
      };

      config = {
        "configMap" = mkOverride 1002 null;
        "secret" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCertConfigMap" = {

      options = {
        "key" = mkOption {
          description = "The key to select.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the ConfigMap or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigCertSecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTlsConfigKeySecret" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserSpecTokenRef" = {

      options = {
        "key" = mkOption {
          description = "The key of the secret to select from.  Must be a valid secret key.";
          type = types.str;
        };
        "name" = mkOption {
          description = "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names";
          type = (types.nullOr types.str);
        };
        "optional" = mkOption {
          description = "Specify whether the Secret or its key must be defined";
          type = (types.nullOr types.bool);
        };
      };

      config = {
        "name" = mkOverride 1002 null;
        "optional" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserStatus" = {

      options = {
        "conditions" = mkOption {
          description = "Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"";
          type = (
            types.nullOr (
              types.listOf (submoduleOf "operator.victoriametrics.com.v1beta1.VMUserStatusConditions")
            )
          );
        };
        "observedGeneration" = mkOption {
          description = "ObservedGeneration defines current generation picked by operator for the\nreconcile";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "Reason defines human readable error reason";
          type = (types.nullOr types.str);
        };
        "updateStatus" = mkOption {
          description = "UpdateStatus defines a status for update rollout";
          type = (types.nullOr types.str);
        };
      };

      config = {
        "conditions" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
        "reason" = mkOverride 1002 null;
        "updateStatus" = mkOverride 1002 null;
      };

    };
    "operator.victoriametrics.com.v1beta1.VMUserStatusConditions" = {

      options = {
        "lastTransitionTime" = mkOption {
          description = "lastTransitionTime is the last time the condition transitioned from one status to another.";
          type = types.str;
        };
        "lastUpdateTime" = mkOption {
          description = "LastUpdateTime is the last time of given type update.\nThis value is used for status TTL update and removal";
          type = types.str;
        };
        "message" = mkOption {
          description = "message is a human readable message indicating details about the transition.\nThis may be an empty string.";
          type = (types.nullOr types.str);
        };
        "observedGeneration" = mkOption {
          description = "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.";
          type = (types.nullOr types.int);
        };
        "reason" = mkOption {
          description = "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.";
          type = types.str;
        };
        "status" = mkOption {
          description = "status of the condition, one of True, False, Unknown.";
          type = types.str;
        };
        "type" = mkOption {
          description = "Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.";
          type = types.str;
        };
      };

      config = {
        "message" = mkOverride 1002 null;
        "observedGeneration" = mkOverride 1002 null;
      };

    };

  };
in
{
  # all resource versions
  options = {
    resources = {
      "operator.victoriametrics.com"."v1"."VLAgent" = mkOption {
        description = "VLAgent - is a tiny but brave agent, which helps you collect logs from various sources and stores them in VictoriaLogs.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VLAgent" "vlagents" "VLAgent"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1"."VLCluster" = mkOption {
        description = "VLCluster is fast, cost-effective and scalable logs database.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VLCluster" "vlclusters" "VLCluster"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1"."VLSingle" = mkOption {
        description = "VLSingle is fast, cost-effective and scalable logs database.\nVLSingle is the Schema for the API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VLSingle" "vlsingles" "VLSingle"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1"."VMAnomaly" = mkOption {
        description = "VMAnomaly is the Schema for the vmanomalies API.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VMAnomaly" "vmanomalies" "VMAnomaly"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1"."VTCluster" = mkOption {
        description = "VTCluster is fast, cost-effective and scalable traces database.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VTCluster" "vtclusters" "VTCluster"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1"."VTSingle" = mkOption {
        description = "VTSingle is fast, cost-effective and scalable traces database.\nVTSingle is the Schema for the API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VTSingle" "vtsingles" "VTSingle"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VLogs" = mkOption {
        description = "VLogs is fast, cost-effective and scalable logs database.\nVLogs is the Schema for the vlogs API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VLogs" "vlogs" "VLogs"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMAgent" = mkOption {
        description = "VMAgent - is a tiny but brave agent, which helps you collect metrics from various sources and stores them in VictoriaMetrics\nor any other Prometheus-compatible storage system that supports the remote_write protocol.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAgent" "vmagents" "VMAgent"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMAlert" = mkOption {
        description = "VMAlert  executes a list of given alerting or recording rules against configured address.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAlert" "vmalerts" "VMAlert"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMAlertmanager" = mkOption {
        description = "VMAlertmanager represents Victoria-Metrics deployment for Alertmanager.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAlertmanager" "vmalertmanagers"
              "VMAlertmanager"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMAlertmanagerConfig" = mkOption {
        description = "VMAlertmanagerConfig is the Schema for the vmalertmanagerconfigs API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfig"
              "vmalertmanagerconfigs"
              "VMAlertmanagerConfig"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMAuth" = mkOption {
        description = "VMAuth is the Schema for the vmauths API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAuth" "vmauths" "VMAuth"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMCluster" = mkOption {
        description = "VMCluster is fast, cost-effective and scalable time-series database.\nCluster version with";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMCluster" "vmclusters" "VMCluster"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMNodeScrape" = mkOption {
        description = "VMNodeScrape defines discovery for targets placed on kubernetes nodes,\nusually its node-exporters and other host services.\nInternalIP is used as __address__ for scraping.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMNodeScrape" "vmnodescrapes"
              "VMNodeScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMPodScrape" = mkOption {
        description = "VMPodScrape is scrape configuration for pods,\nit generates vmagent's config for scraping pod targets\nbased on selectors.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMPodScrape" "vmpodscrapes"
              "VMPodScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMProbe" = mkOption {
        description = "VMProbe defines a probe for targets, that will be executed with prober,\nlike blackbox exporter.\nIt helps to monitor reachability of target with various checks.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMProbe" "vmprobes" "VMProbe"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMRule" = mkOption {
        description = "VMRule defines rule records for vmalert application";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMRule" "vmrules" "VMRule"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMScrapeConfig" = mkOption {
        description = "VMScrapeConfig specifies a set of targets and parameters describing how to scrape them.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMScrapeConfig" "vmscrapeconfigs"
              "VMScrapeConfig"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMServiceScrape" = mkOption {
        description = "VMServiceScrape is scrape configuration for endpoints associated with\nkubernetes service,\nit generates scrape configuration for vmagent based on selectors.\nresult config will scrape service endpoints";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMServiceScrape" "vmservicescrapes"
              "VMServiceScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMSingle" = mkOption {
        description = "VMSingle  is fast, cost-effective and scalable time-series database.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMSingle" "vmsingles" "VMSingle"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMStaticScrape" = mkOption {
        description = "VMStaticScrape  defines static targets configuration for scraping.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMStaticScrape" "vmstaticscrapes"
              "VMStaticScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "operator.victoriametrics.com"."v1beta1"."VMUser" = mkOption {
        description = "VMUser is the Schema for the vmusers API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMUser" "vmusers" "VMUser"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };

    }
    // {
      "vlAgents" = mkOption {
        description = "VLAgent - is a tiny but brave agent, which helps you collect logs from various sources and stores them in VictoriaLogs.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VLAgent" "vlagents" "VLAgent"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "vlClusters" = mkOption {
        description = "VLCluster is fast, cost-effective and scalable logs database.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VLCluster" "vlclusters" "VLCluster"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "vlSingles" = mkOption {
        description = "VLSingle is fast, cost-effective and scalable logs database.\nVLSingle is the Schema for the API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VLSingle" "vlsingles" "VLSingle"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "vLogs" = mkOption {
        description = "VLogs is fast, cost-effective and scalable logs database.\nVLogs is the Schema for the vlogs API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VLogs" "vlogs" "VLogs"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmAgents" = mkOption {
        description = "VMAgent - is a tiny but brave agent, which helps you collect metrics from various sources and stores them in VictoriaMetrics\nor any other Prometheus-compatible storage system that supports the remote_write protocol.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAgent" "vmagents" "VMAgent"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmAlerts" = mkOption {
        description = "VMAlert  executes a list of given alerting or recording rules against configured address.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAlert" "vmalerts" "VMAlert"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmAlertmanagers" = mkOption {
        description = "VMAlertmanager represents Victoria-Metrics deployment for Alertmanager.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAlertmanager" "vmalertmanagers"
              "VMAlertmanager"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmAlertmanagerConfigs" = mkOption {
        description = "VMAlertmanagerConfig is the Schema for the vmalertmanagerconfigs API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAlertmanagerConfig"
              "vmalertmanagerconfigs"
              "VMAlertmanagerConfig"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmAnomalies" = mkOption {
        description = "VMAnomaly is the Schema for the vmanomalies API.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VMAnomaly" "vmanomalies" "VMAnomaly"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "vmAuths" = mkOption {
        description = "VMAuth is the Schema for the vmauths API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMAuth" "vmauths" "VMAuth"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmClusters" = mkOption {
        description = "VMCluster is fast, cost-effective and scalable time-series database.\nCluster version with";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMCluster" "vmclusters" "VMCluster"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmNodeScrapes" = mkOption {
        description = "VMNodeScrape defines discovery for targets placed on kubernetes nodes,\nusually its node-exporters and other host services.\nInternalIP is used as __address__ for scraping.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMNodeScrape" "vmnodescrapes"
              "VMNodeScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmPodScrapes" = mkOption {
        description = "VMPodScrape is scrape configuration for pods,\nit generates vmagent's config for scraping pod targets\nbased on selectors.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMPodScrape" "vmpodscrapes"
              "VMPodScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmProbes" = mkOption {
        description = "VMProbe defines a probe for targets, that will be executed with prober,\nlike blackbox exporter.\nIt helps to monitor reachability of target with various checks.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMProbe" "vmprobes" "VMProbe"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmRules" = mkOption {
        description = "VMRule defines rule records for vmalert application";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMRule" "vmrules" "VMRule"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmScrapeConfigs" = mkOption {
        description = "VMScrapeConfig specifies a set of targets and parameters describing how to scrape them.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMScrapeConfig" "vmscrapeconfigs"
              "VMScrapeConfig"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmServiceScrapes" = mkOption {
        description = "VMServiceScrape is scrape configuration for endpoints associated with\nkubernetes service,\nit generates scrape configuration for vmagent based on selectors.\nresult config will scrape service endpoints";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMServiceScrape" "vmservicescrapes"
              "VMServiceScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmSingles" = mkOption {
        description = "VMSingle  is fast, cost-effective and scalable time-series database.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMSingle" "vmsingles" "VMSingle"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmStaticScrapes" = mkOption {
        description = "VMStaticScrape  defines static targets configuration for scraping.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMStaticScrape" "vmstaticscrapes"
              "VMStaticScrape"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vmUsers" = mkOption {
        description = "VMUser is the Schema for the vmusers API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1beta1.VMUser" "vmusers" "VMUser"
              "operator.victoriametrics.com"
              "v1beta1"
          )
        );
        default = { };
      };
      "vtClusters" = mkOption {
        description = "VTCluster is fast, cost-effective and scalable traces database.";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VTCluster" "vtclusters" "VTCluster"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };
      "vtSingles" = mkOption {
        description = "VTSingle is fast, cost-effective and scalable traces database.\nVTSingle is the Schema for the API";
        type = (
          types.attrsOf (
            submoduleForDefinition "operator.victoriametrics.com.v1.VTSingle" "vtsingles" "VTSingle"
              "operator.victoriametrics.com"
              "v1"
          )
        );
        default = { };
      };

    };
  };

  config = {
    # expose resource definitions
    inherit definitions;

    # register resource types
    types = [
      {
        name = "vlagents";
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VLAgent";
        attrName = "vlAgents";
      }
      {
        name = "vlclusters";
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VLCluster";
        attrName = "vlClusters";
      }
      {
        name = "vlsingles";
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VLSingle";
        attrName = "vlSingles";
      }
      {
        name = "vmanomalies";
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VMAnomaly";
        attrName = "vmAnomalies";
      }
      {
        name = "vtclusters";
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VTCluster";
        attrName = "vtClusters";
      }
      {
        name = "vtsingles";
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VTSingle";
        attrName = "vtSingles";
      }
      {
        name = "vlogs";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VLogs";
        attrName = "vLogs";
      }
      {
        name = "vmagents";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAgent";
        attrName = "vmAgents";
      }
      {
        name = "vmalerts";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAlert";
        attrName = "vmAlerts";
      }
      {
        name = "vmalertmanagers";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAlertmanager";
        attrName = "vmAlertmanagers";
      }
      {
        name = "vmalertmanagerconfigs";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAlertmanagerConfig";
        attrName = "vmAlertmanagerConfigs";
      }
      {
        name = "vmauths";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAuth";
        attrName = "vmAuths";
      }
      {
        name = "vmclusters";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMCluster";
        attrName = "vmClusters";
      }
      {
        name = "vmnodescrapes";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMNodeScrape";
        attrName = "vmNodeScrapes";
      }
      {
        name = "vmpodscrapes";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMPodScrape";
        attrName = "vmPodScrapes";
      }
      {
        name = "vmprobes";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMProbe";
        attrName = "vmProbes";
      }
      {
        name = "vmrules";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMRule";
        attrName = "vmRules";
      }
      {
        name = "vmscrapeconfigs";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMScrapeConfig";
        attrName = "vmScrapeConfigs";
      }
      {
        name = "vmservicescrapes";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMServiceScrape";
        attrName = "vmServiceScrapes";
      }
      {
        name = "vmsingles";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMSingle";
        attrName = "vmSingles";
      }
      {
        name = "vmstaticscrapes";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMStaticScrape";
        attrName = "vmStaticScrapes";
      }
      {
        name = "vmusers";
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMUser";
        attrName = "vmUsers";
      }
    ];

    resources = {
      "operator.victoriametrics.com"."v1"."VLAgent" = mkAliasDefinitions options.resources."vlAgents";
      "operator.victoriametrics.com"."v1"."VLCluster" = mkAliasDefinitions options.resources."vlClusters";
      "operator.victoriametrics.com"."v1"."VLSingle" = mkAliasDefinitions options.resources."vlSingles";
      "operator.victoriametrics.com"."v1beta1"."VLogs" = mkAliasDefinitions options.resources."vLogs";
      "operator.victoriametrics.com"."v1beta1"."VMAgent" =
        mkAliasDefinitions
          options.resources."vmAgents";
      "operator.victoriametrics.com"."v1beta1"."VMAlert" =
        mkAliasDefinitions
          options.resources."vmAlerts";
      "operator.victoriametrics.com"."v1beta1"."VMAlertmanager" =
        mkAliasDefinitions
          options.resources."vmAlertmanagers";
      "operator.victoriametrics.com"."v1beta1"."VMAlertmanagerConfig" =
        mkAliasDefinitions
          options.resources."vmAlertmanagerConfigs";
      "operator.victoriametrics.com"."v1"."VMAnomaly" =
        mkAliasDefinitions
          options.resources."vmAnomalies";
      "operator.victoriametrics.com"."v1beta1"."VMAuth" = mkAliasDefinitions options.resources."vmAuths";
      "operator.victoriametrics.com"."v1beta1"."VMCluster" =
        mkAliasDefinitions
          options.resources."vmClusters";
      "operator.victoriametrics.com"."v1beta1"."VMNodeScrape" =
        mkAliasDefinitions
          options.resources."vmNodeScrapes";
      "operator.victoriametrics.com"."v1beta1"."VMPodScrape" =
        mkAliasDefinitions
          options.resources."vmPodScrapes";
      "operator.victoriametrics.com"."v1beta1"."VMProbe" =
        mkAliasDefinitions
          options.resources."vmProbes";
      "operator.victoriametrics.com"."v1beta1"."VMRule" = mkAliasDefinitions options.resources."vmRules";
      "operator.victoriametrics.com"."v1beta1"."VMScrapeConfig" =
        mkAliasDefinitions
          options.resources."vmScrapeConfigs";
      "operator.victoriametrics.com"."v1beta1"."VMServiceScrape" =
        mkAliasDefinitions
          options.resources."vmServiceScrapes";
      "operator.victoriametrics.com"."v1beta1"."VMSingle" =
        mkAliasDefinitions
          options.resources."vmSingles";
      "operator.victoriametrics.com"."v1beta1"."VMStaticScrape" =
        mkAliasDefinitions
          options.resources."vmStaticScrapes";
      "operator.victoriametrics.com"."v1beta1"."VMUser" = mkAliasDefinitions options.resources."vmUsers";
      "operator.victoriametrics.com"."v1"."VTCluster" = mkAliasDefinitions options.resources."vtClusters";
      "operator.victoriametrics.com"."v1"."VTSingle" = mkAliasDefinitions options.resources."vtSingles";

    };

    # make all namespaced resources default to the
    # application's namespace
    defaults = [
      {
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VLAgent";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VLCluster";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VLSingle";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VMAnomaly";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VTCluster";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1";
        kind = "VTSingle";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VLogs";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAgent";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAlert";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAlertmanager";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAlertmanagerConfig";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMAuth";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMCluster";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMNodeScrape";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMPodScrape";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMProbe";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMRule";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMScrapeConfig";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMServiceScrape";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMSingle";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMStaticScrape";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
      {
        group = "operator.victoriametrics.com";
        version = "v1beta1";
        kind = "VMUser";
        default.metadata.namespace = lib.mkDefault config.namespace;
      }
    ];
  };
}
